{"ast":null,"code":"import { createAnatomy } from '@zag-js/anatomy';\nimport { setElementValue, raf, contains, dataAttr, ariaAttr, isComposingEvent, isApple } from '@zag-js/dom-query';\nimport { createMachine } from '@zag-js/core';\nimport { trackInteractOutside } from '@zag-js/interact-outside';\nimport { createProps } from '@zag-js/types';\nimport { createSplitProps } from '@zag-js/utils';\n\n// src/editable.anatomy.ts\nvar anatomy = createAnatomy(\"editable\").parts(\"root\", \"area\", \"label\", \"preview\", \"input\", \"editTrigger\", \"submitTrigger\", \"cancelTrigger\", \"control\");\nvar parts = anatomy.build();\n\n// src/editable.dom.ts\nvar getRootId = ctx => ctx.ids?.root ?? `editable:${ctx.id}`;\nvar getAreaId = ctx => ctx.ids?.area ?? `editable:${ctx.id}:area`;\nvar getLabelId = ctx => ctx.ids?.label ?? `editable:${ctx.id}:label`;\nvar getPreviewId = ctx => ctx.ids?.preview ?? `editable:${ctx.id}:preview`;\nvar getInputId = ctx => ctx.ids?.input ?? `editable:${ctx.id}:input`;\nvar getControlId = ctx => ctx.ids?.control ?? `editable:${ctx.id}:control`;\nvar getSubmitTriggerId = ctx => ctx.ids?.submitTrigger ?? `editable:${ctx.id}:submit`;\nvar getCancelTriggerId = ctx => ctx.ids?.cancelTrigger ?? `editable:${ctx.id}:cancel`;\nvar getEditTriggerId = ctx => ctx.ids?.editTrigger ?? `editable:${ctx.id}:edit`;\nvar getInputEl = ctx => ctx.getById(getInputId(ctx));\nvar getPreviewEl = ctx => ctx.getById(getPreviewId(ctx));\nvar getSubmitTriggerEl = ctx => ctx.getById(getSubmitTriggerId(ctx));\nvar getCancelTriggerEl = ctx => ctx.getById(getCancelTriggerId(ctx));\nvar getEditTriggerEl = ctx => ctx.getById(getEditTriggerId(ctx));\n\n// src/editable.connect.ts\nfunction connect(service, normalize) {\n  const {\n    state,\n    context,\n    send,\n    prop,\n    scope,\n    computed\n  } = service;\n  const disabled = prop(\"disabled\");\n  const interactive = computed(\"isInteractive\");\n  const readOnly = prop(\"readOnly\");\n  const invalid = prop(\"invalid\");\n  const autoResize = prop(\"autoResize\");\n  const translations = prop(\"translations\");\n  const editing = state.matches(\"edit\");\n  const placeholderProp = prop(\"placeholder\");\n  const placeholder = typeof placeholderProp === \"string\" ? {\n    edit: placeholderProp,\n    preview: placeholderProp\n  } : placeholderProp;\n  const value = context.get(\"value\");\n  const empty = value.trim() === \"\";\n  const valueText = empty ? placeholder?.preview ?? \"\" : value;\n  return {\n    editing,\n    empty,\n    value,\n    valueText,\n    setValue(value2) {\n      send({\n        type: \"VALUE.SET\",\n        value: value2,\n        src: \"setValue\"\n      });\n    },\n    clearValue() {\n      send({\n        type: \"VALUE.SET\",\n        value: \"\",\n        src: \"clearValue\"\n      });\n    },\n    edit() {\n      if (!interactive) return;\n      send({\n        type: \"EDIT\"\n      });\n    },\n    cancel() {\n      if (!interactive) return;\n      send({\n        type: \"CANCEL\"\n      });\n    },\n    submit() {\n      if (!interactive) return;\n      send({\n        type: \"SUBMIT\"\n      });\n    },\n    getRootProps() {\n      return normalize.element({\n        ...parts.root.attrs,\n        id: getRootId(scope),\n        dir: prop(\"dir\")\n      });\n    },\n    getAreaProps() {\n      return normalize.element({\n        ...parts.area.attrs,\n        id: getAreaId(scope),\n        dir: prop(\"dir\"),\n        style: autoResize ? {\n          display: \"inline-grid\"\n        } : void 0,\n        \"data-focus\": dataAttr(editing),\n        \"data-disabled\": dataAttr(disabled),\n        \"data-placeholder-shown\": dataAttr(empty)\n      });\n    },\n    getLabelProps() {\n      return normalize.label({\n        ...parts.label.attrs,\n        id: getLabelId(scope),\n        dir: prop(\"dir\"),\n        htmlFor: getInputId(scope),\n        \"data-focus\": dataAttr(editing),\n        \"data-invalid\": dataAttr(invalid),\n        onClick() {\n          if (editing) return;\n          const previewEl = getPreviewEl(scope);\n          previewEl?.focus({\n            preventScroll: true\n          });\n        }\n      });\n    },\n    getInputProps() {\n      return normalize.input({\n        ...parts.input.attrs,\n        dir: prop(\"dir\"),\n        \"aria-label\": translations?.input,\n        name: prop(\"name\"),\n        form: prop(\"form\"),\n        id: getInputId(scope),\n        hidden: autoResize ? void 0 : !editing,\n        placeholder: placeholder?.edit,\n        maxLength: prop(\"maxLength\"),\n        required: prop(\"required\"),\n        disabled,\n        \"data-disabled\": dataAttr(disabled),\n        readOnly,\n        \"data-readonly\": dataAttr(readOnly),\n        \"aria-invalid\": ariaAttr(invalid),\n        \"data-invalid\": dataAttr(invalid),\n        \"data-autoresize\": dataAttr(autoResize),\n        defaultValue: value,\n        size: autoResize ? 1 : void 0,\n        onChange(event) {\n          send({\n            type: \"VALUE.SET\",\n            src: \"input.change\",\n            value: event.currentTarget.value\n          });\n        },\n        onKeyDown(event) {\n          if (event.defaultPrevented) return;\n          if (isComposingEvent(event)) return;\n          const keyMap = {\n            Escape() {\n              send({\n                type: \"CANCEL\"\n              });\n              event.preventDefault();\n            },\n            Enter(event2) {\n              if (!computed(\"submitOnEnter\")) return;\n              const {\n                localName\n              } = event2.currentTarget;\n              if (localName === \"textarea\") {\n                const submitMod = isApple() ? event2.metaKey : event2.ctrlKey;\n                if (!submitMod) return;\n                send({\n                  type: \"SUBMIT\",\n                  src: \"keydown.enter\"\n                });\n                return;\n              }\n              if (localName === \"input\" && !event2.shiftKey && !event2.metaKey) {\n                send({\n                  type: \"SUBMIT\",\n                  src: \"keydown.enter\"\n                });\n                event2.preventDefault();\n              }\n            }\n          };\n          const exec = keyMap[event.key];\n          if (exec) {\n            exec(event);\n          }\n        },\n        style: autoResize ? {\n          gridArea: \"1 / 1 / auto / auto\",\n          visibility: !editing ? \"hidden\" : void 0\n        } : void 0\n      });\n    },\n    getPreviewProps() {\n      return normalize.element({\n        id: getPreviewId(scope),\n        ...parts.preview.attrs,\n        dir: prop(\"dir\"),\n        \"data-placeholder-shown\": dataAttr(empty),\n        \"aria-readonly\": ariaAttr(readOnly),\n        \"data-readonly\": dataAttr(disabled),\n        \"data-disabled\": dataAttr(disabled),\n        \"aria-disabled\": ariaAttr(disabled),\n        \"aria-invalid\": ariaAttr(invalid),\n        \"data-invalid\": dataAttr(invalid),\n        \"aria-label\": translations?.edit,\n        \"data-autoresize\": dataAttr(autoResize),\n        children: valueText,\n        hidden: autoResize ? void 0 : editing,\n        tabIndex: interactive ? 0 : void 0,\n        onClick() {\n          if (!interactive) return;\n          if (prop(\"activationMode\") !== \"click\") return;\n          send({\n            type: \"EDIT\",\n            src: \"click\"\n          });\n        },\n        onFocus() {\n          if (!interactive) return;\n          if (prop(\"activationMode\") !== \"focus\") return;\n          send({\n            type: \"EDIT\",\n            src: \"focus\"\n          });\n        },\n        onDoubleClick(event) {\n          if (event.defaultPrevented) return;\n          if (!interactive) return;\n          if (prop(\"activationMode\") !== \"dblclick\") return;\n          send({\n            type: \"EDIT\",\n            src: \"dblclick\"\n          });\n        },\n        style: autoResize ? {\n          whiteSpace: \"pre\",\n          userSelect: \"none\",\n          gridArea: \"1 / 1 / auto / auto\",\n          visibility: editing ? \"hidden\" : void 0,\n          // in event the preview overflow's the parent element\n          overflow: \"hidden\",\n          textOverflow: \"ellipsis\"\n        } : void 0\n      });\n    },\n    getEditTriggerProps() {\n      return normalize.button({\n        ...parts.editTrigger.attrs,\n        id: getEditTriggerId(scope),\n        dir: prop(\"dir\"),\n        \"aria-label\": translations?.edit,\n        hidden: editing,\n        type: \"button\",\n        disabled,\n        onClick(event) {\n          if (event.defaultPrevented) return;\n          if (!interactive) return;\n          send({\n            type: \"EDIT\",\n            src: \"edit.click\"\n          });\n        }\n      });\n    },\n    getControlProps() {\n      return normalize.element({\n        id: getControlId(scope),\n        ...parts.control.attrs,\n        dir: prop(\"dir\")\n      });\n    },\n    getSubmitTriggerProps() {\n      return normalize.button({\n        ...parts.submitTrigger.attrs,\n        dir: prop(\"dir\"),\n        id: getSubmitTriggerId(scope),\n        \"aria-label\": translations?.submit,\n        hidden: !editing,\n        disabled,\n        type: \"button\",\n        onClick(event) {\n          if (event.defaultPrevented) return;\n          if (!interactive) return;\n          send({\n            type: \"SUBMIT\",\n            src: \"submit.click\"\n          });\n        }\n      });\n    },\n    getCancelTriggerProps() {\n      return normalize.button({\n        ...parts.cancelTrigger.attrs,\n        dir: prop(\"dir\"),\n        \"aria-label\": translations?.cancel,\n        id: getCancelTriggerId(scope),\n        hidden: !editing,\n        type: \"button\",\n        disabled,\n        onClick(event) {\n          if (event.defaultPrevented) return;\n          if (!interactive) return;\n          send({\n            type: \"CANCEL\",\n            src: \"cancel.click\"\n          });\n        }\n      });\n    }\n  };\n}\nvar machine = createMachine({\n  props({\n    props: props2\n  }) {\n    return {\n      activationMode: \"focus\",\n      submitMode: \"both\",\n      defaultValue: \"\",\n      selectOnFocus: true,\n      ...props2,\n      translations: {\n        input: \"editable input\",\n        edit: \"edit\",\n        submit: \"submit\",\n        cancel: \"cancel\",\n        ...props2.translations\n      }\n    };\n  },\n  initialState({\n    prop\n  }) {\n    const edit = prop(\"edit\") || prop(\"defaultEdit\");\n    return edit ? \"edit\" : \"preview\";\n  },\n  entry: [\"focusInputIfNeeded\"],\n  context: ({\n    bindable,\n    prop\n  }) => {\n    return {\n      value: bindable(() => ({\n        defaultValue: prop(\"defaultValue\"),\n        value: prop(\"value\"),\n        onChange(value) {\n          return prop(\"onValueChange\")?.({\n            value\n          });\n        }\n      })),\n      previousValue: bindable(() => ({\n        defaultValue: \"\"\n      }))\n    };\n  },\n  watch({\n    track,\n    action,\n    context,\n    prop\n  }) {\n    track([() => context.get(\"value\")], () => {\n      action([\"syncInputValue\"]);\n    });\n    track([() => prop(\"edit\")], () => {\n      action([\"toggleEditing\"]);\n    });\n  },\n  computed: {\n    submitOnEnter({\n      prop\n    }) {\n      return [\"both\", \"enter\"].includes(prop(\"submitMode\"));\n    },\n    submitOnBlur({\n      prop\n    }) {\n      return [\"both\", \"blur\"].includes(prop(\"submitMode\"));\n    },\n    isInteractive({\n      prop\n    }) {\n      return !(prop(\"disabled\") || prop(\"readOnly\"));\n    }\n  },\n  on: {\n    \"VALUE.SET\": {\n      actions: [\"setValue\"]\n    }\n  },\n  states: {\n    preview: {\n      entry: [\"blurInputIfNeeded\"],\n      on: {\n        \"CONTROLLED.EDIT\": {\n          target: \"edit\",\n          actions: [\"setPreviousValue\", \"focusInput\"]\n        },\n        EDIT: [{\n          guard: \"isEditControlled\",\n          actions: [\"invokeOnEdit\"]\n        }, {\n          target: \"edit\",\n          actions: [\"setPreviousValue\", \"focusInput\", \"invokeOnEdit\"]\n        }]\n      }\n    },\n    edit: {\n      effects: [\"trackInteractOutside\"],\n      on: {\n        \"CONTROLLED.PREVIEW\": [{\n          guard: \"isSubmitEvent\",\n          target: \"preview\",\n          actions: [\"setPreviousValue\", \"restoreFocus\", \"invokeOnSubmit\"]\n        }, {\n          target: \"preview\",\n          actions: [\"revertValue\", \"restoreFocus\", \"invokeOnCancel\"]\n        }],\n        CANCEL: [{\n          guard: \"isEditControlled\",\n          actions: [\"invokeOnPreview\"]\n        }, {\n          target: \"preview\",\n          actions: [\"revertValue\", \"restoreFocus\", \"invokeOnCancel\", \"invokeOnPreview\"]\n        }],\n        SUBMIT: [{\n          guard: \"isEditControlled\",\n          actions: [\"invokeOnPreview\"]\n        }, {\n          target: \"preview\",\n          actions: [\"setPreviousValue\", \"restoreFocus\", \"invokeOnSubmit\", \"invokeOnPreview\"]\n        }]\n      }\n    }\n  },\n  implementations: {\n    guards: {\n      isEditControlled: ({\n        prop\n      }) => prop(\"edit\") != void 0,\n      isSubmitEvent: ({\n        event\n      }) => event.previousEvent?.type === \"SUBMIT\"\n    },\n    effects: {\n      trackInteractOutside({\n        send,\n        scope,\n        prop,\n        computed\n      }) {\n        return trackInteractOutside(getInputEl(scope), {\n          exclude(target) {\n            const ignore = [getCancelTriggerEl(scope), getSubmitTriggerEl(scope)];\n            return ignore.some(el => contains(el, target));\n          },\n          onFocusOutside: prop(\"onFocusOutside\"),\n          onPointerDownOutside: prop(\"onPointerDownOutside\"),\n          onInteractOutside(event) {\n            prop(\"onInteractOutside\")?.(event);\n            if (event.defaultPrevented) return;\n            const {\n              focusable\n            } = event.detail;\n            send({\n              type: computed(\"submitOnBlur\") ? \"SUBMIT\" : \"CANCEL\",\n              src: \"interact-outside\",\n              focusable\n            });\n          }\n        });\n      }\n    },\n    actions: {\n      restoreFocus({\n        event,\n        scope,\n        prop\n      }) {\n        if (event.focusable) return;\n        raf(() => {\n          const finalEl = prop(\"finalFocusEl\")?.() ?? getEditTriggerEl(scope);\n          finalEl?.focus({\n            preventScroll: true\n          });\n        });\n      },\n      clearValue({\n        context\n      }) {\n        context.set(\"value\", \"\");\n      },\n      focusInputIfNeeded({\n        action,\n        prop\n      }) {\n        const edit = prop(\"edit\") || prop(\"defaultEdit\");\n        if (!edit) return;\n        action([\"focusInput\"]);\n      },\n      focusInput({\n        scope,\n        prop\n      }) {\n        raf(() => {\n          const inputEl = getInputEl(scope);\n          if (!inputEl) return;\n          if (prop(\"selectOnFocus\")) {\n            inputEl.select();\n          } else {\n            inputEl.focus({\n              preventScroll: true\n            });\n          }\n        });\n      },\n      invokeOnCancel({\n        prop,\n        context\n      }) {\n        const prev = context.get(\"previousValue\");\n        prop(\"onValueRevert\")?.({\n          value: prev\n        });\n      },\n      invokeOnSubmit({\n        prop,\n        context\n      }) {\n        const value = context.get(\"value\");\n        prop(\"onValueCommit\")?.({\n          value\n        });\n      },\n      invokeOnEdit({\n        prop\n      }) {\n        prop(\"onEditChange\")?.({\n          edit: true\n        });\n      },\n      invokeOnPreview({\n        prop\n      }) {\n        prop(\"onEditChange\")?.({\n          edit: false\n        });\n      },\n      toggleEditing({\n        prop,\n        send,\n        event\n      }) {\n        send({\n          type: prop(\"edit\") ? \"CONTROLLED.EDIT\" : \"CONTROLLED.PREVIEW\",\n          previousEvent: event\n        });\n      },\n      syncInputValue({\n        context,\n        scope\n      }) {\n        const inputEl = getInputEl(scope);\n        if (!inputEl) return;\n        setElementValue(inputEl, context.get(\"value\"));\n      },\n      setValue({\n        context,\n        prop,\n        event\n      }) {\n        const max = prop(\"maxLength\");\n        const value = max != null ? event.value.slice(0, max) : event.value;\n        context.set(\"value\", value);\n      },\n      setPreviousValue({\n        context\n      }) {\n        context.set(\"previousValue\", context.get(\"value\"));\n      },\n      revertValue({\n        context\n      }) {\n        const value = context.get(\"previousValue\");\n        if (!value) return;\n        context.set(\"value\", value);\n      },\n      blurInputIfNeeded({\n        scope\n      }) {\n        getInputEl(scope)?.blur();\n      }\n    }\n  }\n});\nvar props = createProps()([\"activationMode\", \"autoResize\", \"dir\", \"disabled\", \"finalFocusEl\", \"form\", \"getRootNode\", \"id\", \"ids\", \"invalid\", \"maxLength\", \"name\", \"onEditChange\", \"onFocusOutside\", \"onInteractOutside\", \"onPointerDownOutside\", \"onValueChange\", \"onValueCommit\", \"onValueRevert\", \"placeholder\", \"readOnly\", \"required\", \"selectOnFocus\", \"edit\", \"defaultEdit\", \"submitMode\", \"translations\", \"defaultValue\", \"value\"]);\nvar splitProps = createSplitProps(props);\nexport { anatomy, connect, machine, props, splitProps };","map":null,"metadata":{},"sourceType":"module"}