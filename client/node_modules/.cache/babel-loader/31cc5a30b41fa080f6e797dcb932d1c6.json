{"ast":null,"code":"import { createAnatomy } from '@zag-js/anatomy';\nimport { ListCollection } from '@zag-js/collection';\nimport { raf, getInitialFocus, observeAttributes, trackFormControl, getByTypeahead, scrollIntoView, isSelfTarget, isValidTabEvent, getEventKey, getEventTarget, isEditableElement, visuallyHiddenStyle, dataAttr, ariaAttr } from '@zag-js/dom-query';\nimport { getPlacement, getPlacementStyles } from '@zag-js/popper';\nimport { addOrRemove, isEqual, createSplitProps, ensure } from '@zag-js/utils';\nimport { createGuards, createMachine } from '@zag-js/core';\nimport { trackDismissableElement } from '@zag-js/dismissable';\nimport { createProps } from '@zag-js/types';\n\n// src/select.anatomy.ts\nvar anatomy = createAnatomy(\"select\").parts(\"label\", \"positioner\", \"trigger\", \"indicator\", \"clearTrigger\", \"item\", \"itemText\", \"itemIndicator\", \"itemGroup\", \"itemGroupLabel\", \"list\", \"content\", \"root\", \"control\", \"valueText\");\nvar parts = anatomy.build();\nvar collection = options => {\n  return new ListCollection(options);\n};\ncollection.empty = () => {\n  return new ListCollection({\n    items: []\n  });\n};\n\n// src/select.dom.ts\nvar getRootId = ctx => ctx.ids?.root ?? `select:${ctx.id}`;\nvar getContentId = ctx => ctx.ids?.content ?? `select:${ctx.id}:content`;\nvar getTriggerId = ctx => ctx.ids?.trigger ?? `select:${ctx.id}:trigger`;\nvar getClearTriggerId = ctx => ctx.ids?.clearTrigger ?? `select:${ctx.id}:clear-trigger`;\nvar getLabelId = ctx => ctx.ids?.label ?? `select:${ctx.id}:label`;\nvar getControlId = ctx => ctx.ids?.control ?? `select:${ctx.id}:control`;\nvar getItemId = (ctx, id) => ctx.ids?.item?.(id) ?? `select:${ctx.id}:option:${id}`;\nvar getHiddenSelectId = ctx => ctx.ids?.hiddenSelect ?? `select:${ctx.id}:select`;\nvar getPositionerId = ctx => ctx.ids?.positioner ?? `select:${ctx.id}:positioner`;\nvar getItemGroupId = (ctx, id) => ctx.ids?.itemGroup?.(id) ?? `select:${ctx.id}:optgroup:${id}`;\nvar getItemGroupLabelId = (ctx, id) => ctx.ids?.itemGroupLabel?.(id) ?? `select:${ctx.id}:optgroup-label:${id}`;\nvar getHiddenSelectEl = ctx => ctx.getById(getHiddenSelectId(ctx));\nvar getContentEl = ctx => ctx.getById(getContentId(ctx));\nvar getTriggerEl = ctx => ctx.getById(getTriggerId(ctx));\nvar getClearTriggerEl = ctx => ctx.getById(getClearTriggerId(ctx));\nvar getPositionerEl = ctx => ctx.getById(getPositionerId(ctx));\nvar getItemEl = (ctx, id) => ctx.getById(getItemId(ctx, id));\n\n// src/select.connect.ts\nfunction connect(service, normalize) {\n  const {\n    context,\n    prop,\n    scope,\n    state,\n    computed,\n    send\n  } = service;\n  const disabled = prop(\"disabled\") || context.get(\"fieldsetDisabled\");\n  const invalid = prop(\"invalid\");\n  const readOnly = prop(\"readOnly\");\n  const composite = prop(\"composite\");\n  const collection2 = prop(\"collection\");\n  const open = state.hasTag(\"open\");\n  const focused = state.matches(\"focused\");\n  const highlightedValue = context.get(\"highlightedValue\");\n  const highlightedItem = context.get(\"highlightedItem\");\n  const selectedItems = context.get(\"selectedItems\");\n  const currentPlacement = context.get(\"currentPlacement\");\n  const isTypingAhead = computed(\"isTypingAhead\");\n  const interactive = computed(\"isInteractive\");\n  const ariaActiveDescendant = highlightedValue ? getItemId(scope, highlightedValue) : void 0;\n  function getItemState(props2) {\n    const _disabled = collection2.getItemDisabled(props2.item);\n    const value = collection2.getItemValue(props2.item);\n    ensure(value, () => `[zag-js] No value found for item ${JSON.stringify(props2.item)}`);\n    return {\n      value,\n      disabled: Boolean(disabled || _disabled),\n      highlighted: highlightedValue === value,\n      selected: context.get(\"value\").includes(value)\n    };\n  }\n  const popperStyles = getPlacementStyles({\n    ...prop(\"positioning\"),\n    placement: currentPlacement\n  });\n  return {\n    open,\n    focused,\n    empty: context.get(\"value\").length === 0,\n    highlightedItem,\n    highlightedValue,\n    selectedItems,\n    hasSelectedItems: computed(\"hasSelectedItems\"),\n    value: context.get(\"value\"),\n    valueAsString: context.get(\"valueAsString\"),\n    collection: collection2,\n    multiple: !!prop(\"multiple\"),\n    disabled: !!disabled,\n    reposition(options = {}) {\n      send({\n        type: \"POSITIONING.SET\",\n        options\n      });\n    },\n    focus() {\n      getTriggerEl(scope)?.focus({\n        preventScroll: true\n      });\n    },\n    setOpen(nextOpen) {\n      const open2 = state.hasTag(\"open\");\n      if (open2 === nextOpen) return;\n      send({\n        type: nextOpen ? \"OPEN\" : \"CLOSE\"\n      });\n    },\n    selectValue(value) {\n      send({\n        type: \"ITEM.SELECT\",\n        value\n      });\n    },\n    setValue(value) {\n      send({\n        type: \"VALUE.SET\",\n        value\n      });\n    },\n    selectAll() {\n      send({\n        type: \"VALUE.SET\",\n        value: collection2.getValues()\n      });\n    },\n    highlightValue(value) {\n      send({\n        type: \"HIGHLIGHTED_VALUE.SET\",\n        value\n      });\n    },\n    clearValue(value) {\n      if (value) {\n        send({\n          type: \"ITEM.CLEAR\",\n          value\n        });\n      } else {\n        send({\n          type: \"VALUE.CLEAR\"\n        });\n      }\n    },\n    getItemState,\n    getRootProps() {\n      return normalize.element({\n        ...parts.root.attrs,\n        dir: prop(\"dir\"),\n        id: getRootId(scope),\n        \"data-invalid\": dataAttr(invalid),\n        \"data-readonly\": dataAttr(readOnly)\n      });\n    },\n    getLabelProps() {\n      return normalize.label({\n        dir: prop(\"dir\"),\n        id: getLabelId(scope),\n        ...parts.label.attrs,\n        \"data-disabled\": dataAttr(disabled),\n        \"data-invalid\": dataAttr(invalid),\n        \"data-readonly\": dataAttr(readOnly),\n        htmlFor: getHiddenSelectId(scope),\n        onClick(event) {\n          if (event.defaultPrevented) return;\n          if (disabled) return;\n          getTriggerEl(scope)?.focus({\n            preventScroll: true\n          });\n        }\n      });\n    },\n    getControlProps() {\n      return normalize.element({\n        ...parts.control.attrs,\n        dir: prop(\"dir\"),\n        id: getControlId(scope),\n        \"data-state\": open ? \"open\" : \"closed\",\n        \"data-focus\": dataAttr(focused),\n        \"data-disabled\": dataAttr(disabled),\n        \"data-invalid\": dataAttr(invalid)\n      });\n    },\n    getValueTextProps() {\n      return normalize.element({\n        ...parts.valueText.attrs,\n        dir: prop(\"dir\"),\n        \"data-disabled\": dataAttr(disabled),\n        \"data-invalid\": dataAttr(invalid),\n        \"data-focus\": dataAttr(focused)\n      });\n    },\n    getTriggerProps() {\n      return normalize.button({\n        id: getTriggerId(scope),\n        disabled,\n        dir: prop(\"dir\"),\n        type: \"button\",\n        role: \"combobox\",\n        \"aria-controls\": getContentId(scope),\n        \"aria-expanded\": open,\n        \"aria-haspopup\": \"listbox\",\n        \"data-state\": open ? \"open\" : \"closed\",\n        \"aria-invalid\": invalid,\n        \"aria-labelledby\": getLabelId(scope),\n        ...parts.trigger.attrs,\n        \"data-disabled\": dataAttr(disabled),\n        \"data-invalid\": dataAttr(invalid),\n        \"data-readonly\": dataAttr(readOnly),\n        \"data-placement\": currentPlacement,\n        \"data-placeholder-shown\": dataAttr(!computed(\"hasSelectedItems\")),\n        onClick(event) {\n          if (!interactive) return;\n          if (event.defaultPrevented) return;\n          send({\n            type: \"TRIGGER.CLICK\"\n          });\n        },\n        onFocus() {\n          send({\n            type: \"TRIGGER.FOCUS\"\n          });\n        },\n        onBlur() {\n          send({\n            type: \"TRIGGER.BLUR\"\n          });\n        },\n        onKeyDown(event) {\n          if (event.defaultPrevented) return;\n          if (!interactive) return;\n          const keyMap = {\n            ArrowUp() {\n              send({\n                type: \"TRIGGER.ARROW_UP\"\n              });\n            },\n            ArrowDown(event2) {\n              send({\n                type: event2.altKey ? \"OPEN\" : \"TRIGGER.ARROW_DOWN\"\n              });\n            },\n            ArrowLeft() {\n              send({\n                type: \"TRIGGER.ARROW_LEFT\"\n              });\n            },\n            ArrowRight() {\n              send({\n                type: \"TRIGGER.ARROW_RIGHT\"\n              });\n            },\n            Home() {\n              send({\n                type: \"TRIGGER.HOME\"\n              });\n            },\n            End() {\n              send({\n                type: \"TRIGGER.END\"\n              });\n            },\n            Enter() {\n              send({\n                type: \"TRIGGER.ENTER\"\n              });\n            },\n            Space(event2) {\n              if (isTypingAhead) {\n                send({\n                  type: \"TRIGGER.TYPEAHEAD\",\n                  key: event2.key\n                });\n              } else {\n                send({\n                  type: \"TRIGGER.ENTER\"\n                });\n              }\n            }\n          };\n          const exec = keyMap[getEventKey(event, {\n            dir: prop(\"dir\"),\n            orientation: \"vertical\"\n          })];\n          if (exec) {\n            exec(event);\n            event.preventDefault();\n            return;\n          }\n          if (getByTypeahead.isValidEvent(event)) {\n            send({\n              type: \"TRIGGER.TYPEAHEAD\",\n              key: event.key\n            });\n            event.preventDefault();\n          }\n        }\n      });\n    },\n    getIndicatorProps() {\n      return normalize.element({\n        ...parts.indicator.attrs,\n        dir: prop(\"dir\"),\n        \"aria-hidden\": true,\n        \"data-state\": open ? \"open\" : \"closed\",\n        \"data-disabled\": dataAttr(disabled),\n        \"data-invalid\": dataAttr(invalid),\n        \"data-readonly\": dataAttr(readOnly)\n      });\n    },\n    getItemProps(props2) {\n      const itemState = getItemState(props2);\n      return normalize.element({\n        id: getItemId(scope, itemState.value),\n        role: \"option\",\n        ...parts.item.attrs,\n        dir: prop(\"dir\"),\n        \"data-value\": itemState.value,\n        \"aria-selected\": itemState.selected,\n        \"data-state\": itemState.selected ? \"checked\" : \"unchecked\",\n        \"data-highlighted\": dataAttr(itemState.highlighted),\n        \"data-disabled\": dataAttr(itemState.disabled),\n        \"aria-disabled\": ariaAttr(itemState.disabled),\n        onPointerMove(event) {\n          if (itemState.disabled || event.pointerType !== \"mouse\") return;\n          if (itemState.value === highlightedValue) return;\n          send({\n            type: \"ITEM.POINTER_MOVE\",\n            value: itemState.value\n          });\n        },\n        onClick(event) {\n          if (event.defaultPrevented) return;\n          if (itemState.disabled) return;\n          send({\n            type: \"ITEM.CLICK\",\n            src: \"pointerup\",\n            value: itemState.value\n          });\n        },\n        onPointerLeave(event) {\n          if (itemState.disabled) return;\n          if (props2.persistFocus) return;\n          if (event.pointerType !== \"mouse\") return;\n          const pointerMoved = service.event.previous()?.type.includes(\"POINTER\");\n          if (!pointerMoved) return;\n          send({\n            type: \"ITEM.POINTER_LEAVE\"\n          });\n        }\n      });\n    },\n    getItemTextProps(props2) {\n      const itemState = getItemState(props2);\n      return normalize.element({\n        ...parts.itemText.attrs,\n        \"data-state\": itemState.selected ? \"checked\" : \"unchecked\",\n        \"data-disabled\": dataAttr(itemState.disabled),\n        \"data-highlighted\": dataAttr(itemState.highlighted)\n      });\n    },\n    getItemIndicatorProps(props2) {\n      const itemState = getItemState(props2);\n      return normalize.element({\n        \"aria-hidden\": true,\n        ...parts.itemIndicator.attrs,\n        \"data-state\": itemState.selected ? \"checked\" : \"unchecked\",\n        hidden: !itemState.selected\n      });\n    },\n    getItemGroupLabelProps(props2) {\n      const {\n        htmlFor\n      } = props2;\n      return normalize.element({\n        ...parts.itemGroupLabel.attrs,\n        id: getItemGroupLabelId(scope, htmlFor),\n        dir: prop(\"dir\"),\n        role: \"presentation\"\n      });\n    },\n    getItemGroupProps(props2) {\n      const {\n        id\n      } = props2;\n      return normalize.element({\n        ...parts.itemGroup.attrs,\n        \"data-disabled\": dataAttr(disabled),\n        id: getItemGroupId(scope, id),\n        \"aria-labelledby\": getItemGroupLabelId(scope, id),\n        role: \"group\",\n        dir: prop(\"dir\")\n      });\n    },\n    getClearTriggerProps() {\n      return normalize.button({\n        ...parts.clearTrigger.attrs,\n        id: getClearTriggerId(scope),\n        type: \"button\",\n        \"aria-label\": \"Clear value\",\n        \"data-invalid\": dataAttr(invalid),\n        disabled,\n        hidden: !computed(\"hasSelectedItems\"),\n        dir: prop(\"dir\"),\n        onClick(event) {\n          if (event.defaultPrevented) return;\n          send({\n            type: \"CLEAR.CLICK\"\n          });\n        }\n      });\n    },\n    getHiddenSelectProps() {\n      const value = context.get(\"value\");\n      const defaultValue = prop(\"multiple\") ? value : value?.[0];\n      return normalize.select({\n        name: prop(\"name\"),\n        form: prop(\"form\"),\n        disabled,\n        multiple: prop(\"multiple\"),\n        required: prop(\"required\"),\n        \"aria-hidden\": true,\n        id: getHiddenSelectId(scope),\n        defaultValue,\n        style: visuallyHiddenStyle,\n        tabIndex: -1,\n        // Some browser extensions will focus the hidden select.\n        // Let's forward the focus to the trigger.\n        onFocus() {\n          getTriggerEl(scope)?.focus({\n            preventScroll: true\n          });\n        },\n        \"aria-labelledby\": getLabelId(scope)\n      });\n    },\n    getPositionerProps() {\n      return normalize.element({\n        ...parts.positioner.attrs,\n        dir: prop(\"dir\"),\n        id: getPositionerId(scope),\n        style: popperStyles.floating\n      });\n    },\n    getContentProps() {\n      return normalize.element({\n        hidden: !open,\n        dir: prop(\"dir\"),\n        id: getContentId(scope),\n        role: composite ? \"listbox\" : \"dialog\",\n        ...parts.content.attrs,\n        \"data-state\": open ? \"open\" : \"closed\",\n        \"data-placement\": currentPlacement,\n        \"data-activedescendant\": ariaActiveDescendant,\n        \"aria-activedescendant\": composite ? ariaActiveDescendant : void 0,\n        \"aria-multiselectable\": prop(\"multiple\") && composite ? true : void 0,\n        \"aria-labelledby\": getLabelId(scope),\n        tabIndex: 0,\n        onKeyDown(event) {\n          if (!interactive) return;\n          if (!isSelfTarget(event)) return;\n          if (event.key === \"Tab\") {\n            const valid = isValidTabEvent(event);\n            if (!valid) {\n              event.preventDefault();\n              return;\n            }\n          }\n          const keyMap = {\n            ArrowUp() {\n              send({\n                type: \"CONTENT.ARROW_UP\"\n              });\n            },\n            ArrowDown() {\n              send({\n                type: \"CONTENT.ARROW_DOWN\"\n              });\n            },\n            Home() {\n              send({\n                type: \"CONTENT.HOME\"\n              });\n            },\n            End() {\n              send({\n                type: \"CONTENT.END\"\n              });\n            },\n            Enter() {\n              send({\n                type: \"ITEM.CLICK\",\n                src: \"keydown.enter\"\n              });\n            },\n            Space(event2) {\n              if (isTypingAhead) {\n                send({\n                  type: \"CONTENT.TYPEAHEAD\",\n                  key: event2.key\n                });\n              } else {\n                keyMap.Enter?.(event2);\n              }\n            }\n          };\n          const exec = keyMap[getEventKey(event)];\n          if (exec) {\n            exec(event);\n            event.preventDefault();\n            return;\n          }\n          const target = getEventTarget(event);\n          if (isEditableElement(target)) {\n            return;\n          }\n          if (getByTypeahead.isValidEvent(event)) {\n            send({\n              type: \"CONTENT.TYPEAHEAD\",\n              key: event.key\n            });\n            event.preventDefault();\n          }\n        }\n      });\n    },\n    getListProps() {\n      return normalize.element({\n        ...parts.list.attrs,\n        tabIndex: 0,\n        role: !composite ? \"listbox\" : void 0,\n        \"aria-labelledby\": getTriggerId(scope),\n        \"aria-activedescendant\": !composite ? ariaActiveDescendant : void 0,\n        \"aria-multiselectable\": !composite && prop(\"multiple\") ? true : void 0\n      });\n    }\n  };\n}\nvar {\n  and,\n  not,\n  or\n} = createGuards();\nvar machine = createMachine({\n  props({\n    props: props2\n  }) {\n    return {\n      loopFocus: false,\n      closeOnSelect: !props2.multiple,\n      composite: true,\n      defaultValue: [],\n      ...props2,\n      collection: props2.collection ?? collection.empty(),\n      positioning: {\n        placement: \"bottom-start\",\n        gutter: 8,\n        ...props2.positioning\n      }\n    };\n  },\n  context({\n    prop,\n    bindable\n  }) {\n    return {\n      value: bindable(() => ({\n        defaultValue: prop(\"defaultValue\"),\n        value: prop(\"value\"),\n        isEqual,\n        onChange(value) {\n          const items = prop(\"collection\").findMany(value);\n          return prop(\"onValueChange\")?.({\n            value,\n            items\n          });\n        }\n      })),\n      highlightedValue: bindable(() => ({\n        defaultValue: prop(\"defaultHighlightedValue\") || null,\n        value: prop(\"highlightedValue\"),\n        onChange(value) {\n          prop(\"onHighlightChange\")?.({\n            highlightedValue: value,\n            highlightedItem: prop(\"collection\").find(value),\n            highlightedIndex: prop(\"collection\").indexOf(value)\n          });\n        }\n      })),\n      currentPlacement: bindable(() => ({\n        defaultValue: void 0\n      })),\n      fieldsetDisabled: bindable(() => ({\n        defaultValue: false\n      })),\n      highlightedItem: bindable(() => ({\n        defaultValue: null\n      })),\n      selectedItems: bindable(() => {\n        const value = prop(\"value\") ?? prop(\"defaultValue\") ?? [];\n        const items = prop(\"collection\").findMany(value);\n        return {\n          defaultValue: items\n        };\n      }),\n      valueAsString: bindable(() => {\n        const value = prop(\"value\") ?? prop(\"defaultValue\") ?? [];\n        return {\n          defaultValue: prop(\"collection\").stringifyMany(value)\n        };\n      })\n    };\n  },\n  refs() {\n    return {\n      typeahead: {\n        ...getByTypeahead.defaultOptions\n      }\n    };\n  },\n  computed: {\n    hasSelectedItems: ({\n      context\n    }) => context.get(\"value\").length > 0,\n    isTypingAhead: ({\n      refs\n    }) => refs.get(\"typeahead\").keysSoFar !== \"\",\n    isDisabled: ({\n      prop,\n      context\n    }) => !!prop(\"disabled\") || !!context.get(\"fieldsetDisabled\"),\n    isInteractive: ({\n      prop\n    }) => !(prop(\"disabled\") || prop(\"readOnly\"))\n  },\n  initialState({\n    prop\n  }) {\n    const open = prop(\"open\") || prop(\"defaultOpen\");\n    return open ? \"open\" : \"idle\";\n  },\n  entry: [\"syncSelectElement\"],\n  watch({\n    context,\n    prop,\n    track,\n    action\n  }) {\n    track([() => context.get(\"value\").toString()], () => {\n      action([\"syncSelectedItems\", \"syncSelectElement\", \"dispatchChangeEvent\"]);\n    });\n    track([() => prop(\"open\")], () => {\n      action([\"toggleVisibility\"]);\n    });\n    track([() => context.get(\"highlightedValue\")], () => {\n      action([\"syncHighlightedItem\"]);\n    });\n    track([() => prop(\"collection\").toString()], () => {\n      action([\"syncCollection\"]);\n    });\n  },\n  on: {\n    \"HIGHLIGHTED_VALUE.SET\": {\n      actions: [\"setHighlightedItem\"]\n    },\n    \"ITEM.SELECT\": {\n      actions: [\"selectItem\"]\n    },\n    \"ITEM.CLEAR\": {\n      actions: [\"clearItem\"]\n    },\n    \"VALUE.SET\": {\n      actions: [\"setSelectedItems\"]\n    },\n    \"VALUE.CLEAR\": {\n      actions: [\"clearSelectedItems\"]\n    },\n    \"CLEAR.CLICK\": {\n      actions: [\"clearSelectedItems\", \"focusTriggerEl\"]\n    }\n  },\n  effects: [\"trackFormControlState\"],\n  states: {\n    idle: {\n      tags: [\"closed\"],\n      on: {\n        \"CONTROLLED.OPEN\": [{\n          guard: \"isTriggerClickEvent\",\n          target: \"open\",\n          actions: [\"setInitialFocus\", \"highlightFirstSelectedItem\"]\n        }, {\n          target: \"open\",\n          actions: [\"setInitialFocus\"]\n        }],\n        \"TRIGGER.CLICK\": [{\n          guard: \"isOpenControlled\",\n          actions: [\"invokeOnOpen\"]\n        }, {\n          target: \"open\",\n          actions: [\"invokeOnOpen\", \"setInitialFocus\", \"highlightFirstSelectedItem\"]\n        }],\n        \"TRIGGER.FOCUS\": {\n          target: \"focused\"\n        },\n        OPEN: [{\n          guard: \"isOpenControlled\",\n          actions: [\"invokeOnOpen\"]\n        }, {\n          target: \"open\",\n          actions: [\"setInitialFocus\", \"invokeOnOpen\"]\n        }]\n      }\n    },\n    focused: {\n      tags: [\"closed\"],\n      on: {\n        \"CONTROLLED.OPEN\": [{\n          guard: \"isTriggerClickEvent\",\n          target: \"open\",\n          actions: [\"setInitialFocus\", \"highlightFirstSelectedItem\"]\n        }, {\n          guard: \"isTriggerArrowUpEvent\",\n          target: \"open\",\n          actions: [\"setInitialFocus\", \"highlightComputedLastItem\"]\n        }, {\n          guard: or(\"isTriggerArrowDownEvent\", \"isTriggerEnterEvent\"),\n          target: \"open\",\n          actions: [\"setInitialFocus\", \"highlightComputedFirstItem\"]\n        }, {\n          target: \"open\",\n          actions: [\"setInitialFocus\"]\n        }],\n        OPEN: [{\n          guard: \"isOpenControlled\",\n          actions: [\"invokeOnOpen\"]\n        }, {\n          target: \"open\",\n          actions: [\"setInitialFocus\", \"invokeOnOpen\"]\n        }],\n        \"TRIGGER.BLUR\": {\n          target: \"idle\"\n        },\n        \"TRIGGER.CLICK\": [{\n          guard: \"isOpenControlled\",\n          actions: [\"invokeOnOpen\"]\n        }, {\n          target: \"open\",\n          actions: [\"setInitialFocus\", \"invokeOnOpen\", \"highlightFirstSelectedItem\"]\n        }],\n        \"TRIGGER.ENTER\": [{\n          guard: \"isOpenControlled\",\n          actions: [\"invokeOnOpen\"]\n        }, {\n          target: \"open\",\n          actions: [\"setInitialFocus\", \"invokeOnOpen\", \"highlightComputedFirstItem\"]\n        }],\n        \"TRIGGER.ARROW_UP\": [{\n          guard: \"isOpenControlled\",\n          actions: [\"invokeOnOpen\"]\n        }, {\n          target: \"open\",\n          actions: [\"setInitialFocus\", \"invokeOnOpen\", \"highlightComputedLastItem\"]\n        }],\n        \"TRIGGER.ARROW_DOWN\": [{\n          guard: \"isOpenControlled\",\n          actions: [\"invokeOnOpen\"]\n        }, {\n          target: \"open\",\n          actions: [\"setInitialFocus\", \"invokeOnOpen\", \"highlightComputedFirstItem\"]\n        }],\n        \"TRIGGER.ARROW_LEFT\": [{\n          guard: and(not(\"multiple\"), \"hasSelectedItems\"),\n          actions: [\"selectPreviousItem\"]\n        }, {\n          guard: not(\"multiple\"),\n          actions: [\"selectLastItem\"]\n        }],\n        \"TRIGGER.ARROW_RIGHT\": [{\n          guard: and(not(\"multiple\"), \"hasSelectedItems\"),\n          actions: [\"selectNextItem\"]\n        }, {\n          guard: not(\"multiple\"),\n          actions: [\"selectFirstItem\"]\n        }],\n        \"TRIGGER.HOME\": {\n          guard: not(\"multiple\"),\n          actions: [\"selectFirstItem\"]\n        },\n        \"TRIGGER.END\": {\n          guard: not(\"multiple\"),\n          actions: [\"selectLastItem\"]\n        },\n        \"TRIGGER.TYPEAHEAD\": {\n          guard: not(\"multiple\"),\n          actions: [\"selectMatchingItem\"]\n        }\n      }\n    },\n    open: {\n      tags: [\"open\"],\n      exit: [\"scrollContentToTop\"],\n      effects: [\"trackDismissableElement\", \"computePlacement\", \"scrollToHighlightedItem\"],\n      on: {\n        \"CONTROLLED.CLOSE\": {\n          target: \"focused\",\n          actions: [\"focusTriggerEl\", \"clearHighlightedItem\"]\n        },\n        CLOSE: [{\n          guard: \"isOpenControlled\",\n          actions: [\"invokeOnClose\"]\n        }, {\n          target: \"focused\",\n          actions: [\"invokeOnClose\", \"focusTriggerEl\", \"clearHighlightedItem\"]\n        }],\n        \"TRIGGER.CLICK\": [{\n          guard: \"isOpenControlled\",\n          actions: [\"invokeOnClose\"]\n        }, {\n          target: \"focused\",\n          actions: [\"invokeOnClose\", \"clearHighlightedItem\"]\n        }],\n        \"ITEM.CLICK\": [{\n          guard: and(\"closeOnSelect\", \"isOpenControlled\"),\n          actions: [\"selectHighlightedItem\", \"invokeOnClose\"]\n        }, {\n          guard: \"closeOnSelect\",\n          target: \"focused\",\n          actions: [\"selectHighlightedItem\", \"invokeOnClose\", \"focusTriggerEl\", \"clearHighlightedItem\"]\n        }, {\n          actions: [\"selectHighlightedItem\"]\n        }],\n        \"CONTENT.HOME\": {\n          actions: [\"highlightFirstItem\"]\n        },\n        \"CONTENT.END\": {\n          actions: [\"highlightLastItem\"]\n        },\n        \"CONTENT.ARROW_DOWN\": [{\n          guard: and(\"hasHighlightedItem\", \"loop\", \"isLastItemHighlighted\"),\n          actions: [\"highlightFirstItem\"]\n        }, {\n          guard: \"hasHighlightedItem\",\n          actions: [\"highlightNextItem\"]\n        }, {\n          actions: [\"highlightFirstItem\"]\n        }],\n        \"CONTENT.ARROW_UP\": [{\n          guard: and(\"hasHighlightedItem\", \"loop\", \"isFirstItemHighlighted\"),\n          actions: [\"highlightLastItem\"]\n        }, {\n          guard: \"hasHighlightedItem\",\n          actions: [\"highlightPreviousItem\"]\n        }, {\n          actions: [\"highlightLastItem\"]\n        }],\n        \"CONTENT.TYPEAHEAD\": {\n          actions: [\"highlightMatchingItem\"]\n        },\n        \"ITEM.POINTER_MOVE\": {\n          actions: [\"highlightItem\"]\n        },\n        \"ITEM.POINTER_LEAVE\": {\n          actions: [\"clearHighlightedItem\"]\n        },\n        \"POSITIONING.SET\": {\n          actions: [\"reposition\"]\n        }\n      }\n    }\n  },\n  implementations: {\n    guards: {\n      loop: ({\n        prop\n      }) => !!prop(\"loopFocus\"),\n      multiple: ({\n        prop\n      }) => !!prop(\"multiple\"),\n      hasSelectedItems: ({\n        computed\n      }) => !!computed(\"hasSelectedItems\"),\n      hasHighlightedItem: ({\n        context\n      }) => context.get(\"highlightedValue\") != null,\n      isFirstItemHighlighted: ({\n        context,\n        prop\n      }) => context.get(\"highlightedValue\") === prop(\"collection\").firstValue,\n      isLastItemHighlighted: ({\n        context,\n        prop\n      }) => context.get(\"highlightedValue\") === prop(\"collection\").lastValue,\n      closeOnSelect: ({\n        prop,\n        event\n      }) => !!(event.closeOnSelect ?? prop(\"closeOnSelect\")),\n      // guard assertions (for controlled mode)\n      isOpenControlled: ({\n        prop\n      }) => prop(\"open\") !== void 0,\n      isTriggerClickEvent: ({\n        event\n      }) => event.previousEvent?.type === \"TRIGGER.CLICK\",\n      isTriggerEnterEvent: ({\n        event\n      }) => event.previousEvent?.type === \"TRIGGER.ENTER\",\n      isTriggerArrowUpEvent: ({\n        event\n      }) => event.previousEvent?.type === \"TRIGGER.ARROW_UP\",\n      isTriggerArrowDownEvent: ({\n        event\n      }) => event.previousEvent?.type === \"TRIGGER.ARROW_DOWN\"\n    },\n    effects: {\n      trackFormControlState({\n        context,\n        scope\n      }) {\n        return trackFormControl(getHiddenSelectEl(scope), {\n          onFieldsetDisabledChange(disabled) {\n            context.set(\"fieldsetDisabled\", disabled);\n          },\n          onFormReset() {\n            const value = context.initial(\"value\");\n            context.set(\"value\", value);\n          }\n        });\n      },\n      trackDismissableElement({\n        scope,\n        send,\n        prop\n      }) {\n        const contentEl = () => getContentEl(scope);\n        let restoreFocus = true;\n        return trackDismissableElement(contentEl, {\n          defer: true,\n          exclude: [getTriggerEl(scope), getClearTriggerEl(scope)],\n          onFocusOutside: prop(\"onFocusOutside\"),\n          onPointerDownOutside: prop(\"onPointerDownOutside\"),\n          onInteractOutside(event) {\n            prop(\"onInteractOutside\")?.(event);\n            restoreFocus = !(event.detail.focusable || event.detail.contextmenu);\n          },\n          onDismiss() {\n            send({\n              type: \"CLOSE\",\n              src: \"interact-outside\",\n              restoreFocus\n            });\n          }\n        });\n      },\n      computePlacement({\n        context,\n        prop,\n        scope\n      }) {\n        const positioning = prop(\"positioning\");\n        context.set(\"currentPlacement\", positioning.placement);\n        const triggerEl = () => getTriggerEl(scope);\n        const positionerEl = () => getPositionerEl(scope);\n        return getPlacement(triggerEl, positionerEl, {\n          defer: true,\n          ...positioning,\n          onComplete(data) {\n            context.set(\"currentPlacement\", data.placement);\n          }\n        });\n      },\n      scrollToHighlightedItem({\n        context,\n        prop,\n        scope,\n        event\n      }) {\n        const exec = immediate => {\n          const highlightedValue = context.get(\"highlightedValue\");\n          if (highlightedValue == null) return;\n          if (event.current().type.includes(\"POINTER\")) return;\n          const optionEl = getItemEl(scope, highlightedValue);\n          const contentEl2 = getContentEl(scope);\n          const scrollToIndexFn = prop(\"scrollToIndexFn\");\n          if (scrollToIndexFn) {\n            const highlightedIndex = prop(\"collection\").indexOf(highlightedValue);\n            scrollToIndexFn?.({\n              index: highlightedIndex,\n              immediate\n            });\n            return;\n          }\n          scrollIntoView(optionEl, {\n            rootEl: contentEl2,\n            block: \"nearest\"\n          });\n        };\n        raf(() => exec(true));\n        const contentEl = () => getContentEl(scope);\n        return observeAttributes(contentEl, {\n          defer: true,\n          attributes: [\"data-activedescendant\"],\n          callback() {\n            exec(false);\n          }\n        });\n      }\n    },\n    actions: {\n      reposition({\n        context,\n        prop,\n        scope,\n        event\n      }) {\n        const positionerEl = () => getPositionerEl(scope);\n        getPlacement(getTriggerEl(scope), positionerEl, {\n          ...prop(\"positioning\"),\n          ...event.options,\n          defer: true,\n          listeners: false,\n          onComplete(data) {\n            context.set(\"currentPlacement\", data.placement);\n          }\n        });\n      },\n      toggleVisibility({\n        send,\n        prop,\n        event\n      }) {\n        send({\n          type: prop(\"open\") ? \"CONTROLLED.OPEN\" : \"CONTROLLED.CLOSE\",\n          previousEvent: event\n        });\n      },\n      highlightPreviousItem({\n        context,\n        prop\n      }) {\n        const highlightedValue = context.get(\"highlightedValue\");\n        if (highlightedValue == null) return;\n        const value = prop(\"collection\").getPreviousValue(highlightedValue, 1, prop(\"loopFocus\"));\n        context.set(\"highlightedValue\", value);\n      },\n      highlightNextItem({\n        context,\n        prop\n      }) {\n        const highlightedValue = context.get(\"highlightedValue\");\n        if (highlightedValue == null) return;\n        const value = prop(\"collection\").getNextValue(highlightedValue, 1, prop(\"loopFocus\"));\n        context.set(\"highlightedValue\", value);\n      },\n      highlightFirstItem({\n        context,\n        prop\n      }) {\n        const value = prop(\"collection\").firstValue;\n        context.set(\"highlightedValue\", value);\n      },\n      highlightLastItem({\n        context,\n        prop\n      }) {\n        const value = prop(\"collection\").lastValue;\n        context.set(\"highlightedValue\", value);\n      },\n      setInitialFocus({\n        scope\n      }) {\n        raf(() => {\n          const element = getInitialFocus({\n            root: getContentEl(scope)\n          });\n          element?.focus({\n            preventScroll: true\n          });\n        });\n      },\n      focusTriggerEl({\n        event,\n        scope\n      }) {\n        const restoreFocus = event.restoreFocus ?? event.previousEvent?.restoreFocus;\n        if (restoreFocus != null && !restoreFocus) return;\n        raf(() => {\n          const element = getTriggerEl(scope);\n          element?.focus({\n            preventScroll: true\n          });\n        });\n      },\n      selectHighlightedItem({\n        context,\n        prop,\n        event\n      }) {\n        let value = event.value ?? context.get(\"highlightedValue\");\n        if (value == null) return;\n        const nullable = prop(\"deselectable\") && !prop(\"multiple\") && context.get(\"value\").includes(value);\n        value = nullable ? null : value;\n        context.set(\"value\", prev => {\n          if (value == null) return [];\n          if (prop(\"multiple\")) return addOrRemove(prev, value);\n          return [value];\n        });\n      },\n      highlightComputedFirstItem({\n        context,\n        prop,\n        computed\n      }) {\n        const collection2 = prop(\"collection\");\n        const value = computed(\"hasSelectedItems\") ? collection2.sort(context.get(\"value\"))[0] : collection2.firstValue;\n        context.set(\"highlightedValue\", value);\n      },\n      highlightComputedLastItem({\n        context,\n        prop,\n        computed\n      }) {\n        const collection2 = prop(\"collection\");\n        const value = computed(\"hasSelectedItems\") ? collection2.sort(context.get(\"value\"))[0] : collection2.lastValue;\n        context.set(\"highlightedValue\", value);\n      },\n      highlightFirstSelectedItem({\n        context,\n        prop,\n        computed\n      }) {\n        if (!computed(\"hasSelectedItems\")) return;\n        const value = prop(\"collection\").sort(context.get(\"value\"))[0];\n        context.set(\"highlightedValue\", value);\n      },\n      highlightItem({\n        context,\n        event\n      }) {\n        context.set(\"highlightedValue\", event.value);\n      },\n      highlightMatchingItem({\n        context,\n        prop,\n        event,\n        refs\n      }) {\n        const value = prop(\"collection\").search(event.key, {\n          state: refs.get(\"typeahead\"),\n          currentValue: context.get(\"highlightedValue\")\n        });\n        if (value == null) return;\n        context.set(\"highlightedValue\", value);\n      },\n      setHighlightedItem({\n        context,\n        event\n      }) {\n        context.set(\"highlightedValue\", event.value);\n      },\n      clearHighlightedItem({\n        context\n      }) {\n        context.set(\"highlightedValue\", null);\n      },\n      selectItem({\n        context,\n        prop,\n        event\n      }) {\n        const nullable = prop(\"deselectable\") && !prop(\"multiple\") && context.get(\"value\").includes(event.value);\n        const value = nullable ? null : event.value;\n        context.set(\"value\", prev => {\n          if (value == null) return [];\n          if (prop(\"multiple\")) return addOrRemove(prev, value);\n          return [value];\n        });\n      },\n      clearItem({\n        context,\n        event\n      }) {\n        context.set(\"value\", prev => prev.filter(v => v !== event.value));\n      },\n      setSelectedItems({\n        context,\n        event\n      }) {\n        context.set(\"value\", event.value);\n      },\n      clearSelectedItems({\n        context\n      }) {\n        context.set(\"value\", []);\n      },\n      selectPreviousItem({\n        context,\n        prop\n      }) {\n        const [firstItem] = context.get(\"value\");\n        const value = prop(\"collection\").getPreviousValue(firstItem);\n        if (value) context.set(\"value\", [value]);\n      },\n      selectNextItem({\n        context,\n        prop\n      }) {\n        const [firstItem] = context.get(\"value\");\n        const value = prop(\"collection\").getNextValue(firstItem);\n        if (value) context.set(\"value\", [value]);\n      },\n      selectFirstItem({\n        context,\n        prop\n      }) {\n        const value = prop(\"collection\").firstValue;\n        if (value) context.set(\"value\", [value]);\n      },\n      selectLastItem({\n        context,\n        prop\n      }) {\n        const value = prop(\"collection\").lastValue;\n        if (value) context.set(\"value\", [value]);\n      },\n      selectMatchingItem({\n        context,\n        prop,\n        event,\n        refs\n      }) {\n        const value = prop(\"collection\").search(event.key, {\n          state: refs.get(\"typeahead\"),\n          currentValue: context.get(\"value\")[0]\n        });\n        if (value == null) return;\n        context.set(\"value\", [value]);\n      },\n      scrollContentToTop({\n        prop,\n        scope\n      }) {\n        if (prop(\"scrollToIndexFn\")) {\n          prop(\"scrollToIndexFn\")?.({\n            index: 0,\n            immediate: true\n          });\n        } else {\n          getContentEl(scope)?.scrollTo(0, 0);\n        }\n      },\n      invokeOnOpen({\n        prop\n      }) {\n        prop(\"onOpenChange\")?.({\n          open: true\n        });\n      },\n      invokeOnClose({\n        prop\n      }) {\n        prop(\"onOpenChange\")?.({\n          open: false\n        });\n      },\n      syncSelectElement({\n        context,\n        prop,\n        scope\n      }) {\n        const selectEl = getHiddenSelectEl(scope);\n        if (!selectEl) return;\n        if (context.get(\"value\").length === 0 && !prop(\"multiple\")) {\n          selectEl.selectedIndex = -1;\n          return;\n        }\n        for (const option of selectEl.options) {\n          option.selected = context.get(\"value\").includes(option.value);\n        }\n      },\n      syncCollection({\n        context,\n        prop\n      }) {\n        const collection2 = prop(\"collection\");\n        const highlightedItem = collection2.find(context.get(\"highlightedValue\"));\n        if (highlightedItem) context.set(\"highlightedItem\", highlightedItem);\n        const selectedItems = collection2.findMany(context.get(\"value\"));\n        context.set(\"selectedItems\", selectedItems);\n        const valueAsString = collection2.stringifyItems(selectedItems);\n        context.set(\"valueAsString\", valueAsString);\n      },\n      syncSelectedItems({\n        context,\n        prop\n      }) {\n        const collection2 = prop(\"collection\");\n        const prevSelectedItems = context.get(\"selectedItems\");\n        const value = context.get(\"value\");\n        const selectedItems = value.map(value2 => {\n          const item = prevSelectedItems.find(item2 => collection2.getItemValue(item2) === value2);\n          return item || collection2.find(value2);\n        });\n        context.set(\"selectedItems\", selectedItems);\n        context.set(\"valueAsString\", collection2.stringifyItems(selectedItems));\n      },\n      syncHighlightedItem({\n        context,\n        prop\n      }) {\n        const collection2 = prop(\"collection\");\n        const highlightedValue = context.get(\"highlightedValue\");\n        const highlightedItem = highlightedValue ? collection2.find(highlightedValue) : null;\n        context.set(\"highlightedItem\", highlightedItem);\n      },\n      dispatchChangeEvent({\n        scope\n      }) {\n        queueMicrotask(() => {\n          const node = getHiddenSelectEl(scope);\n          if (!node) return;\n          const win = scope.getWin();\n          const changeEvent = new win.Event(\"change\", {\n            bubbles: true,\n            composed: true\n          });\n          node.dispatchEvent(changeEvent);\n        });\n      }\n    }\n  }\n});\nvar props = createProps()([\"closeOnSelect\", \"collection\", \"dir\", \"disabled\", \"deselectable\", \"form\", \"getRootNode\", \"highlightedValue\", \"id\", \"ids\", \"invalid\", \"loopFocus\", \"multiple\", \"name\", \"onFocusOutside\", \"onHighlightChange\", \"onInteractOutside\", \"onOpenChange\", \"onPointerDownOutside\", \"onValueChange\", \"defaultOpen\", \"open\", \"composite\", \"positioning\", \"required\", \"readOnly\", \"scrollToIndexFn\", \"value\", \"defaultValue\", \"defaultHighlightedValue\"]);\nvar splitProps = createSplitProps(props);\nvar itemProps = createProps()([\"item\", \"persistFocus\"]);\nvar splitItemProps = createSplitProps(itemProps);\nvar itemGroupProps = createProps()([\"id\"]);\nvar splitItemGroupProps = createSplitProps(itemGroupProps);\nvar itemGroupLabelProps = createProps()([\"htmlFor\"]);\nvar splitItemGroupLabelProps = createSplitProps(itemGroupLabelProps);\nexport { anatomy, collection, connect, itemGroupLabelProps, itemGroupProps, itemProps, machine, props, splitItemGroupLabelProps, splitItemGroupProps, splitItemProps, splitProps };","map":null,"metadata":{},"sourceType":"module"}