{"ast":null,"code":"import { createAnatomy } from '@zag-js/anatomy';\nimport { createMachine } from '@zag-js/core';\nimport { setRafTimeout, setRafInterval, createSplitProps, isObject } from '@zag-js/utils';\nimport { createProps } from '@zag-js/types';\n\n// src/timer.anatomy.ts\nvar anatomy = createAnatomy(\"timer\").parts(\"root\", \"area\", \"control\", \"item\", \"itemValue\", \"itemLabel\", \"actionTrigger\", \"separator\");\nvar parts = anatomy.build();\n\n// src/timer.dom.ts\nvar getRootId = ctx => ctx.ids?.root ?? `timer:${ctx.id}:root`;\nvar getAreaId = ctx => ctx.ids?.area ?? `timer:${ctx.id}:area`;\n\n// src/timer.connect.ts\nvar validActions = /* @__PURE__ */new Set([\"start\", \"pause\", \"resume\", \"reset\"]);\nfunction connect(service, normalize) {\n  const {\n    state,\n    send,\n    computed,\n    scope\n  } = service;\n  const running = state.matches(\"running\");\n  const paused = state.matches(\"paused\");\n  const time = computed(\"time\");\n  const formattedTime = computed(\"formattedTime\");\n  const progressPercent = computed(\"progressPercent\");\n  return {\n    running,\n    paused,\n    time,\n    formattedTime,\n    progressPercent,\n    start() {\n      send({\n        type: \"START\"\n      });\n    },\n    pause() {\n      send({\n        type: \"PAUSE\"\n      });\n    },\n    resume() {\n      send({\n        type: \"RESUME\"\n      });\n    },\n    reset() {\n      send({\n        type: \"RESET\"\n      });\n    },\n    restart() {\n      send({\n        type: \"RESTART\"\n      });\n    },\n    getRootProps() {\n      return normalize.element({\n        id: getRootId(scope),\n        ...parts.root.attrs\n      });\n    },\n    getAreaProps() {\n      return normalize.element({\n        role: \"timer\",\n        id: getAreaId(scope),\n        \"aria-label\": `${time.days} days ${formattedTime.hours}:${formattedTime.minutes}:${formattedTime.seconds}`,\n        \"aria-atomic\": true,\n        ...parts.area.attrs\n      });\n    },\n    getControlProps() {\n      return normalize.element({\n        ...parts.control.attrs\n      });\n    },\n    getItemProps(props2) {\n      const value = time[props2.type];\n      return normalize.element({\n        ...parts.item.attrs,\n        \"data-type\": props2.type,\n        style: {\n          \"--value\": value\n        }\n      });\n    },\n    getItemLabelProps(props2) {\n      return normalize.element({\n        ...parts.itemLabel.attrs,\n        \"data-type\": props2.type\n      });\n    },\n    getItemValueProps(props2) {\n      return normalize.element({\n        ...parts.itemValue.attrs,\n        \"data-type\": props2.type\n      });\n    },\n    getSeparatorProps() {\n      return normalize.element({\n        \"aria-hidden\": true,\n        ...parts.separator.attrs\n      });\n    },\n    getActionTriggerProps(props2) {\n      if (!validActions.has(props2.action)) {\n        throw new Error(`[zag-js] Invalid action: ${props2.action}. Must be one of: ${Array.from(validActions).join(\", \")}`);\n      }\n      return normalize.button({\n        ...parts.actionTrigger.attrs,\n        hidden: (() => {\n          switch (props2.action) {\n            case \"start\":\n              return running || paused;\n            case \"pause\":\n              return !running;\n            case \"reset\":\n              return !running && !paused;\n            case \"resume\":\n              return !paused;\n            default:\n              return;\n          }\n        })(),\n        type: \"button\",\n        onClick(event) {\n          if (event.defaultPrevented) return;\n          send({\n            type: props2.action.toUpperCase()\n          });\n        }\n      });\n    }\n  };\n}\nvar machine = createMachine({\n  props({\n    props: props2\n  }) {\n    return {\n      interval: 1e3,\n      ...props2\n    };\n  },\n  initialState({\n    prop\n  }) {\n    return prop(\"autoStart\") ? \"running\" : \"idle\";\n  },\n  context({\n    prop,\n    bindable\n  }) {\n    return {\n      currentMs: bindable(() => ({\n        defaultValue: prop(\"startMs\") ?? 0\n      }))\n    };\n  },\n  watch({\n    track,\n    send,\n    prop\n  }) {\n    track([() => prop(\"startMs\")], () => {\n      send({\n        type: \"RESTART\"\n      });\n    });\n  },\n  on: {\n    RESTART: {\n      target: \"running:temp\",\n      actions: [\"resetTime\"]\n    }\n  },\n  computed: {\n    time: ({\n      context\n    }) => msToTime(context.get(\"currentMs\")),\n    formattedTime: ({\n      computed\n    }) => formatTime(computed(\"time\")),\n    progressPercent: ({\n      context,\n      prop\n    }) => {\n      const targetMs = prop(\"targetMs\");\n      if (targetMs == null) return 0;\n      return toPercent(context.get(\"currentMs\"), prop(\"startMs\") ?? 0, targetMs);\n    }\n  },\n  states: {\n    idle: {\n      on: {\n        START: {\n          target: \"running\"\n        },\n        RESET: {\n          actions: [\"resetTime\"]\n        }\n      }\n    },\n    \"running:temp\": {\n      effects: [\"waitForNextTick\"],\n      on: {\n        CONTINUE: {\n          target: \"running\"\n        }\n      }\n    },\n    running: {\n      effects: [\"keepTicking\"],\n      on: {\n        PAUSE: {\n          target: \"paused\"\n        },\n        TICK: [{\n          target: \"idle\",\n          guard: \"hasReachedTarget\",\n          actions: [\"invokeOnComplete\"]\n        }, {\n          actions: [\"updateTime\", \"invokeOnTick\"]\n        }],\n        RESET: {\n          actions: [\"resetTime\"]\n        }\n      }\n    },\n    paused: {\n      on: {\n        RESUME: {\n          target: \"running\"\n        },\n        RESET: {\n          target: \"idle\",\n          actions: [\"resetTime\"]\n        }\n      }\n    }\n  },\n  implementations: {\n    effects: {\n      keepTicking({\n        prop,\n        send\n      }) {\n        return setRafInterval(({\n          deltaMs\n        }) => {\n          send({\n            type: \"TICK\",\n            deltaMs\n          });\n        }, prop(\"interval\"));\n      },\n      waitForNextTick({\n        send\n      }) {\n        return setRafTimeout(() => {\n          send({\n            type: \"CONTINUE\"\n          });\n        }, 0);\n      }\n    },\n    actions: {\n      updateTime({\n        context,\n        prop,\n        event\n      }) {\n        const sign = prop(\"countdown\") ? -1 : 1;\n        const deltaMs = roundToInterval(event.deltaMs, prop(\"interval\"));\n        context.set(\"currentMs\", prev => prev + sign * deltaMs);\n      },\n      resetTime({\n        context,\n        prop\n      }) {\n        let targetMs = prop(\"targetMs\");\n        if (targetMs == null && prop(\"countdown\")) targetMs = 0;\n        context.set(\"currentMs\", prop(\"startMs\") ?? 0);\n      },\n      invokeOnTick({\n        context,\n        prop,\n        computed\n      }) {\n        prop(\"onTick\")?.({\n          value: context.get(\"currentMs\"),\n          time: computed(\"time\"),\n          formattedTime: computed(\"formattedTime\")\n        });\n      },\n      invokeOnComplete({\n        prop\n      }) {\n        prop(\"onComplete\")?.();\n      }\n    },\n    guards: {\n      hasReachedTarget: ({\n        context,\n        prop\n      }) => {\n        let targetMs = prop(\"targetMs\");\n        if (targetMs == null && prop(\"countdown\")) targetMs = 0;\n        if (targetMs == null) return false;\n        return context.get(\"currentMs\") === targetMs;\n      }\n    }\n  }\n});\nfunction msToTime(ms) {\n  const milliseconds = ms % 1e3;\n  const seconds = Math.floor(ms / 1e3) % 60;\n  const minutes = Math.floor(ms / (1e3 * 60)) % 60;\n  const hours = Math.floor(ms / (1e3 * 60 * 60)) % 24;\n  const days = Math.floor(ms / (1e3 * 60 * 60 * 24));\n  return {\n    days,\n    hours,\n    minutes,\n    seconds,\n    milliseconds\n  };\n}\nfunction toPercent(value, minValue, maxValue) {\n  return (value - minValue) / (maxValue - minValue);\n}\nfunction padStart(num, size = 2) {\n  return num.toString().padStart(size, \"0\");\n}\nfunction roundToInterval(value, interval) {\n  return Math.round(value / interval) * interval;\n}\nfunction formatTime(time) {\n  const {\n    days,\n    hours,\n    minutes,\n    seconds\n  } = time;\n  return {\n    days: padStart(days),\n    hours: padStart(hours),\n    minutes: padStart(minutes),\n    seconds: padStart(seconds),\n    milliseconds: time.milliseconds.toString()\n  };\n}\nvar segments = /* @__PURE__ */new Set([\"days\", \"hours\", \"minutes\", \"seconds\"]);\nfunction isTimeSegment(date) {\n  return isObject(date) && Object.keys(date).some(key => segments.has(key));\n}\nfunction parse(date) {\n  if (typeof date === \"string\") {\n    return new Date(date).getTime();\n  }\n  if (isTimeSegment(date)) {\n    const {\n      days = 0,\n      hours = 0,\n      minutes = 0,\n      seconds = 0,\n      milliseconds = 0\n    } = date;\n    const value = (days * 24 * 60 * 60 + hours * 60 * 60 + minutes * 60 + seconds) * 1e3;\n    return value + milliseconds;\n  }\n  throw new Error(\"Invalid date\");\n}\nvar props = createProps()([\"autoStart\", \"countdown\", \"getRootNode\", \"id\", \"ids\", \"interval\", \"onComplete\", \"onTick\", \"startMs\", \"targetMs\"]);\nvar splitProps = createSplitProps(props);\nexport { anatomy, connect, machine, parse, props, splitProps };","map":null,"metadata":{},"sourceType":"module"}