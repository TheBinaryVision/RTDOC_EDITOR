{"ast":null,"code":"import { addDomEvent, raf, contains, dataAttr, MAX_Z_INDEX } from '@zag-js/dom-query';\nimport { createAnatomy } from '@zag-js/anatomy';\nimport { createMachine, createGuards } from '@zag-js/core';\nimport { trackDismissableBranch } from '@zag-js/dismissable';\nimport { uuid, setRafTimeout, ensureProps, runIfFn, compact } from '@zag-js/utils';\n\n// src/toast-group.connect.ts\nvar anatomy = createAnatomy(\"toast\").parts(\"group\", \"root\", \"title\", \"description\", \"actionTrigger\", \"closeTrigger\");\nvar parts = anatomy.build();\n\n// src/toast.dom.ts\nvar getRegionId = placement => `toast-group:${placement}`;\nvar getRegionEl = (ctx, placement) => ctx.getById(`toast-group:${placement}`);\nvar getRootId = ctx => `toast:${ctx.id}`;\nvar getRootEl = ctx => ctx.getById(getRootId(ctx));\nvar getTitleId = ctx => `toast:${ctx.id}:title`;\nvar getDescriptionId = ctx => `toast:${ctx.id}:description`;\nvar getCloseTriggerId = ctx => `toast${ctx.id}:close`;\nvar defaultTimeouts = {\n  info: 5e3,\n  error: 5e3,\n  success: 2e3,\n  loading: Infinity,\n  DEFAULT: 5e3\n};\nfunction getToastDuration(duration, type) {\n  return duration ?? defaultTimeouts[type] ?? defaultTimeouts.DEFAULT;\n}\nvar getOffsets = offsets => typeof offsets === \"string\" ? {\n  left: offsets,\n  right: offsets,\n  bottom: offsets,\n  top: offsets\n} : offsets;\nfunction getGroupPlacementStyle(service, placement) {\n  const {\n    prop,\n    computed,\n    context\n  } = service;\n  const {\n    offsets,\n    gap\n  } = prop(\"store\").attrs;\n  const heights = context.get(\"heights\");\n  const computedOffset = getOffsets(offsets);\n  const rtl = prop(\"dir\") === \"rtl\";\n  const computedPlacement = placement.replace(\"-start\", rtl ? \"-right\" : \"-left\").replace(\"-end\", rtl ? \"-left\" : \"-right\");\n  const isRighty = computedPlacement.includes(\"right\");\n  const isLefty = computedPlacement.includes(\"left\");\n  const styles = {\n    position: \"fixed\",\n    pointerEvents: computed(\"count\") > 0 ? void 0 : \"none\",\n    display: \"flex\",\n    flexDirection: \"column\",\n    \"--gap\": `${gap}px`,\n    \"--first-height\": `${heights[0]?.height || 0}px`,\n    zIndex: MAX_Z_INDEX\n  };\n  let alignItems = \"center\";\n  if (isRighty) alignItems = \"flex-end\";\n  if (isLefty) alignItems = \"flex-start\";\n  styles.alignItems = alignItems;\n  if (computedPlacement.includes(\"top\")) {\n    const offset = computedOffset.top;\n    styles.top = `max(env(safe-area-inset-top, 0px), ${offset})`;\n  }\n  if (computedPlacement.includes(\"bottom\")) {\n    const offset = computedOffset.bottom;\n    styles.bottom = `max(env(safe-area-inset-bottom, 0px), ${offset})`;\n  }\n  if (!computedPlacement.includes(\"left\")) {\n    const offset = computedOffset.right;\n    styles.insetInlineEnd = `calc(env(safe-area-inset-right, 0px) + ${offset})`;\n  }\n  if (!computedPlacement.includes(\"right\")) {\n    const offset = computedOffset.left;\n    styles.insetInlineStart = `calc(env(safe-area-inset-left, 0px) + ${offset})`;\n  }\n  return styles;\n}\nfunction getPlacementStyle(service, visible) {\n  const {\n    prop,\n    context,\n    computed\n  } = service;\n  const parent = prop(\"parent\");\n  const placement = parent.computed(\"placement\");\n  const {\n    gap\n  } = parent.prop(\"store\").attrs;\n  const [side] = placement.split(\"-\");\n  const mounted = context.get(\"mounted\");\n  const remainingTime = context.get(\"remainingTime\");\n  const height = computed(\"height\");\n  const frontmost = computed(\"frontmost\");\n  const sibling = !frontmost;\n  const overlap = !prop(\"stacked\");\n  const stacked = prop(\"stacked\");\n  const type = prop(\"type\");\n  const duration = type === \"loading\" ? Number.MAX_SAFE_INTEGER : remainingTime;\n  const offset = computed(\"heightIndex\") * gap + computed(\"heightBefore\");\n  const styles = {\n    position: \"absolute\",\n    pointerEvents: \"auto\",\n    \"--opacity\": \"0\",\n    \"--remove-delay\": `${prop(\"removeDelay\")}ms`,\n    \"--duration\": `${duration}ms`,\n    \"--initial-height\": `${height}px`,\n    \"--offset\": `${offset}px`,\n    \"--index\": prop(\"index\"),\n    \"--z-index\": computed(\"zIndex\"),\n    \"--lift-amount\": \"calc(var(--lift) * var(--gap))\",\n    \"--y\": \"100%\",\n    \"--x\": \"0\"\n  };\n  const assign = overrides => Object.assign(styles, overrides);\n  if (side === \"top\") {\n    assign({\n      top: \"0\",\n      \"--sign\": \"-1\",\n      \"--y\": \"-100%\",\n      \"--lift\": \"1\"\n    });\n  } else if (side === \"bottom\") {\n    assign({\n      bottom: \"0\",\n      \"--sign\": \"1\",\n      \"--y\": \"100%\",\n      \"--lift\": \"-1\"\n    });\n  }\n  if (mounted) {\n    assign({\n      \"--y\": \"0\",\n      \"--opacity\": \"1\"\n    });\n    if (stacked) {\n      assign({\n        \"--y\": \"calc(var(--lift) * var(--offset))\",\n        \"--height\": \"var(--initial-height)\"\n      });\n    }\n  }\n  if (!visible) {\n    assign({\n      \"--opacity\": \"0\",\n      pointerEvents: \"none\"\n    });\n  }\n  if (sibling && overlap) {\n    assign({\n      \"--base-scale\": \"var(--index) * 0.05 + 1\",\n      \"--y\": \"calc(var(--lift-amount) * var(--index))\",\n      \"--scale\": \"calc(-1 * var(--base-scale))\",\n      \"--height\": \"var(--first-height)\"\n    });\n    if (!visible) {\n      assign({\n        \"--y\": \"calc(var(--sign) * 40%)\"\n      });\n    }\n  }\n  if (sibling && stacked && !visible) {\n    assign({\n      \"--y\": \"calc(var(--lift) * var(--offset) + var(--lift) * -100%)\"\n    });\n  }\n  if (frontmost && !visible) {\n    assign({\n      \"--y\": \"calc(var(--lift) * -100%)\"\n    });\n  }\n  return styles;\n}\nfunction getGhostBeforeStyle(service, visible) {\n  const {\n    computed\n  } = service;\n  const styles = {\n    position: \"absolute\",\n    inset: \"0\",\n    scale: \"1 2\",\n    pointerEvents: visible ? \"none\" : \"auto\"\n  };\n  const assign = overrides => Object.assign(styles, overrides);\n  if (computed(\"frontmost\") && !visible) {\n    assign({\n      height: \"calc(var(--initial-height) + 80%)\"\n    });\n  }\n  return styles;\n}\nfunction getGhostAfterStyle() {\n  return {\n    position: \"absolute\",\n    left: \"0\",\n    height: \"calc(var(--gap) + 2px)\",\n    bottom: \"100%\",\n    width: \"100%\"\n  };\n}\n\n// src/toast-group.connect.ts\nfunction groupConnect(service, normalize) {\n  const {\n    context,\n    prop,\n    send,\n    refs,\n    computed\n  } = service;\n  return {\n    getCount() {\n      return context.get(\"toasts\").length;\n    },\n    getToasts() {\n      return context.get(\"toasts\");\n    },\n    getGroupProps(options = {}) {\n      const {\n        label = \"Notifications\"\n      } = options;\n      const {\n        hotkey\n      } = prop(\"store\").attrs;\n      const hotkeyLabel = hotkey.join(\"+\").replace(/Key/g, \"\").replace(/Digit/g, \"\");\n      const placement = computed(\"placement\");\n      const [side, align = \"center\"] = placement.split(\"-\");\n      return normalize.element({\n        ...parts.group.attrs,\n        dir: prop(\"dir\"),\n        tabIndex: -1,\n        \"aria-label\": `${placement} ${label} ${hotkeyLabel}`,\n        id: getRegionId(placement),\n        \"data-placement\": placement,\n        \"data-side\": side,\n        \"data-align\": align,\n        \"aria-live\": \"polite\",\n        role: \"region\",\n        style: getGroupPlacementStyle(service, placement),\n        onMouseMove() {\n          send({\n            type: \"REGION.POINTER_ENTER\",\n            placement\n          });\n        },\n        onMouseLeave() {\n          send({\n            type: \"REGION.POINTER_LEAVE\",\n            placement\n          });\n        },\n        onFocus(event) {\n          send({\n            type: \"REGION.FOCUS\",\n            target: event.relatedTarget\n          });\n        },\n        onBlur(event) {\n          if (refs.get(\"isFocusWithin\") && !contains(event.currentTarget, event.relatedTarget)) {\n            queueMicrotask(() => send({\n              type: \"REGION.BLUR\"\n            }));\n          }\n        }\n      });\n    },\n    subscribe(fn) {\n      const store = prop(\"store\");\n      return store.subscribe(() => fn(context.get(\"toasts\")));\n    }\n  };\n}\nvar groupMachine = createMachine({\n  props({\n    props\n  }) {\n    return {\n      dir: \"ltr\",\n      id: uuid(),\n      ...props,\n      store: props.store\n    };\n  },\n  initialState({\n    prop\n  }) {\n    return prop(\"store\").attrs.overlap ? \"overlap\" : \"stack\";\n  },\n  refs() {\n    return {\n      lastFocusedEl: null,\n      isFocusWithin: false,\n      dismissableCleanup: void 0\n    };\n  },\n  context({\n    bindable\n  }) {\n    return {\n      toasts: bindable(() => ({\n        defaultValue: [],\n        sync: true,\n        hash: toasts => toasts.map(t => t.id).join(\",\")\n      })),\n      heights: bindable(() => ({\n        defaultValue: [],\n        sync: true\n      }))\n    };\n  },\n  computed: {\n    count: ({\n      context\n    }) => context.get(\"toasts\").length,\n    overlap: ({\n      prop\n    }) => prop(\"store\").attrs.overlap,\n    placement: ({\n      prop\n    }) => prop(\"store\").attrs.placement\n  },\n  effects: [\"subscribeToStore\", \"trackDocumentVisibility\", \"trackHotKeyPress\"],\n  watch({\n    track,\n    context,\n    action\n  }) {\n    track([() => context.hash(\"toasts\")], () => {\n      queueMicrotask(() => {\n        action([\"collapsedIfEmpty\", \"setDismissableBranch\"]);\n      });\n    });\n  },\n  exit: [\"clearDismissableBranch\", \"clearLastFocusedEl\"],\n  on: {\n    \"DOC.HOTKEY\": {\n      actions: [\"focusRegionEl\"]\n    },\n    \"REGION.BLUR\": [{\n      guard: \"isOverlapping\",\n      target: \"overlap\",\n      actions: [\"collapseToasts\", \"resumeToasts\", \"restoreLastFocusedEl\"]\n    }, {\n      target: \"stack\",\n      actions: [\"resumeToasts\", \"restoreLastFocusedEl\"]\n    }],\n    \"TOAST.REMOVE\": {\n      actions: [\"removeToast\", \"removeHeight\"]\n    },\n    \"TOAST.PAUSE\": {\n      actions: [\"pauseToasts\"]\n    }\n  },\n  states: {\n    stack: {\n      on: {\n        \"REGION.POINTER_LEAVE\": [{\n          guard: \"isOverlapping\",\n          target: \"overlap\",\n          actions: [\"resumeToasts\", \"collapseToasts\"]\n        }, {\n          actions: [\"resumeToasts\"]\n        }],\n        \"REGION.OVERLAP\": {\n          target: \"overlap\",\n          actions: [\"collapseToasts\"]\n        },\n        \"REGION.FOCUS\": {\n          actions: [\"setLastFocusedEl\", \"pauseToasts\"]\n        },\n        \"REGION.POINTER_ENTER\": {\n          actions: [\"pauseToasts\"]\n        }\n      }\n    },\n    overlap: {\n      on: {\n        \"REGION.STACK\": {\n          target: \"stack\",\n          actions: [\"expandToasts\"]\n        },\n        \"REGION.POINTER_ENTER\": {\n          target: \"stack\",\n          actions: [\"pauseToasts\", \"expandToasts\"]\n        },\n        \"REGION.FOCUS\": {\n          target: \"stack\",\n          actions: [\"setLastFocusedEl\", \"pauseToasts\", \"expandToasts\"]\n        }\n      }\n    }\n  },\n  implementations: {\n    guards: {\n      isOverlapping: ({\n        computed\n      }) => computed(\"overlap\")\n    },\n    effects: {\n      subscribeToStore({\n        context,\n        prop\n      }) {\n        return prop(\"store\").subscribe(toast => {\n          if (toast.dismiss) {\n            context.set(\"toasts\", prev => prev.filter(t => t.id !== toast.id));\n            return;\n          }\n          context.set(\"toasts\", prev => {\n            const index = prev.findIndex(t => t.id === toast.id);\n            if (index !== -1) {\n              return [...prev.slice(0, index), {\n                ...prev[index],\n                ...toast\n              }, ...prev.slice(index + 1)];\n            }\n            return [toast, ...prev];\n          });\n        });\n      },\n      trackHotKeyPress({\n        prop,\n        send\n      }) {\n        const handleKeyDown = event => {\n          const {\n            hotkey\n          } = prop(\"store\").attrs;\n          const isHotkeyPressed = hotkey.every(key => event[key] || event.code === key);\n          if (!isHotkeyPressed) return;\n          send({\n            type: \"DOC.HOTKEY\"\n          });\n        };\n        return addDomEvent(document, \"keydown\", handleKeyDown, {\n          capture: true\n        });\n      },\n      trackDocumentVisibility({\n        prop,\n        send,\n        scope\n      }) {\n        const {\n          pauseOnPageIdle\n        } = prop(\"store\").attrs;\n        if (!pauseOnPageIdle) return;\n        const doc = scope.getDoc();\n        return addDomEvent(doc, \"visibilitychange\", () => {\n          const isHidden = doc.visibilityState === \"hidden\";\n          send({\n            type: isHidden ? \"PAUSE_ALL\" : \"RESUME_ALL\"\n          });\n        });\n      }\n    },\n    actions: {\n      setDismissableBranch({\n        refs,\n        context,\n        computed,\n        scope\n      }) {\n        const toasts = context.get(\"toasts\");\n        const placement = computed(\"placement\");\n        const hasToasts = toasts.length > 0;\n        if (!hasToasts) {\n          refs.get(\"dismissableCleanup\")?.();\n          return;\n        }\n        if (hasToasts && refs.get(\"dismissableCleanup\")) {\n          return;\n        }\n        const groupEl = () => getRegionEl(scope, placement);\n        const cleanup = trackDismissableBranch(groupEl, {\n          defer: true\n        });\n        refs.set(\"dismissableCleanup\", cleanup);\n      },\n      clearDismissableBranch({\n        refs\n      }) {\n        refs.get(\"dismissableCleanup\")?.();\n      },\n      focusRegionEl({\n        scope,\n        computed\n      }) {\n        queueMicrotask(() => {\n          getRegionEl(scope, computed(\"placement\"))?.focus();\n        });\n      },\n      pauseToasts({\n        prop\n      }) {\n        prop(\"store\").pause();\n      },\n      resumeToasts({\n        prop\n      }) {\n        prop(\"store\").resume();\n      },\n      expandToasts({\n        prop\n      }) {\n        prop(\"store\").expand();\n      },\n      collapseToasts({\n        prop\n      }) {\n        prop(\"store\").collapse();\n      },\n      removeToast({\n        prop,\n        event\n      }) {\n        prop(\"store\").remove(event.id);\n      },\n      removeHeight({\n        event,\n        context\n      }) {\n        if (event?.id == null) return;\n        queueMicrotask(() => {\n          context.set(\"heights\", heights => heights.filter(height => height.id !== event.id));\n        });\n      },\n      collapsedIfEmpty({\n        send,\n        computed\n      }) {\n        if (!computed(\"overlap\") || computed(\"count\") > 1) return;\n        send({\n          type: \"REGION.OVERLAP\"\n        });\n      },\n      setLastFocusedEl({\n        refs,\n        event\n      }) {\n        if (refs.get(\"isFocusWithin\") || !event.target) return;\n        refs.set(\"isFocusWithin\", true);\n        refs.set(\"lastFocusedEl\", event.target);\n      },\n      restoreLastFocusedEl({\n        refs\n      }) {\n        if (!refs.get(\"lastFocusedEl\")) return;\n        refs.get(\"lastFocusedEl\")?.focus({\n          preventScroll: true\n        });\n        refs.set(\"lastFocusedEl\", null);\n        refs.set(\"isFocusWithin\", false);\n      },\n      clearLastFocusedEl({\n        refs\n      }) {\n        if (!refs.get(\"lastFocusedEl\")) return;\n        refs.get(\"lastFocusedEl\")?.focus({\n          preventScroll: true\n        });\n        refs.set(\"lastFocusedEl\", null);\n        refs.set(\"isFocusWithin\", false);\n      }\n    }\n  }\n});\nfunction connect(service, normalize) {\n  const {\n    state,\n    send,\n    prop,\n    scope,\n    context,\n    computed\n  } = service;\n  const visible = state.hasTag(\"visible\");\n  const paused = state.hasTag(\"paused\");\n  const mounted = context.get(\"mounted\");\n  const frontmost = computed(\"frontmost\");\n  const placement = prop(\"parent\").computed(\"placement\");\n  const type = prop(\"type\");\n  const stacked = prop(\"stacked\");\n  const title = prop(\"title\");\n  const description = prop(\"description\");\n  const action = prop(\"action\");\n  const [side, align = \"center\"] = placement.split(\"-\");\n  return {\n    type,\n    title,\n    description,\n    placement,\n    visible,\n    paused,\n    closable: !!prop(\"closable\"),\n    pause() {\n      send({\n        type: \"PAUSE\"\n      });\n    },\n    resume() {\n      send({\n        type: \"RESUME\"\n      });\n    },\n    dismiss() {\n      send({\n        type: \"DISMISS\",\n        src: \"programmatic\"\n      });\n    },\n    getRootProps() {\n      return normalize.element({\n        ...parts.root.attrs,\n        dir: prop(\"dir\"),\n        id: getRootId(scope),\n        \"data-state\": visible ? \"open\" : \"closed\",\n        \"data-type\": type,\n        \"data-placement\": placement,\n        \"data-align\": align,\n        \"data-side\": side,\n        \"data-mounted\": dataAttr(mounted),\n        \"data-paused\": dataAttr(paused),\n        \"data-first\": dataAttr(frontmost),\n        \"data-sibling\": dataAttr(!frontmost),\n        \"data-stack\": dataAttr(stacked),\n        \"data-overlap\": dataAttr(!stacked),\n        role: \"status\",\n        \"aria-atomic\": \"true\",\n        \"aria-describedby\": description ? getDescriptionId(scope) : void 0,\n        \"aria-labelledby\": title ? getTitleId(scope) : void 0,\n        tabIndex: 0,\n        style: getPlacementStyle(service, visible),\n        onKeyDown(event) {\n          if (event.defaultPrevented) return;\n          if (event.key == \"Escape\") {\n            send({\n              type: \"DISMISS\",\n              src: \"keyboard\"\n            });\n            event.preventDefault();\n          }\n        }\n      });\n    },\n    /* Leave a ghost div to avoid setting hover to false when transitioning out */\n    getGhostBeforeProps() {\n      return normalize.element({\n        \"data-ghost\": \"before\",\n        style: getGhostBeforeStyle(service, visible)\n      });\n    },\n    /* Needed to avoid setting hover to false when in between toasts */\n    getGhostAfterProps() {\n      return normalize.element({\n        \"data-ghost\": \"after\",\n        style: getGhostAfterStyle()\n      });\n    },\n    getTitleProps() {\n      return normalize.element({\n        ...parts.title.attrs,\n        id: getTitleId(scope)\n      });\n    },\n    getDescriptionProps() {\n      return normalize.element({\n        ...parts.description.attrs,\n        id: getDescriptionId(scope)\n      });\n    },\n    getActionTriggerProps() {\n      return normalize.button({\n        ...parts.actionTrigger.attrs,\n        type: \"button\",\n        onClick(event) {\n          if (event.defaultPrevented) return;\n          action?.onClick?.();\n          send({\n            type: \"DISMISS\",\n            src: \"user\"\n          });\n        }\n      });\n    },\n    getCloseTriggerProps() {\n      return normalize.button({\n        id: getCloseTriggerId(scope),\n        ...parts.closeTrigger.attrs,\n        type: \"button\",\n        \"aria-label\": \"Dismiss notification\",\n        onClick(event) {\n          if (event.defaultPrevented) return;\n          send({\n            type: \"DISMISS\",\n            src: \"user\"\n          });\n        }\n      });\n    }\n  };\n}\nvar {\n  not\n} = createGuards();\nvar machine = createMachine({\n  props({\n    props\n  }) {\n    ensureProps(props, [\"id\", \"type\", \"parent\", \"removeDelay\"], \"toast\");\n    return {\n      closable: true,\n      ...props,\n      duration: getToastDuration(props.duration, props.type)\n    };\n  },\n  initialState({\n    prop\n  }) {\n    const persist = prop(\"type\") === \"loading\" || prop(\"duration\") === Infinity;\n    return persist ? \"visible:persist\" : \"visible\";\n  },\n  context({\n    prop,\n    bindable\n  }) {\n    return {\n      remainingTime: bindable(() => ({\n        defaultValue: getToastDuration(prop(\"duration\"), prop(\"type\"))\n      })),\n      createdAt: bindable(() => ({\n        defaultValue: Date.now()\n      })),\n      mounted: bindable(() => ({\n        defaultValue: false\n      })),\n      initialHeight: bindable(() => ({\n        defaultValue: 0\n      }))\n    };\n  },\n  refs() {\n    return {\n      closeTimerStartTime: Date.now(),\n      lastCloseStartTimerStartTime: 0\n    };\n  },\n  computed: {\n    zIndex: ({\n      prop\n    }) => {\n      const toasts = prop(\"parent\").context.get(\"toasts\");\n      const index = toasts.findIndex(toast => toast.id === prop(\"id\"));\n      return toasts.length - index;\n    },\n    height: ({\n      prop\n    }) => {\n      const heights = prop(\"parent\").context.get(\"heights\");\n      const height = heights.find(height2 => height2.id === prop(\"id\"));\n      return height?.height ?? 0;\n    },\n    heightIndex: ({\n      prop\n    }) => {\n      const heights = prop(\"parent\").context.get(\"heights\");\n      return heights.findIndex(height => height.id === prop(\"id\"));\n    },\n    frontmost: ({\n      prop\n    }) => prop(\"index\") === 0,\n    heightBefore: ({\n      prop\n    }) => {\n      const heights = prop(\"parent\").context.get(\"heights\");\n      const heightIndex = heights.findIndex(height => height.id === prop(\"id\"));\n      return heights.reduce((prev, curr, reducerIndex) => {\n        if (reducerIndex >= heightIndex) return prev;\n        return prev + curr.height;\n      }, 0);\n    },\n    shouldPersist: ({\n      prop\n    }) => prop(\"type\") === \"loading\" || prop(\"duration\") === Infinity\n  },\n  watch({\n    track,\n    prop,\n    send\n  }) {\n    track([() => prop(\"message\")], () => {\n      const message = prop(\"message\");\n      if (message) send({\n        type: message,\n        src: \"programmatic\"\n      });\n    });\n    track([() => prop(\"type\"), () => prop(\"duration\")], () => {\n      send({\n        type: \"UPDATE\"\n      });\n    });\n  },\n  on: {\n    UPDATE: [{\n      guard: \"shouldPersist\",\n      target: \"visible:persist\",\n      actions: [\"resetCloseTimer\"]\n    }, {\n      target: \"visible:updating\",\n      actions: [\"resetCloseTimer\"]\n    }],\n    MEASURE: {\n      actions: [\"measureHeight\"]\n    }\n  },\n  entry: [\"setMounted\", \"measureHeight\", \"invokeOnVisible\"],\n  effects: [\"trackHeight\"],\n  states: {\n    \"visible:updating\": {\n      tags: [\"visible\", \"updating\"],\n      effects: [\"waitForNextTick\"],\n      on: {\n        SHOW: {\n          target: \"visible\"\n        }\n      }\n    },\n    \"visible:persist\": {\n      tags: [\"visible\", \"paused\"],\n      on: {\n        RESUME: {\n          guard: not(\"isLoadingType\"),\n          target: \"visible\",\n          actions: [\"setCloseTimer\"]\n        },\n        DISMISS: {\n          target: \"dismissing\"\n        }\n      }\n    },\n    visible: {\n      tags: [\"visible\"],\n      effects: [\"waitForDuration\"],\n      on: {\n        DISMISS: {\n          target: \"dismissing\"\n        },\n        PAUSE: {\n          target: \"visible:persist\",\n          actions: [\"syncRemainingTime\"]\n        }\n      }\n    },\n    dismissing: {\n      entry: [\"invokeOnDismiss\"],\n      effects: [\"waitForRemoveDelay\"],\n      on: {\n        REMOVE: {\n          target: \"unmounted\",\n          actions: [\"notifyParentToRemove\"]\n        }\n      }\n    },\n    unmounted: {\n      entry: [\"invokeOnUnmount\"]\n    }\n  },\n  implementations: {\n    effects: {\n      waitForRemoveDelay({\n        prop,\n        send\n      }) {\n        return setRafTimeout(() => {\n          send({\n            type: \"REMOVE\",\n            src: \"timer\"\n          });\n        }, prop(\"removeDelay\"));\n      },\n      waitForDuration({\n        send,\n        context,\n        computed\n      }) {\n        if (computed(\"shouldPersist\")) return;\n        return setRafTimeout(() => {\n          send({\n            type: \"DISMISS\",\n            src: \"timer\"\n          });\n        }, context.get(\"remainingTime\"));\n      },\n      waitForNextTick({\n        send\n      }) {\n        return setRafTimeout(() => {\n          send({\n            type: \"SHOW\",\n            src: \"timer\"\n          });\n        }, 0);\n      },\n      trackHeight({\n        scope,\n        prop\n      }) {\n        let cleanup;\n        raf(() => {\n          const rootEl = getRootEl(scope);\n          if (!rootEl) return;\n          const syncHeight = () => {\n            const originalHeight = rootEl.style.height;\n            rootEl.style.height = \"auto\";\n            const height = rootEl.getBoundingClientRect().height;\n            rootEl.style.height = originalHeight;\n            const item = {\n              id: prop(\"id\"),\n              height\n            };\n            setHeight(prop(\"parent\"), item);\n          };\n          const win = scope.getWin();\n          const observer = new win.MutationObserver(syncHeight);\n          observer.observe(rootEl, {\n            childList: true,\n            subtree: true,\n            characterData: true\n          });\n          cleanup = () => observer.disconnect();\n        });\n        return () => cleanup?.();\n      }\n    },\n    guards: {\n      isLoadingType: ({\n        prop\n      }) => prop(\"type\") === \"loading\",\n      shouldPersist: ({\n        computed\n      }) => computed(\"shouldPersist\")\n    },\n    actions: {\n      setMounted({\n        context\n      }) {\n        raf(() => {\n          context.set(\"mounted\", true);\n        });\n      },\n      measureHeight({\n        scope,\n        prop,\n        context\n      }) {\n        queueMicrotask(() => {\n          const rootEl = getRootEl(scope);\n          if (!rootEl) return;\n          const originalHeight = rootEl.style.height;\n          rootEl.style.height = \"auto\";\n          const height = rootEl.getBoundingClientRect().height;\n          rootEl.style.height = originalHeight;\n          context.set(\"initialHeight\", height);\n          const item = {\n            id: prop(\"id\"),\n            height\n          };\n          setHeight(prop(\"parent\"), item);\n        });\n      },\n      setCloseTimer({\n        refs\n      }) {\n        refs.set(\"closeTimerStartTime\", Date.now());\n      },\n      resetCloseTimer({\n        context,\n        refs,\n        prop\n      }) {\n        refs.set(\"closeTimerStartTime\", Date.now());\n        context.set(\"remainingTime\", getToastDuration(prop(\"duration\"), prop(\"type\")));\n      },\n      syncRemainingTime({\n        context,\n        refs\n      }) {\n        context.set(\"remainingTime\", prev => {\n          const closeTimerStartTime = refs.get(\"closeTimerStartTime\");\n          const elapsedTime = Date.now() - closeTimerStartTime;\n          refs.set(\"lastCloseStartTimerStartTime\", Date.now());\n          return prev - elapsedTime;\n        });\n      },\n      notifyParentToRemove({\n        prop\n      }) {\n        const parent = prop(\"parent\");\n        parent.send({\n          type: \"TOAST.REMOVE\",\n          id: prop(\"id\")\n        });\n      },\n      invokeOnDismiss({\n        prop,\n        event\n      }) {\n        prop(\"onStatusChange\")?.({\n          status: \"dismissing\",\n          src: event.src\n        });\n      },\n      invokeOnUnmount({\n        prop\n      }) {\n        prop(\"onStatusChange\")?.({\n          status: \"unmounted\"\n        });\n      },\n      invokeOnVisible({\n        prop\n      }) {\n        prop(\"onStatusChange\")?.({\n          status: \"visible\"\n        });\n      }\n    }\n  }\n});\nfunction setHeight(parent, item) {\n  const {\n    id,\n    height\n  } = item;\n  parent.context.set(\"heights\", prev => {\n    const alreadyExists = prev.find(i => i.id === id);\n    if (!alreadyExists) {\n      return [{\n        id,\n        height\n      }, ...prev];\n    } else {\n      return prev.map(i => i.id === id ? {\n        ...i,\n        height\n      } : i);\n    }\n  });\n}\nvar withDefaults = (options, defaults) => {\n  return {\n    ...defaults,\n    ...compact(options)\n  };\n};\nfunction createToastStore(props) {\n  const attrs = withDefaults(props, {\n    placement: \"bottom\",\n    overlap: false,\n    max: 24,\n    gap: 16,\n    offsets: \"1rem\",\n    hotkey: [\"altKey\", \"KeyT\"],\n    removeDelay: 200,\n    pauseOnPageIdle: true\n  });\n  let subscribers = [];\n  let toasts = [];\n  let dismissedToasts = /* @__PURE__ */new Set();\n  const subscribe = subscriber => {\n    subscribers.push(subscriber);\n    return () => {\n      const index = subscribers.indexOf(subscriber);\n      subscribers.splice(index, 1);\n    };\n  };\n  const publish = data => {\n    subscribers.forEach(subscriber => subscriber(data));\n    return data;\n  };\n  const addToast = data => {\n    if (toasts.length >= attrs.max) return;\n    publish(data);\n    toasts.unshift(data);\n  };\n  const create = data => {\n    const id = data.id ?? `toast:${uuid()}`;\n    const exists = toasts.find(toast => toast.id === id);\n    if (dismissedToasts.has(id)) dismissedToasts.delete(id);\n    if (exists) {\n      toasts = toasts.map(toast => {\n        if (toast.id === id) {\n          return publish({\n            ...toast,\n            ...data,\n            id\n          });\n        }\n        return toast;\n      });\n    } else {\n      addToast({\n        id,\n        duration: attrs.duration,\n        removeDelay: attrs.removeDelay,\n        type: \"info\",\n        ...data,\n        stacked: !attrs.overlap,\n        gap: attrs.gap\n      });\n    }\n    return id;\n  };\n  const remove = id => {\n    dismissedToasts.add(id);\n    if (!id) {\n      toasts.forEach(toast => {\n        subscribers.forEach(subscriber => subscriber({\n          id: toast.id,\n          dismiss: true\n        }));\n      });\n      toasts = [];\n    } else {\n      subscribers.forEach(subscriber => subscriber({\n        id,\n        dismiss: true\n      }));\n      toasts = toasts.filter(toast => toast.id !== id);\n    }\n    return id;\n  };\n  const error = data => {\n    return create({\n      ...data,\n      type: \"error\"\n    });\n  };\n  const success = data => {\n    return create({\n      ...data,\n      type: \"success\"\n    });\n  };\n  const info = data => {\n    return create({\n      ...data,\n      type: \"info\"\n    });\n  };\n  const warning = data => {\n    return create({\n      ...data,\n      type: \"warning\"\n    });\n  };\n  const loading = data => {\n    return create({\n      ...data,\n      type: \"loading\"\n    });\n  };\n  const getVisibleToasts = () => {\n    return toasts.filter(toast => !dismissedToasts.has(toast.id));\n  };\n  const getCount = () => {\n    return toasts.length;\n  };\n  const promise = (promise2, options, shared = {}) => {\n    if (!options) return;\n    let id = void 0;\n    if (options.loading !== void 0) {\n      id = create({\n        ...shared,\n        ...options.loading,\n        promise: promise2,\n        type: \"loading\"\n      });\n    }\n    let removable = id !== void 0;\n    let result;\n    const prom = runIfFn(promise2).then(async response => {\n      result = [\"resolve\", response];\n      if (isHttpResponse(response) && !response.ok) {\n        removable = false;\n        const errorOptions = runIfFn(options.error, `HTTP Error! status: ${response.status}`);\n        create({\n          ...shared,\n          ...errorOptions,\n          id,\n          type: \"error\"\n        });\n      } else if (options.success !== void 0) {\n        removable = false;\n        const successOptions = runIfFn(options.success, response);\n        create({\n          ...shared,\n          ...successOptions,\n          id,\n          type: \"success\"\n        });\n      }\n    }).catch(async error2 => {\n      result = [\"reject\", error2];\n      if (options.error !== void 0) {\n        removable = false;\n        const errorOptions = runIfFn(options.error, error2);\n        create({\n          ...shared,\n          ...errorOptions,\n          id,\n          type: \"error\"\n        });\n      }\n    }).finally(() => {\n      if (removable) {\n        remove(id);\n        id = void 0;\n      }\n      options.finally?.();\n    });\n    const unwrap = () => new Promise((resolve, reject) => prom.then(() => result[0] === \"reject\" ? reject(result[1]) : resolve(result[1])).catch(reject));\n    return {\n      id,\n      unwrap\n    };\n  };\n  const update = (id, data) => {\n    return create({\n      id,\n      ...data\n    });\n  };\n  const pause = id => {\n    if (id != null) {\n      toasts = toasts.map(toast => {\n        if (toast.id === id) return publish({\n          ...toast,\n          message: \"PAUSE\"\n        });\n        return toast;\n      });\n    } else {\n      toasts = toasts.map(toast => publish({\n        ...toast,\n        message: \"PAUSE\"\n      }));\n    }\n  };\n  const resume = id => {\n    if (id != null) {\n      toasts = toasts.map(toast => {\n        if (toast.id === id) return publish({\n          ...toast,\n          message: \"RESUME\"\n        });\n        return toast;\n      });\n    } else {\n      toasts = toasts.map(toast => publish({\n        ...toast,\n        message: \"RESUME\"\n      }));\n    }\n  };\n  const dismiss = id => {\n    if (id != null) {\n      toasts = toasts.map(toast => {\n        if (toast.id === id) return publish({\n          ...toast,\n          message: \"DISMISS\"\n        });\n        return toast;\n      });\n    } else {\n      toasts = toasts.map(toast => publish({\n        ...toast,\n        message: \"DISMISS\"\n      }));\n    }\n  };\n  const isVisible = id => {\n    return !dismissedToasts.has(id) && !!toasts.find(toast => toast.id === id);\n  };\n  const isDismissed = id => {\n    return dismissedToasts.has(id);\n  };\n  const expand = () => {\n    toasts = toasts.map(toast => publish({\n      ...toast,\n      stacked: true\n    }));\n  };\n  const collapse = () => {\n    toasts = toasts.map(toast => publish({\n      ...toast,\n      stacked: false\n    }));\n  };\n  return {\n    attrs,\n    subscribe,\n    create,\n    update,\n    remove,\n    dismiss,\n    error,\n    success,\n    info,\n    warning,\n    loading,\n    getVisibleToasts,\n    getCount,\n    promise,\n    pause,\n    resume,\n    isVisible,\n    isDismissed,\n    expand,\n    collapse\n  };\n}\nvar isHttpResponse = data => {\n  return data && typeof data === \"object\" && \"ok\" in data && typeof data.ok === \"boolean\" && \"status\" in data && typeof data.status === \"number\";\n};\n\n// src/index.ts\nvar group = {\n  connect: groupConnect,\n  machine: groupMachine\n};\nexport { anatomy, connect, createToastStore as createStore, group, machine };","map":null,"metadata":{},"sourceType":"module"}