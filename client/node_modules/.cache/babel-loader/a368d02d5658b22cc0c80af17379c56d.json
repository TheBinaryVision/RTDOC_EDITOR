{"ast":null,"code":"import { createAnatomy } from '@zag-js/anatomy';\nimport { raf, dispatchInputValueEvent, queryAll, dataAttr, ariaAttr, isHTMLElement, isComposingEvent, isModifierKey, getEventKey, getNativeEvent, getBeforeInputValue, visuallyHiddenStyle } from '@zag-js/dom-query';\nimport { setValueAtIndex, isEqual, createSplitProps, invariant } from '@zag-js/utils';\nimport { setup } from '@zag-js/core';\nimport { createProps } from '@zag-js/types';\n\n// src/pin-input.anatomy.ts\nvar anatomy = createAnatomy(\"pinInput\").parts(\"root\", \"label\", \"input\", \"control\");\nvar parts = anatomy.build();\nvar getRootId = ctx => ctx.ids?.root ?? `pin-input:${ctx.id}`;\nvar getInputId = (ctx, id) => ctx.ids?.input?.(id) ?? `pin-input:${ctx.id}:${id}`;\nvar getHiddenInputId = ctx => ctx.ids?.hiddenInput ?? `pin-input:${ctx.id}:hidden`;\nvar getLabelId = ctx => ctx.ids?.label ?? `pin-input:${ctx.id}:label`;\nvar getControlId = ctx => ctx.ids?.control ?? `pin-input:${ctx.id}:control`;\nvar getRootEl = ctx => ctx.getById(getRootId(ctx));\nvar getInputEls = ctx => {\n  const ownerId = CSS.escape(getRootId(ctx));\n  const selector = `input[data-ownedby=${ownerId}]`;\n  return queryAll(getRootEl(ctx), selector);\n};\nvar getInputElAtIndex = (ctx, index) => getInputEls(ctx)[index];\nvar getFirstInputEl = ctx => getInputEls(ctx)[0];\nvar getHiddenInputEl = ctx => ctx.getById(getHiddenInputId(ctx));\nvar setInputValue = (inputEl, value) => {\n  inputEl.value = value;\n  inputEl.setAttribute(\"value\", value);\n};\n\n// src/pin-input.utils.ts\nvar REGEX = {\n  numeric: /^[0-9]+$/,\n  alphabetic: /^[A-Za-z]+$/,\n  alphanumeric: /^[a-zA-Z0-9]+$/i\n};\nfunction isValidType(type, value) {\n  if (!type) return true;\n  return !!REGEX[type]?.test(value);\n}\nfunction isValidValue(value, type, pattern) {\n  if (!pattern) return isValidType(type, value);\n  const regex = new RegExp(pattern, \"g\");\n  return regex.test(value);\n}\n\n// src/pin-input.connect.ts\nfunction connect(service, normalize) {\n  const {\n    send,\n    context,\n    computed,\n    prop,\n    scope\n  } = service;\n  const complete = computed(\"isValueComplete\");\n  const invalid = prop(\"invalid\");\n  const translations = prop(\"translations\");\n  const focusedIndex = context.get(\"focusedIndex\");\n  function focus() {\n    getFirstInputEl(scope)?.focus();\n  }\n  return {\n    focus,\n    count: context.get(\"count\"),\n    items: Array.from({\n      length: context.get(\"count\")\n    }).map((_, i) => i),\n    value: context.get(\"value\"),\n    valueAsString: computed(\"valueAsString\"),\n    complete,\n    setValue(value) {\n      if (!Array.isArray(value)) {\n        invariant(\"[pin-input/setValue] value must be an array\");\n      }\n      send({\n        type: \"VALUE.SET\",\n        value\n      });\n    },\n    clearValue() {\n      send({\n        type: \"VALUE.CLEAR\"\n      });\n    },\n    setValueAtIndex(index, value) {\n      send({\n        type: \"VALUE.SET\",\n        value,\n        index\n      });\n    },\n    getRootProps() {\n      return normalize.element({\n        dir: prop(\"dir\"),\n        ...parts.root.attrs,\n        id: getRootId(scope),\n        \"data-invalid\": dataAttr(invalid),\n        \"data-disabled\": dataAttr(prop(\"disabled\")),\n        \"data-complete\": dataAttr(complete),\n        \"data-readonly\": dataAttr(prop(\"readOnly\"))\n      });\n    },\n    getLabelProps() {\n      return normalize.label({\n        ...parts.label.attrs,\n        dir: prop(\"dir\"),\n        htmlFor: getHiddenInputId(scope),\n        id: getLabelId(scope),\n        \"data-invalid\": dataAttr(invalid),\n        \"data-disabled\": dataAttr(prop(\"disabled\")),\n        \"data-complete\": dataAttr(complete),\n        \"data-readonly\": dataAttr(prop(\"readOnly\")),\n        onClick(event) {\n          event.preventDefault();\n          focus();\n        }\n      });\n    },\n    getHiddenInputProps() {\n      return normalize.input({\n        \"aria-hidden\": true,\n        type: \"text\",\n        tabIndex: -1,\n        id: getHiddenInputId(scope),\n        readOnly: prop(\"readOnly\"),\n        disabled: prop(\"disabled\"),\n        required: prop(\"required\"),\n        name: prop(\"name\"),\n        form: prop(\"form\"),\n        style: visuallyHiddenStyle,\n        maxLength: computed(\"valueLength\"),\n        defaultValue: computed(\"valueAsString\")\n      });\n    },\n    getControlProps() {\n      return normalize.element({\n        ...parts.control.attrs,\n        dir: prop(\"dir\"),\n        id: getControlId(scope)\n      });\n    },\n    getInputProps(props2) {\n      const {\n        index\n      } = props2;\n      const inputType = prop(\"type\") === \"numeric\" ? \"tel\" : \"text\";\n      return normalize.input({\n        ...parts.input.attrs,\n        dir: prop(\"dir\"),\n        disabled: prop(\"disabled\"),\n        \"data-disabled\": dataAttr(prop(\"disabled\")),\n        \"data-complete\": dataAttr(complete),\n        id: getInputId(scope, index.toString()),\n        \"data-index\": index,\n        \"data-ownedby\": getRootId(scope),\n        \"aria-label\": translations?.inputLabel?.(index, computed(\"valueLength\")),\n        inputMode: prop(\"otp\") || prop(\"type\") === \"numeric\" ? \"numeric\" : \"text\",\n        \"aria-invalid\": ariaAttr(invalid),\n        \"data-invalid\": dataAttr(invalid),\n        type: prop(\"mask\") ? \"password\" : inputType,\n        defaultValue: context.get(\"value\")[index] || \"\",\n        readOnly: prop(\"readOnly\"),\n        autoCapitalize: \"none\",\n        autoComplete: prop(\"otp\") ? \"one-time-code\" : \"off\",\n        placeholder: focusedIndex === index ? \"\" : prop(\"placeholder\"),\n        onBeforeInput(event) {\n          try {\n            const value = getBeforeInputValue(event);\n            const isValid = isValidValue(value, prop(\"type\"), prop(\"pattern\"));\n            if (!isValid) {\n              send({\n                type: \"VALUE.INVALID\",\n                value\n              });\n              event.preventDefault();\n            }\n            if (value.length > 2) {\n              event.currentTarget.setSelectionRange(0, 1, \"forward\");\n            }\n          } catch {}\n        },\n        onChange(event) {\n          const evt = getNativeEvent(event);\n          const {\n            value\n          } = event.currentTarget;\n          if (evt.inputType === \"insertFromPaste\" || value.length > 2) {\n            send({\n              type: \"INPUT.PASTE\",\n              value\n            });\n            event.currentTarget.value = value[0];\n            event.preventDefault();\n            return;\n          }\n          if (evt.inputType === \"deleteContentBackward\") {\n            send({\n              type: \"INPUT.BACKSPACE\"\n            });\n            return;\n          }\n          send({\n            type: \"INPUT.CHANGE\",\n            value,\n            index\n          });\n        },\n        onKeyDown(event) {\n          if (event.defaultPrevented) return;\n          if (isComposingEvent(event)) return;\n          if (isModifierKey(event)) return;\n          const keyMap = {\n            Backspace() {\n              send({\n                type: \"INPUT.BACKSPACE\"\n              });\n            },\n            Delete() {\n              send({\n                type: \"INPUT.DELETE\"\n              });\n            },\n            ArrowLeft() {\n              send({\n                type: \"INPUT.ARROW_LEFT\"\n              });\n            },\n            ArrowRight() {\n              send({\n                type: \"INPUT.ARROW_RIGHT\"\n              });\n            },\n            Enter() {\n              send({\n                type: \"INPUT.ENTER\"\n              });\n            }\n          };\n          const exec = keyMap[getEventKey(event, {\n            dir: prop(\"dir\"),\n            orientation: \"horizontal\"\n          })];\n          if (exec) {\n            exec(event);\n            event.preventDefault();\n          }\n        },\n        onFocus() {\n          send({\n            type: \"INPUT.FOCUS\",\n            index\n          });\n        },\n        onBlur(event) {\n          const target = event.relatedTarget;\n          if (isHTMLElement(target) && target.dataset.ownedby === getRootId(scope)) return;\n          send({\n            type: \"INPUT.BLUR\",\n            index\n          });\n        }\n      });\n    }\n  };\n}\nvar {\n  choose,\n  createMachine\n} = setup();\nvar machine = createMachine({\n  props({\n    props: props2\n  }) {\n    return {\n      placeholder: \"\\u25CB\",\n      otp: false,\n      type: \"numeric\",\n      defaultValue: props2.count ? fill([], props2.count) : [],\n      ...props2,\n      translations: {\n        inputLabel: (index, length) => `pin code ${index + 1} of ${length}`,\n        ...props2.translations\n      }\n    };\n  },\n  initialState() {\n    return \"idle\";\n  },\n  context({\n    prop,\n    bindable\n  }) {\n    return {\n      value: bindable(() => ({\n        value: prop(\"value\"),\n        defaultValue: prop(\"defaultValue\"),\n        isEqual,\n        onChange(value) {\n          prop(\"onValueChange\")?.({\n            value,\n            valueAsString: value.join(\"\")\n          });\n        }\n      })),\n      focusedIndex: bindable(() => ({\n        sync: true,\n        defaultValue: -1\n      })),\n      // TODO: Move this to `props` in next major version\n      count: bindable(() => ({\n        defaultValue: prop(\"count\")\n      }))\n    };\n  },\n  computed: {\n    _value: ({\n      context\n    }) => fill(context.get(\"value\"), context.get(\"count\")),\n    valueLength: ({\n      computed\n    }) => computed(\"_value\").length,\n    filledValueLength: ({\n      computed\n    }) => computed(\"_value\").filter(v => v?.trim() !== \"\").length,\n    isValueComplete: ({\n      computed\n    }) => computed(\"valueLength\") === computed(\"filledValueLength\"),\n    valueAsString: ({\n      computed\n    }) => computed(\"_value\").join(\"\"),\n    focusedValue: ({\n      computed,\n      context\n    }) => computed(\"_value\")[context.get(\"focusedIndex\")] || \"\"\n  },\n  entry: choose([{\n    guard: \"autoFocus\",\n    actions: [\"setInputCount\", \"setFocusIndexToFirst\"]\n  }, {\n    actions: [\"setInputCount\"]\n  }]),\n  watch({\n    action,\n    track,\n    context,\n    computed\n  }) {\n    track([() => context.get(\"focusedIndex\")], () => {\n      action([\"focusInput\", \"selectInputIfNeeded\"]);\n    });\n    track([() => context.get(\"value\").join(\",\")], () => {\n      action([\"syncInputElements\", \"dispatchInputEvent\"]);\n    });\n    track([() => computed(\"isValueComplete\")], () => {\n      action([\"invokeOnComplete\", \"blurFocusedInputIfNeeded\"]);\n    });\n  },\n  on: {\n    \"VALUE.SET\": [{\n      guard: \"hasIndex\",\n      actions: [\"setValueAtIndex\"]\n    }, {\n      actions: [\"setValue\"]\n    }],\n    \"VALUE.CLEAR\": {\n      actions: [\"clearValue\", \"setFocusIndexToFirst\"]\n    }\n  },\n  states: {\n    idle: {\n      on: {\n        \"INPUT.FOCUS\": {\n          target: \"focused\",\n          actions: [\"setFocusedIndex\"]\n        }\n      }\n    },\n    focused: {\n      on: {\n        \"INPUT.CHANGE\": {\n          actions: [\"setFocusedValue\", \"syncInputValue\", \"setNextFocusedIndex\"]\n        },\n        \"INPUT.PASTE\": {\n          actions: [\"setPastedValue\", \"setLastValueFocusIndex\"]\n        },\n        \"INPUT.FOCUS\": {\n          actions: [\"setFocusedIndex\"]\n        },\n        \"INPUT.BLUR\": {\n          target: \"idle\",\n          actions: [\"clearFocusedIndex\"]\n        },\n        \"INPUT.DELETE\": {\n          guard: \"hasValue\",\n          actions: [\"clearFocusedValue\"]\n        },\n        \"INPUT.ARROW_LEFT\": {\n          actions: [\"setPrevFocusedIndex\"]\n        },\n        \"INPUT.ARROW_RIGHT\": {\n          actions: [\"setNextFocusedIndex\"]\n        },\n        \"INPUT.BACKSPACE\": [{\n          guard: \"hasValue\",\n          actions: [\"clearFocusedValue\"]\n        }, {\n          actions: [\"setPrevFocusedIndex\", \"clearFocusedValue\"]\n        }],\n        \"INPUT.ENTER\": {\n          guard: \"isValueComplete\",\n          actions: [\"requestFormSubmit\"]\n        },\n        \"VALUE.INVALID\": {\n          actions: [\"invokeOnInvalid\"]\n        }\n      }\n    }\n  },\n  implementations: {\n    guards: {\n      autoFocus: ({\n        prop\n      }) => !!prop(\"autoFocus\"),\n      hasValue: ({\n        context\n      }) => context.get(\"value\")[context.get(\"focusedIndex\")] !== \"\",\n      isValueComplete: ({\n        computed\n      }) => computed(\"isValueComplete\"),\n      hasIndex: ({\n        event\n      }) => event.index !== void 0\n    },\n    actions: {\n      dispatchInputEvent({\n        computed,\n        scope\n      }) {\n        const inputEl = getHiddenInputEl(scope);\n        dispatchInputValueEvent(inputEl, {\n          value: computed(\"valueAsString\")\n        });\n      },\n      setInputCount({\n        scope,\n        context,\n        prop\n      }) {\n        if (prop(\"count\")) return;\n        const inputEls = getInputEls(scope);\n        context.set(\"count\", inputEls.length);\n      },\n      focusInput({\n        context,\n        scope\n      }) {\n        const focusedIndex = context.get(\"focusedIndex\");\n        if (focusedIndex === -1) return;\n        getInputElAtIndex(scope, focusedIndex)?.focus({\n          preventScroll: true\n        });\n      },\n      selectInputIfNeeded({\n        context,\n        prop,\n        scope\n      }) {\n        const focusedIndex = context.get(\"focusedIndex\");\n        if (!prop(\"selectOnFocus\") || focusedIndex === -1) return;\n        raf(() => {\n          getInputElAtIndex(scope, focusedIndex)?.select();\n        });\n      },\n      invokeOnComplete({\n        computed,\n        prop\n      }) {\n        if (!computed(\"isValueComplete\")) return;\n        prop(\"onValueComplete\")?.({\n          value: computed(\"_value\"),\n          valueAsString: computed(\"valueAsString\")\n        });\n      },\n      invokeOnInvalid({\n        context,\n        event,\n        prop\n      }) {\n        prop(\"onValueInvalid\")?.({\n          value: event.value,\n          index: context.get(\"focusedIndex\")\n        });\n      },\n      clearFocusedIndex({\n        context\n      }) {\n        context.set(\"focusedIndex\", -1);\n      },\n      setFocusedIndex({\n        context,\n        event\n      }) {\n        context.set(\"focusedIndex\", event.index);\n      },\n      setValue({\n        context,\n        event\n      }) {\n        const value = fill(event.value, context.get(\"count\"));\n        context.set(\"value\", value);\n      },\n      setFocusedValue({\n        context,\n        event,\n        computed,\n        flush\n      }) {\n        const focusedValue = computed(\"focusedValue\");\n        const focusedIndex = context.get(\"focusedIndex\");\n        const value = getNextValue(focusedValue, event.value);\n        flush(() => {\n          context.set(\"value\", setValueAtIndex(computed(\"_value\"), focusedIndex, value));\n        });\n      },\n      revertInputValue({\n        context,\n        computed,\n        scope\n      }) {\n        const inputEl = getInputElAtIndex(scope, context.get(\"focusedIndex\"));\n        setInputValue(inputEl, computed(\"focusedValue\"));\n      },\n      syncInputValue({\n        context,\n        event,\n        scope\n      }) {\n        const value = context.get(\"value\");\n        const inputEl = getInputElAtIndex(scope, event.index);\n        setInputValue(inputEl, value[event.index]);\n      },\n      syncInputElements({\n        context,\n        scope\n      }) {\n        const inputEls = getInputEls(scope);\n        const value = context.get(\"value\");\n        inputEls.forEach((inputEl, index) => {\n          setInputValue(inputEl, value[index]);\n        });\n      },\n      setPastedValue({\n        context,\n        event,\n        computed,\n        flush\n      }) {\n        raf(() => {\n          const valueAsString = computed(\"valueAsString\");\n          const focusedIndex = context.get(\"focusedIndex\");\n          const valueLength = computed(\"valueLength\");\n          const filledValueLength = computed(\"filledValueLength\");\n          const startIndex = Math.min(focusedIndex, filledValueLength);\n          const left = startIndex > 0 ? valueAsString.substring(0, focusedIndex) : \"\";\n          const right = event.value.substring(0, valueLength - startIndex);\n          const value = fill(`${left}${right}`.split(\"\"), valueLength);\n          flush(() => {\n            context.set(\"value\", value);\n          });\n        });\n      },\n      setValueAtIndex({\n        context,\n        event,\n        computed\n      }) {\n        const nextValue = getNextValue(computed(\"focusedValue\"), event.value);\n        context.set(\"value\", setValueAtIndex(computed(\"_value\"), event.index, nextValue));\n      },\n      clearValue({\n        context\n      }) {\n        const nextValue = Array.from({\n          length: context.get(\"count\")\n        }).fill(\"\");\n        context.set(\"value\", nextValue);\n      },\n      clearFocusedValue({\n        context,\n        computed\n      }) {\n        const focusedIndex = context.get(\"focusedIndex\");\n        if (focusedIndex === -1) return;\n        context.set(\"value\", setValueAtIndex(computed(\"_value\"), focusedIndex, \"\"));\n      },\n      setFocusIndexToFirst({\n        context\n      }) {\n        context.set(\"focusedIndex\", 0);\n      },\n      setNextFocusedIndex({\n        context,\n        computed\n      }) {\n        context.set(\"focusedIndex\", Math.min(context.get(\"focusedIndex\") + 1, computed(\"valueLength\") - 1));\n      },\n      setPrevFocusedIndex({\n        context\n      }) {\n        context.set(\"focusedIndex\", Math.max(context.get(\"focusedIndex\") - 1, 0));\n      },\n      setLastValueFocusIndex({\n        context,\n        computed\n      }) {\n        raf(() => {\n          context.set(\"focusedIndex\", Math.min(computed(\"filledValueLength\"), computed(\"valueLength\") - 1));\n        });\n      },\n      blurFocusedInputIfNeeded({\n        context,\n        prop,\n        scope\n      }) {\n        if (!prop(\"blurOnComplete\")) return;\n        raf(() => {\n          getInputElAtIndex(scope, context.get(\"focusedIndex\"))?.blur();\n        });\n      },\n      requestFormSubmit({\n        computed,\n        prop,\n        scope\n      }) {\n        if (!prop(\"name\") || !computed(\"isValueComplete\")) return;\n        const inputEl = getHiddenInputEl(scope);\n        inputEl?.form?.requestSubmit();\n      }\n    }\n  }\n});\nfunction getNextValue(current, next) {\n  let nextValue = next;\n  if (current[0] === next[0]) nextValue = next[1];else if (current[0] === next[1]) nextValue = next[0];\n  return nextValue.split(\"\")[nextValue.length - 1];\n}\nfunction fill(value, count) {\n  return Array.from({\n    length: count\n  }).fill(\"\").map((v, i) => value[i] || v);\n}\nvar props = createProps()([\"autoFocus\", \"blurOnComplete\", \"count\", \"defaultValue\", \"dir\", \"disabled\", \"form\", \"getRootNode\", \"id\", \"ids\", \"invalid\", \"mask\", \"name\", \"onValueChange\", \"onValueComplete\", \"onValueInvalid\", \"otp\", \"pattern\", \"placeholder\", \"readOnly\", \"required\", \"selectOnFocus\", \"translations\", \"type\", \"value\"]);\nvar splitProps = createSplitProps(props);\nexport { anatomy, connect, machine, props, splitProps };","map":null,"metadata":{},"sourceType":"module"}