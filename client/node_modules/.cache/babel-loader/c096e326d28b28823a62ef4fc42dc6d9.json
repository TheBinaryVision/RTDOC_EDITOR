{"ast":null,"code":"import { createAnatomy } from '@zag-js/anatomy';\nimport { raf, setElementValue, addDomEvent, isSafari, requestPointerLock, observeAttributes, trackFormControl, MAX_Z_INDEX, dataAttr, getEventPoint, getWindow, isLeftClick, ariaAttr, isComposingEvent, getEventStep, isModifierKey } from '@zag-js/dom-query';\nimport { isValueAtMax, isValueAtMin, clampValue, decrementValue, incrementValue, callAll, isValueWithinRange, createSplitProps, roundToDpr, wrap } from '@zag-js/utils';\nimport { setup, memo } from '@zag-js/core';\nimport { NumberParser } from '@internationalized/number';\nimport { createProps } from '@zag-js/types';\n\n// src/number-input.anatomy.ts\nvar anatomy = createAnatomy(\"numberInput\").parts(\"root\", \"label\", \"input\", \"control\", \"valueText\", \"incrementTrigger\", \"decrementTrigger\", \"scrubber\");\nvar parts = anatomy.build();\nvar getRootId = ctx => ctx.ids?.root ?? `number-input:${ctx.id}`;\nvar getInputId = ctx => ctx.ids?.input ?? `number-input:${ctx.id}:input`;\nvar getIncrementTriggerId = ctx => ctx.ids?.incrementTrigger ?? `number-input:${ctx.id}:inc`;\nvar getDecrementTriggerId = ctx => ctx.ids?.decrementTrigger ?? `number-input:${ctx.id}:dec`;\nvar getScrubberId = ctx => ctx.ids?.scrubber ?? `number-input:${ctx.id}:scrubber`;\nvar getCursorId = ctx => `number-input:${ctx.id}:cursor`;\nvar getLabelId = ctx => ctx.ids?.label ?? `number-input:${ctx.id}:label`;\nvar getInputEl = ctx => ctx.getById(getInputId(ctx));\nvar getIncrementTriggerEl = ctx => ctx.getById(getIncrementTriggerId(ctx));\nvar getDecrementTriggerEl = ctx => ctx.getById(getDecrementTriggerId(ctx));\nvar getCursorEl = ctx => ctx.getDoc().getElementById(getCursorId(ctx));\nvar getPressedTriggerEl = (ctx, hint) => {\n  let btnEl = null;\n  if (hint === \"increment\") {\n    btnEl = getIncrementTriggerEl(ctx);\n  }\n  if (hint === \"decrement\") {\n    btnEl = getDecrementTriggerEl(ctx);\n  }\n  return btnEl;\n};\nvar setupVirtualCursor = (ctx, point) => {\n  if (isSafari()) return;\n  createVirtualCursor(ctx, point);\n  return () => {\n    getCursorEl(ctx)?.remove();\n  };\n};\nvar preventTextSelection = ctx => {\n  const doc = ctx.getDoc();\n  const html = doc.documentElement;\n  const body = doc.body;\n  body.style.pointerEvents = \"none\";\n  html.style.userSelect = \"none\";\n  html.style.cursor = \"ew-resize\";\n  return () => {\n    body.style.pointerEvents = \"\";\n    html.style.userSelect = \"\";\n    html.style.cursor = \"\";\n    if (!html.style.length) {\n      html.removeAttribute(\"style\");\n    }\n    if (!body.style.length) {\n      body.removeAttribute(\"style\");\n    }\n  };\n};\nvar getMousemoveValue = (ctx, opts) => {\n  const {\n    point,\n    isRtl,\n    event\n  } = opts;\n  const win = ctx.getWin();\n  const x = roundToDpr(event.movementX, win.devicePixelRatio);\n  const y = roundToDpr(event.movementY, win.devicePixelRatio);\n  let hint = x > 0 ? \"increment\" : x < 0 ? \"decrement\" : null;\n  if (isRtl && hint === \"increment\") hint = \"decrement\";\n  if (isRtl && hint === \"decrement\") hint = \"increment\";\n  const newPoint = {\n    x: point.x + x,\n    y: point.y + y\n  };\n  const width = win.innerWidth;\n  const half = roundToDpr(7.5, win.devicePixelRatio);\n  newPoint.x = wrap(newPoint.x + half, width) - half;\n  return {\n    hint,\n    point: newPoint\n  };\n};\nvar createVirtualCursor = (ctx, point) => {\n  const doc = ctx.getDoc();\n  const el = doc.createElement(\"div\");\n  el.className = \"scrubber--cursor\";\n  el.id = getCursorId(ctx);\n  Object.assign(el.style, {\n    width: \"15px\",\n    height: \"15px\",\n    position: \"fixed\",\n    pointerEvents: \"none\",\n    left: \"0px\",\n    top: \"0px\",\n    zIndex: MAX_Z_INDEX,\n    transform: point ? `translate3d(${point.x}px, ${point.y}px, 0px)` : void 0,\n    willChange: \"transform\"\n  });\n  el.innerHTML = `\n      <svg width=\"46\" height=\"15\" style=\"left: -15.5px; position: absolute; top: 0; filter: drop-shadow(rgba(0, 0, 0, 0.4) 0px 1px 1.1px);\">\n        <g transform=\"translate(2 3)\">\n          <path fill-rule=\"evenodd\" d=\"M 15 4.5L 15 2L 11.5 5.5L 15 9L 15 6.5L 31 6.5L 31 9L 34.5 5.5L 31 2L 31 4.5Z\" style=\"stroke-width: 2px; stroke: white;\"></path>\n          <path fill-rule=\"evenodd\" d=\"M 15 4.5L 15 2L 11.5 5.5L 15 9L 15 6.5L 31 6.5L 31 9L 34.5 5.5L 31 2L 31 4.5Z\"></path>\n        </g>\n      </svg>`;\n  doc.body.appendChild(el);\n};\n\n// src/number-input.connect.ts\nfunction connect(service, normalize) {\n  const {\n    state,\n    send,\n    prop,\n    scope,\n    computed\n  } = service;\n  const focused = state.hasTag(\"focus\");\n  const disabled = computed(\"isDisabled\");\n  const readOnly = prop(\"readOnly\");\n  const empty = computed(\"isValueEmpty\");\n  const invalid = computed(\"isOutOfRange\") || !!prop(\"invalid\");\n  const isIncrementDisabled = disabled || !computed(\"canIncrement\") || readOnly;\n  const isDecrementDisabled = disabled || !computed(\"canDecrement\") || readOnly;\n  const translations = prop(\"translations\");\n  return {\n    focused,\n    invalid,\n    empty,\n    value: computed(\"formattedValue\"),\n    valueAsNumber: computed(\"valueAsNumber\"),\n    setValue(value) {\n      send({\n        type: \"VALUE.SET\",\n        value\n      });\n    },\n    clearValue() {\n      send({\n        type: \"VALUE.CLEAR\"\n      });\n    },\n    increment() {\n      send({\n        type: \"VALUE.INCREMENT\"\n      });\n    },\n    decrement() {\n      send({\n        type: \"VALUE.DECREMENT\"\n      });\n    },\n    setToMax() {\n      send({\n        type: \"VALUE.SET\",\n        value: prop(\"max\")\n      });\n    },\n    setToMin() {\n      send({\n        type: \"VALUE.SET\",\n        value: prop(\"min\")\n      });\n    },\n    focus() {\n      getInputEl(scope)?.focus();\n    },\n    getRootProps() {\n      return normalize.element({\n        id: getRootId(scope),\n        ...parts.root.attrs,\n        dir: prop(\"dir\"),\n        \"data-disabled\": dataAttr(disabled),\n        \"data-focus\": dataAttr(focused),\n        \"data-invalid\": dataAttr(invalid)\n      });\n    },\n    getLabelProps() {\n      return normalize.label({\n        ...parts.label.attrs,\n        dir: prop(\"dir\"),\n        \"data-disabled\": dataAttr(disabled),\n        \"data-focus\": dataAttr(focused),\n        \"data-invalid\": dataAttr(invalid),\n        id: getLabelId(scope),\n        htmlFor: getInputId(scope)\n      });\n    },\n    getControlProps() {\n      return normalize.element({\n        ...parts.control.attrs,\n        dir: prop(\"dir\"),\n        role: \"group\",\n        \"aria-disabled\": disabled,\n        \"data-focus\": dataAttr(focused),\n        \"data-disabled\": dataAttr(disabled),\n        \"data-invalid\": dataAttr(invalid),\n        \"aria-invalid\": ariaAttr(invalid)\n      });\n    },\n    getValueTextProps() {\n      return normalize.element({\n        ...parts.valueText.attrs,\n        dir: prop(\"dir\"),\n        \"data-disabled\": dataAttr(disabled),\n        \"data-invalid\": dataAttr(invalid),\n        \"data-focus\": dataAttr(focused)\n      });\n    },\n    getInputProps() {\n      return normalize.input({\n        ...parts.input.attrs,\n        dir: prop(\"dir\"),\n        name: prop(\"name\"),\n        form: prop(\"form\"),\n        id: getInputId(scope),\n        role: \"spinbutton\",\n        defaultValue: computed(\"formattedValue\"),\n        pattern: prop(\"pattern\"),\n        inputMode: prop(\"inputMode\"),\n        \"aria-invalid\": ariaAttr(invalid),\n        \"data-invalid\": dataAttr(invalid),\n        disabled,\n        \"data-disabled\": dataAttr(disabled),\n        readOnly,\n        required: prop(\"required\"),\n        autoComplete: \"off\",\n        autoCorrect: \"off\",\n        spellCheck: \"false\",\n        type: \"text\",\n        \"aria-roledescription\": \"numberfield\",\n        \"aria-valuemin\": prop(\"min\"),\n        \"aria-valuemax\": prop(\"max\"),\n        \"aria-valuenow\": Number.isNaN(computed(\"valueAsNumber\")) ? void 0 : computed(\"valueAsNumber\"),\n        \"aria-valuetext\": computed(\"valueText\"),\n        onFocus() {\n          send({\n            type: \"INPUT.FOCUS\"\n          });\n        },\n        onBlur() {\n          send({\n            type: \"INPUT.BLUR\"\n          });\n        },\n        onInput(event) {\n          send({\n            type: \"INPUT.CHANGE\",\n            target: event.currentTarget,\n            hint: \"set\"\n          });\n        },\n        onBeforeInput(event) {\n          try {\n            const {\n              selectionStart,\n              selectionEnd,\n              value\n            } = event.currentTarget;\n            const nextValue = value.slice(0, selectionStart) + (event.data ?? \"\") + value.slice(selectionEnd);\n            const isValid = computed(\"parser\").isValidPartialNumber(nextValue);\n            if (!isValid) {\n              event.preventDefault();\n            }\n          } catch {}\n        },\n        onKeyDown(event) {\n          if (event.defaultPrevented) return;\n          if (readOnly) return;\n          if (isComposingEvent(event)) return;\n          const step = getEventStep(event) * prop(\"step\");\n          const keyMap = {\n            ArrowUp() {\n              send({\n                type: \"INPUT.ARROW_UP\",\n                step\n              });\n              event.preventDefault();\n            },\n            ArrowDown() {\n              send({\n                type: \"INPUT.ARROW_DOWN\",\n                step\n              });\n              event.preventDefault();\n            },\n            Home() {\n              if (isModifierKey(event)) return;\n              send({\n                type: \"INPUT.HOME\"\n              });\n              event.preventDefault();\n            },\n            End() {\n              if (isModifierKey(event)) return;\n              send({\n                type: \"INPUT.END\"\n              });\n              event.preventDefault();\n            },\n            Enter() {\n              send({\n                type: \"INPUT.ENTER\"\n              });\n            }\n          };\n          const exec = keyMap[event.key];\n          exec?.(event);\n        }\n      });\n    },\n    getDecrementTriggerProps() {\n      return normalize.button({\n        ...parts.decrementTrigger.attrs,\n        dir: prop(\"dir\"),\n        id: getDecrementTriggerId(scope),\n        disabled: isDecrementDisabled,\n        \"data-disabled\": dataAttr(isDecrementDisabled),\n        \"aria-label\": translations.decrementLabel,\n        type: \"button\",\n        tabIndex: -1,\n        \"aria-controls\": getInputId(scope),\n        onPointerDown(event) {\n          if (isDecrementDisabled || !isLeftClick(event)) return;\n          send({\n            type: \"TRIGGER.PRESS_DOWN\",\n            hint: \"decrement\",\n            pointerType: event.pointerType\n          });\n          if (event.pointerType === \"mouse\") {\n            event.preventDefault();\n          }\n          if (event.pointerType === \"touch\") {\n            event.currentTarget?.focus({\n              preventScroll: true\n            });\n          }\n        },\n        onPointerUp(event) {\n          send({\n            type: \"TRIGGER.PRESS_UP\",\n            hint: \"decrement\",\n            pointerType: event.pointerType\n          });\n        },\n        onPointerLeave() {\n          if (isDecrementDisabled) return;\n          send({\n            type: \"TRIGGER.PRESS_UP\",\n            hint: \"decrement\"\n          });\n        }\n      });\n    },\n    getIncrementTriggerProps() {\n      return normalize.button({\n        ...parts.incrementTrigger.attrs,\n        dir: prop(\"dir\"),\n        id: getIncrementTriggerId(scope),\n        disabled: isIncrementDisabled,\n        \"data-disabled\": dataAttr(isIncrementDisabled),\n        \"aria-label\": translations.incrementLabel,\n        type: \"button\",\n        tabIndex: -1,\n        \"aria-controls\": getInputId(scope),\n        onPointerDown(event) {\n          if (isIncrementDisabled || !isLeftClick(event)) return;\n          send({\n            type: \"TRIGGER.PRESS_DOWN\",\n            hint: \"increment\",\n            pointerType: event.pointerType\n          });\n          if (event.pointerType === \"mouse\") {\n            event.preventDefault();\n          }\n          if (event.pointerType === \"touch\") {\n            event.currentTarget?.focus({\n              preventScroll: true\n            });\n          }\n        },\n        onPointerUp(event) {\n          send({\n            type: \"TRIGGER.PRESS_UP\",\n            hint: \"increment\",\n            pointerType: event.pointerType\n          });\n        },\n        onPointerLeave(event) {\n          send({\n            type: \"TRIGGER.PRESS_UP\",\n            hint: \"increment\",\n            pointerType: event.pointerType\n          });\n        }\n      });\n    },\n    getScrubberProps() {\n      return normalize.element({\n        ...parts.scrubber.attrs,\n        dir: prop(\"dir\"),\n        \"data-disabled\": dataAttr(disabled),\n        id: getScrubberId(scope),\n        role: \"presentation\",\n        onMouseDown(event) {\n          if (disabled) return;\n          const point = getEventPoint(event);\n          const win = getWindow(event.currentTarget);\n          const dpr = win.devicePixelRatio;\n          point.x = point.x - roundToDpr(7.5, dpr);\n          point.y = point.y - roundToDpr(7.5, dpr);\n          send({\n            type: \"SCRUBBER.PRESS_DOWN\",\n            point\n          });\n          event.preventDefault();\n        },\n        style: {\n          cursor: disabled ? void 0 : \"ew-resize\"\n        }\n      });\n    }\n  };\n}\n\n// src/cursor.ts\nfunction recordCursor(inputEl) {\n  if (!inputEl || inputEl.ownerDocument.activeElement !== inputEl) return;\n  try {\n    const {\n      selectionStart: start,\n      selectionEnd: end,\n      value\n    } = inputEl;\n    const beforeTxt = value.substring(0, start);\n    const afterTxt = value.substring(end);\n    return {\n      start,\n      end,\n      value,\n      beforeTxt,\n      afterTxt\n    };\n  } catch {}\n}\nfunction restoreCursor(inputEl, selection) {\n  if (!inputEl || inputEl.ownerDocument.activeElement !== inputEl) return;\n  if (!selection) {\n    inputEl.setSelectionRange(inputEl.value.length, inputEl.value.length);\n    return;\n  }\n  try {\n    const {\n      value\n    } = inputEl;\n    const {\n      beforeTxt = \"\",\n      afterTxt = \"\",\n      start\n    } = selection;\n    let startPos = value.length;\n    if (value.endsWith(afterTxt)) {\n      startPos = value.length - afterTxt.length;\n    } else if (value.startsWith(beforeTxt)) {\n      startPos = beforeTxt.length;\n    } else if (start != null) {\n      const beforeLastChar = beforeTxt[start - 1];\n      const newIndex = value.indexOf(beforeLastChar, start - 1);\n      if (newIndex !== -1) {\n        startPos = newIndex + 1;\n      }\n    }\n    inputEl.setSelectionRange(startPos, startPos);\n  } catch {}\n}\nvar createFormatter = (locale, options = {}) => {\n  return new Intl.NumberFormat(locale, options);\n};\nvar createParser = (locale, options = {}) => {\n  return new NumberParser(locale, options);\n};\nvar parseValue = (value, params) => {\n  const {\n    prop,\n    computed\n  } = params;\n  if (!prop(\"formatOptions\")) return parseFloat(value);\n  return computed(\"parser\").parse(String(value));\n};\nvar formatValue = (value, params) => {\n  const {\n    prop,\n    computed\n  } = params;\n  if (Number.isNaN(value)) return \"\";\n  if (!prop(\"formatOptions\")) return value.toString();\n  return computed(\"formatter\").format(value);\n};\nvar getDefaultStep = (step, formatOptions) => {\n  let defaultStep = step !== void 0 && !Number.isNaN(step) ? step : 1;\n  if (formatOptions?.style === \"percent\" && (step === void 0 || Number.isNaN(step))) {\n    defaultStep = 0.01;\n  }\n  return defaultStep;\n};\n\n// src/number-input.machine.ts\nvar {\n  choose,\n  guards,\n  createMachine\n} = setup();\nvar {\n  not,\n  and\n} = guards;\nvar machine = createMachine({\n  props({\n    props: props2\n  }) {\n    const step = getDefaultStep(props2.step, props2.formatOptions);\n    return {\n      dir: \"ltr\",\n      locale: \"en-US\",\n      focusInputOnChange: true,\n      clampValueOnBlur: !props2.allowOverflow,\n      allowOverflow: false,\n      inputMode: \"decimal\",\n      pattern: \"[0-9]*(.[0-9]+)?\",\n      defaultValue: \"\",\n      step,\n      min: Number.MIN_SAFE_INTEGER,\n      max: Number.MAX_SAFE_INTEGER,\n      spinOnPress: true,\n      ...props2,\n      translations: {\n        incrementLabel: \"increment value\",\n        decrementLabel: \"decrease value\",\n        ...props2.translations\n      }\n    };\n  },\n  initialState() {\n    return \"idle\";\n  },\n  context({\n    prop,\n    bindable,\n    getComputed\n  }) {\n    return {\n      value: bindable(() => ({\n        defaultValue: prop(\"defaultValue\"),\n        value: prop(\"value\"),\n        onChange(value) {\n          const computed = getComputed();\n          const valueAsNumber = parseValue(value, {\n            computed,\n            prop\n          });\n          prop(\"onValueChange\")?.({\n            value,\n            valueAsNumber\n          });\n        }\n      })),\n      hint: bindable(() => ({\n        defaultValue: null\n      })),\n      scrubberCursorPoint: bindable(() => ({\n        defaultValue: null,\n        hash(value) {\n          return value ? `x:${value.x}, y:${value.y}` : \"\";\n        }\n      })),\n      fieldsetDisabled: bindable(() => ({\n        defaultValue: false\n      }))\n    };\n  },\n  computed: {\n    isRtl: ({\n      prop\n    }) => prop(\"dir\") === \"rtl\",\n    valueAsNumber: ({\n      context,\n      computed,\n      prop\n    }) => parseValue(context.get(\"value\"), {\n      computed,\n      prop\n    }),\n    formattedValue: ({\n      computed,\n      prop\n    }) => formatValue(computed(\"valueAsNumber\"), {\n      computed,\n      prop\n    }),\n    isAtMin: ({\n      computed,\n      prop\n    }) => isValueAtMin(computed(\"valueAsNumber\"), prop(\"min\")),\n    isAtMax: ({\n      computed,\n      prop\n    }) => isValueAtMax(computed(\"valueAsNumber\"), prop(\"max\")),\n    isOutOfRange: ({\n      computed,\n      prop\n    }) => !isValueWithinRange(computed(\"valueAsNumber\"), prop(\"min\"), prop(\"max\")),\n    isValueEmpty: ({\n      context\n    }) => context.get(\"value\") === \"\",\n    isDisabled: ({\n      prop,\n      context\n    }) => !!prop(\"disabled\") || context.get(\"fieldsetDisabled\"),\n    canIncrement: ({\n      prop,\n      computed\n    }) => prop(\"allowOverflow\") || !computed(\"isAtMax\"),\n    canDecrement: ({\n      prop,\n      computed\n    }) => prop(\"allowOverflow\") || !computed(\"isAtMin\"),\n    valueText: ({\n      prop,\n      context\n    }) => prop(\"translations\").valueText?.(context.get(\"value\")),\n    formatter: memo(({\n      prop\n    }) => [prop(\"locale\"), prop(\"formatOptions\")], (locale, formatOptions) => createFormatter(locale, formatOptions)),\n    parser: memo(({\n      prop\n    }) => [prop(\"locale\"), prop(\"formatOptions\")], (locale, formatOptions) => createParser(locale, formatOptions))\n  },\n  watch({\n    track,\n    action,\n    context,\n    computed,\n    prop\n  }) {\n    track([() => context.get(\"value\"), () => prop(\"locale\")], () => {\n      action([\"syncInputElement\"]);\n    });\n    track([() => computed(\"isOutOfRange\")], () => {\n      action([\"invokeOnInvalid\"]);\n    });\n    track([() => context.hash(\"scrubberCursorPoint\")], () => {\n      action([\"setVirtualCursorPosition\"]);\n    });\n  },\n  effects: [\"trackFormControl\"],\n  on: {\n    \"VALUE.SET\": {\n      actions: [\"setRawValue\"]\n    },\n    \"VALUE.CLEAR\": {\n      actions: [\"clearValue\"]\n    },\n    \"VALUE.INCREMENT\": {\n      actions: [\"increment\"]\n    },\n    \"VALUE.DECREMENT\": {\n      actions: [\"decrement\"]\n    }\n  },\n  states: {\n    idle: {\n      on: {\n        \"TRIGGER.PRESS_DOWN\": [{\n          guard: \"isTouchPointer\",\n          target: \"before:spin\",\n          actions: [\"setHint\"]\n        }, {\n          target: \"before:spin\",\n          actions: [\"focusInput\", \"invokeOnFocus\", \"setHint\"]\n        }],\n        \"SCRUBBER.PRESS_DOWN\": {\n          target: \"scrubbing\",\n          actions: [\"focusInput\", \"invokeOnFocus\", \"setHint\", \"setCursorPoint\"]\n        },\n        \"INPUT.FOCUS\": {\n          target: \"focused\",\n          actions: [\"focusInput\", \"invokeOnFocus\"]\n        }\n      }\n    },\n    focused: {\n      tags: [\"focus\"],\n      effects: [\"attachWheelListener\"],\n      on: {\n        \"TRIGGER.PRESS_DOWN\": [{\n          guard: \"isTouchPointer\",\n          target: \"before:spin\",\n          actions: [\"setHint\"]\n        }, {\n          target: \"before:spin\",\n          actions: [\"focusInput\", \"setHint\"]\n        }],\n        \"SCRUBBER.PRESS_DOWN\": {\n          target: \"scrubbing\",\n          actions: [\"focusInput\", \"setHint\", \"setCursorPoint\"]\n        },\n        \"INPUT.ARROW_UP\": {\n          actions: [\"increment\"]\n        },\n        \"INPUT.ARROW_DOWN\": {\n          actions: [\"decrement\"]\n        },\n        \"INPUT.HOME\": {\n          actions: [\"decrementToMin\"]\n        },\n        \"INPUT.END\": {\n          actions: [\"incrementToMax\"]\n        },\n        \"INPUT.CHANGE\": {\n          actions: [\"setValue\", \"setHint\"]\n        },\n        \"INPUT.BLUR\": [{\n          guard: and(\"clampValueOnBlur\", not(\"isInRange\")),\n          target: \"idle\",\n          actions: [\"setClampedValue\", \"clearHint\", \"invokeOnBlur\"]\n        }, {\n          guard: not(\"isInRange\"),\n          target: \"idle\",\n          actions: [\"setFormattedValue\", \"clearHint\", \"invokeOnBlur\", \"invokeOnInvalid\"]\n        }, {\n          target: \"idle\",\n          actions: [\"setFormattedValue\", \"clearHint\", \"invokeOnBlur\"]\n        }],\n        \"INPUT.ENTER\": {\n          actions: [\"setFormattedValue\", \"clearHint\", \"invokeOnBlur\"]\n        }\n      }\n    },\n    \"before:spin\": {\n      tags: [\"focus\"],\n      effects: [\"trackButtonDisabled\", \"waitForChangeDelay\"],\n      entry: choose([{\n        guard: \"isIncrementHint\",\n        actions: [\"increment\"]\n      }, {\n        guard: \"isDecrementHint\",\n        actions: [\"decrement\"]\n      }]),\n      on: {\n        CHANGE_DELAY: {\n          target: \"spinning\",\n          guard: and(\"isInRange\", \"spinOnPress\")\n        },\n        \"TRIGGER.PRESS_UP\": [{\n          guard: \"isTouchPointer\",\n          target: \"focused\",\n          actions: [\"clearHint\"]\n        }, {\n          target: \"focused\",\n          actions: [\"focusInput\", \"clearHint\"]\n        }]\n      }\n    },\n    spinning: {\n      tags: [\"focus\"],\n      effects: [\"trackButtonDisabled\", \"spinValue\"],\n      on: {\n        SPIN: [{\n          guard: \"isIncrementHint\",\n          actions: [\"increment\"]\n        }, {\n          guard: \"isDecrementHint\",\n          actions: [\"decrement\"]\n        }],\n        \"TRIGGER.PRESS_UP\": {\n          target: \"focused\",\n          actions: [\"focusInput\", \"clearHint\"]\n        }\n      }\n    },\n    scrubbing: {\n      tags: [\"focus\"],\n      effects: [\"activatePointerLock\", \"trackMousemove\", \"setupVirtualCursor\", \"preventTextSelection\"],\n      on: {\n        \"SCRUBBER.POINTER_UP\": {\n          target: \"focused\",\n          actions: [\"focusInput\", \"clearCursorPoint\"]\n        },\n        \"SCRUBBER.POINTER_MOVE\": [{\n          guard: \"isIncrementHint\",\n          actions: [\"increment\", \"setCursorPoint\"]\n        }, {\n          guard: \"isDecrementHint\",\n          actions: [\"decrement\", \"setCursorPoint\"]\n        }]\n      }\n    }\n  },\n  implementations: {\n    guards: {\n      clampValueOnBlur: ({\n        prop\n      }) => prop(\"clampValueOnBlur\"),\n      spinOnPress: ({\n        prop\n      }) => !!prop(\"spinOnPress\"),\n      isInRange: ({\n        computed\n      }) => !computed(\"isOutOfRange\"),\n      isDecrementHint: ({\n        context,\n        event\n      }) => (event.hint ?? context.get(\"hint\")) === \"decrement\",\n      isIncrementHint: ({\n        context,\n        event\n      }) => (event.hint ?? context.get(\"hint\")) === \"increment\",\n      isTouchPointer: ({\n        event\n      }) => event.pointerType === \"touch\"\n    },\n    effects: {\n      waitForChangeDelay({\n        send\n      }) {\n        const id = setTimeout(() => {\n          send({\n            type: \"CHANGE_DELAY\"\n          });\n        }, 300);\n        return () => clearTimeout(id);\n      },\n      spinValue({\n        send\n      }) {\n        const id = setInterval(() => {\n          send({\n            type: \"SPIN\"\n          });\n        }, 50);\n        return () => clearInterval(id);\n      },\n      trackFormControl({\n        context,\n        scope\n      }) {\n        const inputEl = getInputEl(scope);\n        return trackFormControl(inputEl, {\n          onFieldsetDisabledChange(disabled) {\n            context.set(\"fieldsetDisabled\", disabled);\n          },\n          onFormReset() {\n            context.set(\"value\", context.initial(\"value\"));\n          }\n        });\n      },\n      setupVirtualCursor({\n        context,\n        scope\n      }) {\n        const point = context.get(\"scrubberCursorPoint\");\n        return setupVirtualCursor(scope, point);\n      },\n      preventTextSelection({\n        scope\n      }) {\n        return preventTextSelection(scope);\n      },\n      trackButtonDisabled({\n        context,\n        scope,\n        send\n      }) {\n        const hint = context.get(\"hint\");\n        const btn = getPressedTriggerEl(scope, hint);\n        return observeAttributes(btn, {\n          attributes: [\"disabled\"],\n          callback() {\n            send({\n              type: \"TRIGGER.PRESS_UP\",\n              src: \"attr\"\n            });\n          }\n        });\n      },\n      attachWheelListener({\n        scope,\n        send,\n        prop\n      }) {\n        const inputEl = getInputEl(scope);\n        if (!inputEl || !scope.isActiveElement(inputEl) || !prop(\"allowMouseWheel\")) return;\n        function onWheel(event) {\n          event.preventDefault();\n          const dir = Math.sign(event.deltaY) * -1;\n          if (dir === 1) {\n            send({\n              type: \"VALUE.INCREMENT\"\n            });\n          } else if (dir === -1) {\n            send({\n              type: \"VALUE.DECREMENT\"\n            });\n          }\n        }\n        return addDomEvent(inputEl, \"wheel\", onWheel, {\n          passive: false\n        });\n      },\n      activatePointerLock({\n        scope\n      }) {\n        if (isSafari()) return;\n        return requestPointerLock(scope.getDoc());\n      },\n      trackMousemove({\n        scope,\n        send,\n        context,\n        computed\n      }) {\n        const doc = scope.getDoc();\n        function onMousemove(event) {\n          const point = context.get(\"scrubberCursorPoint\");\n          const isRtl = computed(\"isRtl\");\n          const value = getMousemoveValue(scope, {\n            point,\n            isRtl,\n            event\n          });\n          if (!value.hint) return;\n          send({\n            type: \"SCRUBBER.POINTER_MOVE\",\n            hint: value.hint,\n            point: value.point\n          });\n        }\n        function onMouseup() {\n          send({\n            type: \"SCRUBBER.POINTER_UP\"\n          });\n        }\n        return callAll(addDomEvent(doc, \"mousemove\", onMousemove, false), addDomEvent(doc, \"mouseup\", onMouseup, false));\n      }\n    },\n    actions: {\n      focusInput({\n        scope,\n        prop\n      }) {\n        if (!prop(\"focusInputOnChange\")) return;\n        const inputEl = getInputEl(scope);\n        if (scope.isActiveElement(inputEl)) return;\n        raf(() => inputEl?.focus({\n          preventScroll: true\n        }));\n      },\n      increment({\n        context,\n        event,\n        prop,\n        computed\n      }) {\n        let nextValue = incrementValue(computed(\"valueAsNumber\"), event.step ?? prop(\"step\"));\n        if (!prop(\"allowOverflow\")) nextValue = clampValue(nextValue, prop(\"min\"), prop(\"max\"));\n        context.set(\"value\", formatValue(nextValue, {\n          computed,\n          prop\n        }));\n      },\n      decrement({\n        context,\n        event,\n        prop,\n        computed\n      }) {\n        let nextValue = decrementValue(computed(\"valueAsNumber\"), event.step ?? prop(\"step\"));\n        if (!prop(\"allowOverflow\")) nextValue = clampValue(nextValue, prop(\"min\"), prop(\"max\"));\n        context.set(\"value\", formatValue(nextValue, {\n          computed,\n          prop\n        }));\n      },\n      setClampedValue({\n        context,\n        prop,\n        computed\n      }) {\n        const nextValue = clampValue(computed(\"valueAsNumber\"), prop(\"min\"), prop(\"max\"));\n        context.set(\"value\", formatValue(nextValue, {\n          computed,\n          prop\n        }));\n      },\n      setRawValue({\n        context,\n        event,\n        prop,\n        computed\n      }) {\n        let nextValue = parseValue(event.value, {\n          computed,\n          prop\n        });\n        if (!prop(\"allowOverflow\")) nextValue = clampValue(nextValue, prop(\"min\"), prop(\"max\"));\n        context.set(\"value\", formatValue(nextValue, {\n          computed,\n          prop\n        }));\n      },\n      setValue({\n        context,\n        event\n      }) {\n        const value = event.target?.value ?? event.value;\n        context.set(\"value\", value);\n      },\n      clearValue({\n        context\n      }) {\n        context.set(\"value\", \"\");\n      },\n      incrementToMax({\n        context,\n        prop,\n        computed\n      }) {\n        const value = formatValue(prop(\"max\"), {\n          computed,\n          prop\n        });\n        context.set(\"value\", value);\n      },\n      decrementToMin({\n        context,\n        prop,\n        computed\n      }) {\n        const value = formatValue(prop(\"min\"), {\n          computed,\n          prop\n        });\n        context.set(\"value\", value);\n      },\n      setHint({\n        context,\n        event\n      }) {\n        context.set(\"hint\", event.hint);\n      },\n      clearHint({\n        context\n      }) {\n        context.set(\"hint\", null);\n      },\n      invokeOnFocus({\n        computed,\n        prop\n      }) {\n        prop(\"onFocusChange\")?.({\n          focused: true,\n          value: computed(\"formattedValue\"),\n          valueAsNumber: computed(\"valueAsNumber\")\n        });\n      },\n      invokeOnBlur({\n        computed,\n        prop\n      }) {\n        prop(\"onFocusChange\")?.({\n          focused: false,\n          value: computed(\"formattedValue\"),\n          valueAsNumber: computed(\"valueAsNumber\")\n        });\n      },\n      invokeOnInvalid({\n        computed,\n        prop,\n        event\n      }) {\n        if (event.type === \"INPUT.CHANGE\") return;\n        const reason = computed(\"valueAsNumber\") > prop(\"max\") ? \"rangeOverflow\" : \"rangeUnderflow\";\n        prop(\"onValueInvalid\")?.({\n          reason,\n          value: computed(\"formattedValue\"),\n          valueAsNumber: computed(\"valueAsNumber\")\n        });\n      },\n      syncInputElement({\n        context,\n        event,\n        computed,\n        scope\n      }) {\n        const value = event.type.endsWith(\"CHANGE\") ? context.get(\"value\") : computed(\"formattedValue\");\n        const inputEl = getInputEl(scope);\n        const sel = recordCursor(inputEl);\n        raf(() => {\n          setElementValue(inputEl, value);\n          restoreCursor(inputEl, sel);\n        });\n      },\n      setFormattedValue({\n        context,\n        computed\n      }) {\n        context.set(\"value\", computed(\"formattedValue\"));\n      },\n      setCursorPoint({\n        context,\n        event\n      }) {\n        context.set(\"scrubberCursorPoint\", event.point);\n      },\n      clearCursorPoint({\n        context\n      }) {\n        context.set(\"scrubberCursorPoint\", null);\n      },\n      setVirtualCursorPosition({\n        context,\n        scope\n      }) {\n        const cursorEl = getCursorEl(scope);\n        const point = context.get(\"scrubberCursorPoint\");\n        if (!cursorEl || !point) return;\n        cursorEl.style.transform = `translate3d(${point.x}px, ${point.y}px, 0px)`;\n      }\n    }\n  }\n});\nvar props = createProps()([\"allowMouseWheel\", \"allowOverflow\", \"clampValueOnBlur\", \"dir\", \"disabled\", \"focusInputOnChange\", \"form\", \"formatOptions\", \"getRootNode\", \"id\", \"ids\", \"inputMode\", \"invalid\", \"locale\", \"max\", \"min\", \"name\", \"onFocusChange\", \"onValueChange\", \"onValueInvalid\", \"pattern\", \"required\", \"readOnly\", \"spinOnPress\", \"step\", \"translations\", \"value\", \"defaultValue\"]);\nvar splitProps = createSplitProps(props);\nexport { anatomy, connect, machine, props, splitProps };","map":null,"metadata":{},"sourceType":"module"}