{"ast":null,"code":"import { setStyle, nextTick, raf, getComputedStyle, getEventTarget } from '@zag-js/dom-query';\nimport { createMachine } from '@zag-js/core';\nimport { createProps } from '@zag-js/types';\n\n// src/presence.connect.ts\nfunction connect(service, _normalize) {\n  const {\n    state,\n    send,\n    context\n  } = service;\n  const present = state.matches(\"mounted\", \"unmountSuspended\");\n  return {\n    skip: !context.get(\"initial\"),\n    present,\n    setNode(node) {\n      if (!node) return;\n      send({\n        type: \"NODE.SET\",\n        node\n      });\n    },\n    unmount() {\n      send({\n        type: \"UNMOUNT\"\n      });\n    }\n  };\n}\nvar machine = createMachine({\n  props({\n    props: props2\n  }) {\n    return {\n      ...props2,\n      present: !!props2.present\n    };\n  },\n  initialState({\n    prop\n  }) {\n    return prop(\"present\") ? \"mounted\" : \"unmounted\";\n  },\n  refs() {\n    return {\n      node: null,\n      styles: null\n    };\n  },\n  context({\n    bindable\n  }) {\n    return {\n      unmountAnimationName: bindable(() => ({\n        defaultValue: null\n      })),\n      prevAnimationName: bindable(() => ({\n        defaultValue: null\n      })),\n      present: bindable(() => ({\n        defaultValue: false\n      })),\n      initial: bindable(() => ({\n        sync: true,\n        defaultValue: false\n      }))\n    };\n  },\n  exit: [\"clearInitial\", \"cleanupNode\"],\n  watch({\n    track,\n    action,\n    prop\n  }) {\n    track([() => prop(\"present\")], () => {\n      action([\"setInitial\", \"syncPresence\"]);\n    });\n  },\n  on: {\n    \"NODE.SET\": {\n      actions: [\"setNode\", \"setStyles\"]\n    }\n  },\n  states: {\n    mounted: {\n      on: {\n        UNMOUNT: {\n          target: \"unmounted\",\n          actions: [\"clearPrevAnimationName\", \"invokeOnExitComplete\"]\n        },\n        \"UNMOUNT.SUSPEND\": {\n          target: \"unmountSuspended\"\n        }\n      }\n    },\n    unmountSuspended: {\n      effects: [\"trackAnimationEvents\"],\n      on: {\n        MOUNT: {\n          target: \"mounted\",\n          actions: [\"setPrevAnimationName\"]\n        },\n        UNMOUNT: {\n          target: \"unmounted\",\n          actions: [\"clearPrevAnimationName\", \"invokeOnExitComplete\"]\n        }\n      }\n    },\n    unmounted: {\n      on: {\n        MOUNT: {\n          target: \"mounted\",\n          actions: [\"setPrevAnimationName\"]\n        }\n      }\n    }\n  },\n  implementations: {\n    actions: {\n      setInitial: ({\n        context\n      }) => {\n        if (context.get(\"initial\")) return;\n        queueMicrotask(() => {\n          context.set(\"initial\", true);\n        });\n      },\n      clearInitial: ({\n        context\n      }) => {\n        context.set(\"initial\", false);\n      },\n      cleanupNode: ({\n        refs\n      }) => {\n        refs.set(\"node\", null);\n        refs.set(\"styles\", null);\n      },\n      invokeOnExitComplete: ({\n        prop\n      }) => {\n        prop(\"onExitComplete\")?.();\n      },\n      setNode: ({\n        refs,\n        event\n      }) => {\n        refs.set(\"node\", event.node);\n      },\n      setStyles: ({\n        refs,\n        event\n      }) => {\n        refs.set(\"styles\", getComputedStyle(event.node));\n      },\n      syncPresence: ({\n        context,\n        refs,\n        send,\n        prop\n      }) => {\n        const presentProp = prop(\"present\");\n        if (presentProp) {\n          return send({\n            type: \"MOUNT\",\n            src: \"presence.changed\"\n          });\n        }\n        const node = refs.get(\"node\");\n        if (!presentProp && node?.ownerDocument.visibilityState === \"hidden\") {\n          return send({\n            type: \"UNMOUNT\",\n            src: \"visibilitychange\"\n          });\n        }\n        raf(() => {\n          const animationName = getAnimationName(refs.get(\"styles\"));\n          context.set(\"unmountAnimationName\", animationName);\n          if (animationName === \"none\" || animationName === context.get(\"prevAnimationName\") || refs.get(\"styles\")?.display === \"none\" || refs.get(\"styles\")?.animationDuration === \"0s\") {\n            send({\n              type: \"UNMOUNT\",\n              src: \"presence.changed\"\n            });\n          } else {\n            send({\n              type: \"UNMOUNT.SUSPEND\"\n            });\n          }\n        });\n      },\n      setPrevAnimationName: ({\n        context,\n        refs\n      }) => {\n        raf(() => {\n          context.set(\"prevAnimationName\", getAnimationName(refs.get(\"styles\")));\n        });\n      },\n      clearPrevAnimationName: ({\n        context\n      }) => {\n        context.set(\"prevAnimationName\", null);\n      }\n    },\n    effects: {\n      trackAnimationEvents: ({\n        context,\n        refs,\n        send\n      }) => {\n        const node = refs.get(\"node\");\n        if (!node) return;\n        const onStart = event => {\n          const target = event.composedPath?.()?.[0] ?? event.target;\n          if (target === node) {\n            context.set(\"prevAnimationName\", getAnimationName(refs.get(\"styles\")));\n          }\n        };\n        const onEnd = event => {\n          const animationName = getAnimationName(refs.get(\"styles\"));\n          const target = getEventTarget(event);\n          if (target === node && animationName === context.get(\"unmountAnimationName\")) {\n            send({\n              type: \"UNMOUNT\",\n              src: \"animationend\"\n            });\n          }\n        };\n        node.addEventListener(\"animationstart\", onStart);\n        node.addEventListener(\"animationcancel\", onEnd);\n        node.addEventListener(\"animationend\", onEnd);\n        const cleanupStyles = setStyle(node, {\n          animationFillMode: \"forwards\"\n        });\n        return () => {\n          node.removeEventListener(\"animationstart\", onStart);\n          node.removeEventListener(\"animationcancel\", onEnd);\n          node.removeEventListener(\"animationend\", onEnd);\n          nextTick(() => cleanupStyles());\n        };\n      }\n    }\n  }\n});\nfunction getAnimationName(styles) {\n  return styles?.animationName || \"none\";\n}\nvar props = createProps()([\"onExitComplete\", \"present\", \"immediate\"]);\nexport { connect, machine, props };","map":null,"metadata":{},"sourceType":"module"}