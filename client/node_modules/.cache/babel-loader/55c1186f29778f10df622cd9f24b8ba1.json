{"ast":null,"code":"import { createAnatomy } from '@zag-js/anatomy';\nimport { ListCollection } from '@zag-js/collection';\nimport { raf, setCaretToEnd, observeAttributes, observeChildren, clickIfLink, scrollIntoView, query, dataAttr, ariaAttr, isDownloadingEvent, isOpeningInNewTab, isContextMenuEvent, getEventKey, isLeftClick, isComposingEvent, isAnchorElement } from '@zag-js/dom-query';\nimport { getPlacement, getPlacementStyles } from '@zag-js/popper';\nimport { match, remove, addOrRemove, isBoolean, isEqual, createSplitProps, ensure } from '@zag-js/utils';\nimport { ariaHidden } from '@zag-js/aria-hidden';\nimport { createGuards, createMachine } from '@zag-js/core';\nimport { trackDismissableElement } from '@zag-js/dismissable';\nimport { createProps } from '@zag-js/types';\n\n// src/combobox.anatomy.ts\nvar anatomy = createAnatomy(\"combobox\").parts(\"root\", \"clearTrigger\", \"content\", \"control\", \"input\", \"item\", \"itemGroup\", \"itemGroupLabel\", \"itemIndicator\", \"itemText\", \"label\", \"list\", \"positioner\", \"trigger\");\nvar parts = anatomy.build();\nvar collection = options => {\n  return new ListCollection(options);\n};\ncollection.empty = () => {\n  return new ListCollection({\n    items: []\n  });\n};\nvar getRootId = ctx => ctx.ids?.root ?? `combobox:${ctx.id}`;\nvar getLabelId = ctx => ctx.ids?.label ?? `combobox:${ctx.id}:label`;\nvar getControlId = ctx => ctx.ids?.control ?? `combobox:${ctx.id}:control`;\nvar getInputId = ctx => ctx.ids?.input ?? `combobox:${ctx.id}:input`;\nvar getContentId = ctx => ctx.ids?.content ?? `combobox:${ctx.id}:content`;\nvar getPositionerId = ctx => ctx.ids?.positioner ?? `combobox:${ctx.id}:popper`;\nvar getTriggerId = ctx => ctx.ids?.trigger ?? `combobox:${ctx.id}:toggle-btn`;\nvar getClearTriggerId = ctx => ctx.ids?.clearTrigger ?? `combobox:${ctx.id}:clear-btn`;\nvar getItemGroupId = (ctx, id) => ctx.ids?.itemGroup?.(id) ?? `combobox:${ctx.id}:optgroup:${id}`;\nvar getItemGroupLabelId = (ctx, id) => ctx.ids?.itemGroupLabel?.(id) ?? `combobox:${ctx.id}:optgroup-label:${id}`;\nvar getItemId = (ctx, id) => ctx.ids?.item?.(id) ?? `combobox:${ctx.id}:option:${id}`;\nvar getContentEl = ctx => ctx.getById(getContentId(ctx));\nvar getInputEl = ctx => ctx.getById(getInputId(ctx));\nvar getPositionerEl = ctx => ctx.getById(getPositionerId(ctx));\nvar getControlEl = ctx => ctx.getById(getControlId(ctx));\nvar getTriggerEl = ctx => ctx.getById(getTriggerId(ctx));\nvar getClearTriggerEl = ctx => ctx.getById(getClearTriggerId(ctx));\nvar getItemEl = (ctx, value) => {\n  if (value == null) return;\n  const selector = `[role=option][data-value=\"${CSS.escape(value)}\"`;\n  return query(getContentEl(ctx), selector);\n};\nvar focusInputEl = ctx => {\n  const inputEl = getInputEl(ctx);\n  if (ctx.isActiveElement(inputEl)) return;\n  inputEl?.focus({\n    preventScroll: true\n  });\n};\nvar focusTriggerEl = ctx => {\n  const triggerEl = getTriggerEl(ctx);\n  if (ctx.isActiveElement(triggerEl)) return;\n  triggerEl?.focus({\n    preventScroll: true\n  });\n};\n\n// src/combobox.connect.ts\nfunction connect(service, normalize) {\n  const {\n    context,\n    prop,\n    state,\n    send,\n    scope,\n    computed,\n    event\n  } = service;\n  const translations = prop(\"translations\");\n  const collection2 = prop(\"collection\");\n  const disabled = prop(\"disabled\");\n  const interactive = computed(\"isInteractive\");\n  const invalid = prop(\"invalid\");\n  const readOnly = prop(\"readOnly\");\n  const open = state.hasTag(\"open\");\n  const focused = state.hasTag(\"focused\");\n  const composite = prop(\"composite\");\n  const highlightedValue = context.get(\"highlightedValue\");\n  const popperStyles = getPlacementStyles({\n    ...prop(\"positioning\"),\n    placement: context.get(\"currentPlacement\")\n  });\n  function getItemState(props2) {\n    const disabled2 = collection2.getItemDisabled(props2.item);\n    const value = collection2.getItemValue(props2.item);\n    ensure(value, () => `[zag-js] No value found for item ${JSON.stringify(props2.item)}`);\n    return {\n      value,\n      disabled: Boolean(disabled2 || disabled2),\n      highlighted: highlightedValue === value,\n      selected: context.get(\"value\").includes(value)\n    };\n  }\n  return {\n    focused,\n    open,\n    inputValue: context.get(\"inputValue\"),\n    highlightedValue,\n    highlightedItem: context.get(\"highlightedItem\"),\n    value: context.get(\"value\"),\n    valueAsString: context.get(\"valueAsString\"),\n    hasSelectedItems: computed(\"hasSelectedItems\"),\n    selectedItems: context.get(\"selectedItems\"),\n    collection: prop(\"collection\"),\n    multiple: !!prop(\"multiple\"),\n    disabled: !!disabled,\n    syncSelectedItems() {\n      send({\n        type: \"SELECTED_ITEMS.SYNC\"\n      });\n    },\n    reposition(options = {}) {\n      send({\n        type: \"POSITIONING.SET\",\n        options\n      });\n    },\n    setHighlightValue(value) {\n      send({\n        type: \"HIGHLIGHTED_VALUE.SET\",\n        value\n      });\n    },\n    selectValue(value) {\n      send({\n        type: \"ITEM.SELECT\",\n        value\n      });\n    },\n    setValue(value) {\n      send({\n        type: \"VALUE.SET\",\n        value\n      });\n    },\n    setInputValue(value) {\n      send({\n        type: \"INPUT_VALUE.SET\",\n        value\n      });\n    },\n    clearValue(value) {\n      if (value != null) {\n        send({\n          type: \"ITEM.CLEAR\",\n          value\n        });\n      } else {\n        send({\n          type: \"VALUE.CLEAR\"\n        });\n      }\n    },\n    focus() {\n      getInputEl(scope)?.focus();\n    },\n    setOpen(nextOpen) {\n      const open2 = state.hasTag(\"open\");\n      if (open2 === nextOpen) return;\n      send({\n        type: nextOpen ? \"OPEN\" : \"CLOSE\"\n      });\n    },\n    getRootProps() {\n      return normalize.element({\n        ...parts.root.attrs,\n        dir: prop(\"dir\"),\n        id: getRootId(scope),\n        \"data-invalid\": dataAttr(invalid),\n        \"data-readonly\": dataAttr(readOnly)\n      });\n    },\n    getLabelProps() {\n      return normalize.label({\n        ...parts.label.attrs,\n        dir: prop(\"dir\"),\n        htmlFor: getInputId(scope),\n        id: getLabelId(scope),\n        \"data-readonly\": dataAttr(readOnly),\n        \"data-disabled\": dataAttr(disabled),\n        \"data-invalid\": dataAttr(invalid),\n        \"data-focus\": dataAttr(focused),\n        onClick(event2) {\n          if (composite) return;\n          event2.preventDefault();\n          getTriggerEl(scope)?.focus({\n            preventScroll: true\n          });\n        }\n      });\n    },\n    getControlProps() {\n      return normalize.element({\n        ...parts.control.attrs,\n        dir: prop(\"dir\"),\n        id: getControlId(scope),\n        \"data-state\": open ? \"open\" : \"closed\",\n        \"data-focus\": dataAttr(focused),\n        \"data-disabled\": dataAttr(disabled),\n        \"data-invalid\": dataAttr(invalid)\n      });\n    },\n    getPositionerProps() {\n      return normalize.element({\n        ...parts.positioner.attrs,\n        dir: prop(\"dir\"),\n        id: getPositionerId(scope),\n        style: popperStyles.floating\n      });\n    },\n    getInputProps() {\n      return normalize.input({\n        ...parts.input.attrs,\n        dir: prop(\"dir\"),\n        \"aria-invalid\": ariaAttr(invalid),\n        \"data-invalid\": dataAttr(invalid),\n        name: prop(\"name\"),\n        form: prop(\"form\"),\n        disabled,\n        autoFocus: prop(\"autoFocus\"),\n        required: prop(\"required\"),\n        autoComplete: \"off\",\n        autoCorrect: \"off\",\n        autoCapitalize: \"none\",\n        spellCheck: \"false\",\n        readOnly,\n        placeholder: prop(\"placeholder\"),\n        id: getInputId(scope),\n        type: \"text\",\n        role: \"combobox\",\n        defaultValue: context.get(\"inputValue\"),\n        \"aria-autocomplete\": computed(\"autoComplete\") ? \"both\" : \"list\",\n        \"aria-controls\": getContentId(scope),\n        \"aria-expanded\": open,\n        \"data-state\": open ? \"open\" : \"closed\",\n        \"aria-activedescendant\": highlightedValue ? getItemId(scope, highlightedValue) : void 0,\n        onClick(event2) {\n          if (event2.defaultPrevented) return;\n          if (!prop(\"openOnClick\")) return;\n          if (!interactive) return;\n          send({\n            type: \"INPUT.CLICK\"\n          });\n        },\n        onFocus() {\n          if (disabled) return;\n          send({\n            type: \"INPUT.FOCUS\"\n          });\n        },\n        onBlur() {\n          if (disabled) return;\n          send({\n            type: \"INPUT.BLUR\"\n          });\n        },\n        onChange(event2) {\n          send({\n            type: \"INPUT.CHANGE\",\n            value: event2.currentTarget.value\n          });\n        },\n        onKeyDown(event2) {\n          if (event2.defaultPrevented) return;\n          if (!interactive) return;\n          if (event2.ctrlKey || event2.shiftKey || isComposingEvent(event2)) return;\n          const openOnKeyPress = prop(\"openOnKeyPress\");\n          const isModifierKey = event2.ctrlKey || event2.metaKey || event2.shiftKey;\n          const keypress = true;\n          const keymap = {\n            ArrowDown(event3) {\n              if (!openOnKeyPress && !open) return;\n              send({\n                type: event3.altKey ? \"OPEN\" : \"INPUT.ARROW_DOWN\",\n                keypress\n              });\n              event3.preventDefault();\n            },\n            ArrowUp() {\n              if (!openOnKeyPress && !open) return;\n              send({\n                type: event2.altKey ? \"CLOSE\" : \"INPUT.ARROW_UP\",\n                keypress\n              });\n              event2.preventDefault();\n            },\n            Home(event3) {\n              if (isModifierKey) return;\n              send({\n                type: \"INPUT.HOME\",\n                keypress\n              });\n              if (open) {\n                event3.preventDefault();\n              }\n            },\n            End(event3) {\n              if (isModifierKey) return;\n              send({\n                type: \"INPUT.END\",\n                keypress\n              });\n              if (open) {\n                event3.preventDefault();\n              }\n            },\n            Enter(event3) {\n              send({\n                type: \"INPUT.ENTER\",\n                keypress\n              });\n              if (open) {\n                event3.preventDefault();\n              }\n              const highlightedValue2 = context.get(\"highlightedValue\");\n              const itemEl = getItemEl(scope, highlightedValue2);\n              if (isAnchorElement(itemEl)) {\n                prop(\"navigate\")({\n                  value: highlightedValue2,\n                  node: itemEl\n                });\n              }\n            },\n            Escape() {\n              send({\n                type: \"INPUT.ESCAPE\",\n                keypress\n              });\n              event2.preventDefault();\n            }\n          };\n          const key = getEventKey(event2, {\n            dir: prop(\"dir\")\n          });\n          const exec = keymap[key];\n          exec?.(event2);\n        }\n      });\n    },\n    getTriggerProps(props2 = {}) {\n      return normalize.button({\n        ...parts.trigger.attrs,\n        dir: prop(\"dir\"),\n        id: getTriggerId(scope),\n        \"aria-haspopup\": composite ? \"listbox\" : \"dialog\",\n        type: \"button\",\n        tabIndex: props2.focusable ? void 0 : -1,\n        \"aria-label\": translations.triggerLabel,\n        \"aria-expanded\": open,\n        \"data-state\": open ? \"open\" : \"closed\",\n        \"aria-controls\": open ? getContentId(scope) : void 0,\n        disabled,\n        \"data-invalid\": dataAttr(invalid),\n        \"data-focusable\": dataAttr(props2.focusable),\n        \"data-readonly\": dataAttr(readOnly),\n        \"data-disabled\": dataAttr(disabled),\n        onFocus() {\n          if (!props2.focusable) return;\n          send({\n            type: \"INPUT.FOCUS\",\n            src: \"trigger\"\n          });\n        },\n        onClick(event2) {\n          if (event2.defaultPrevented) return;\n          if (!interactive) return;\n          if (!isLeftClick(event2)) return;\n          send({\n            type: \"TRIGGER.CLICK\"\n          });\n        },\n        onPointerDown(event2) {\n          if (!interactive) return;\n          if (event2.pointerType === \"touch\") return;\n          event2.preventDefault();\n          queueMicrotask(() => {\n            getInputEl(scope)?.focus({\n              preventScroll: true\n            });\n          });\n        },\n        onKeyDown(event2) {\n          if (event2.defaultPrevented) return;\n          if (composite) return;\n          const keyMap = {\n            ArrowDown() {\n              send({\n                type: \"INPUT.ARROW_DOWN\",\n                src: \"trigger\"\n              });\n            },\n            ArrowUp() {\n              send({\n                type: \"INPUT.ARROW_UP\",\n                src: \"trigger\"\n              });\n            }\n          };\n          const key = getEventKey(event2, {\n            dir: prop(\"dir\")\n          });\n          const exec = keyMap[key];\n          if (exec) {\n            exec(event2);\n            event2.preventDefault();\n          }\n        }\n      });\n    },\n    getContentProps() {\n      return normalize.element({\n        ...parts.content.attrs,\n        dir: prop(\"dir\"),\n        id: getContentId(scope),\n        role: !composite ? \"dialog\" : \"listbox\",\n        tabIndex: -1,\n        hidden: !open,\n        \"data-state\": open ? \"open\" : \"closed\",\n        \"data-placement\": context.get(\"currentPlacement\"),\n        \"aria-labelledby\": getLabelId(scope),\n        \"aria-multiselectable\": prop(\"multiple\") && composite ? true : void 0,\n        onPointerDown(event2) {\n          event2.preventDefault();\n        }\n      });\n    },\n    getListProps() {\n      return normalize.element({\n        ...parts.list.attrs,\n        role: !composite ? \"listbox\" : void 0,\n        \"aria-labelledby\": getLabelId(scope),\n        \"aria-multiselectable\": prop(\"multiple\") && !composite ? true : void 0\n      });\n    },\n    getClearTriggerProps() {\n      return normalize.button({\n        ...parts.clearTrigger.attrs,\n        dir: prop(\"dir\"),\n        id: getClearTriggerId(scope),\n        type: \"button\",\n        tabIndex: -1,\n        disabled,\n        \"data-invalid\": dataAttr(invalid),\n        \"aria-label\": translations.clearTriggerLabel,\n        \"aria-controls\": getInputId(scope),\n        hidden: !context.get(\"value\").length,\n        onPointerDown(event2) {\n          event2.preventDefault();\n        },\n        onClick(event2) {\n          if (event2.defaultPrevented) return;\n          if (!interactive) return;\n          send({\n            type: \"VALUE.CLEAR\",\n            src: \"clear-trigger\"\n          });\n        }\n      });\n    },\n    getItemState,\n    getItemProps(props2) {\n      const itemState = getItemState(props2);\n      const value = itemState.value;\n      return normalize.element({\n        ...parts.item.attrs,\n        dir: prop(\"dir\"),\n        id: getItemId(scope, value),\n        role: \"option\",\n        tabIndex: -1,\n        \"data-highlighted\": dataAttr(itemState.highlighted),\n        \"data-state\": itemState.selected ? \"checked\" : \"unchecked\",\n        \"aria-selected\": ariaAttr(itemState.highlighted),\n        \"aria-disabled\": ariaAttr(itemState.disabled),\n        \"data-disabled\": dataAttr(itemState.disabled),\n        \"data-value\": itemState.value,\n        onPointerMove() {\n          if (itemState.disabled) return;\n          if (itemState.highlighted) return;\n          send({\n            type: \"ITEM.POINTER_MOVE\",\n            value\n          });\n        },\n        onPointerLeave() {\n          if (props2.persistFocus) return;\n          if (itemState.disabled) return;\n          const prev = event.previous();\n          const mouseMoved = prev?.type.includes(\"POINTER\");\n          if (!mouseMoved) return;\n          send({\n            type: \"ITEM.POINTER_LEAVE\",\n            value\n          });\n        },\n        onClick(event2) {\n          if (isDownloadingEvent(event2)) return;\n          if (isOpeningInNewTab(event2)) return;\n          if (isContextMenuEvent(event2)) return;\n          if (itemState.disabled) return;\n          send({\n            type: \"ITEM.CLICK\",\n            src: \"click\",\n            value\n          });\n        }\n      });\n    },\n    getItemTextProps(props2) {\n      const itemState = getItemState(props2);\n      return normalize.element({\n        ...parts.itemText.attrs,\n        dir: prop(\"dir\"),\n        \"data-state\": itemState.selected ? \"checked\" : \"unchecked\",\n        \"data-disabled\": dataAttr(itemState.disabled),\n        \"data-highlighted\": dataAttr(itemState.highlighted)\n      });\n    },\n    getItemIndicatorProps(props2) {\n      const itemState = getItemState(props2);\n      return normalize.element({\n        \"aria-hidden\": true,\n        ...parts.itemIndicator.attrs,\n        dir: prop(\"dir\"),\n        \"data-state\": itemState.selected ? \"checked\" : \"unchecked\",\n        hidden: !itemState.selected\n      });\n    },\n    getItemGroupProps(props2) {\n      const {\n        id\n      } = props2;\n      return normalize.element({\n        ...parts.itemGroup.attrs,\n        dir: prop(\"dir\"),\n        id: getItemGroupId(scope, id),\n        \"aria-labelledby\": getItemGroupLabelId(scope, id),\n        role: \"group\"\n      });\n    },\n    getItemGroupLabelProps(props2) {\n      const {\n        htmlFor\n      } = props2;\n      return normalize.element({\n        ...parts.itemGroupLabel.attrs,\n        dir: prop(\"dir\"),\n        id: getItemGroupLabelId(scope, htmlFor),\n        role: \"presentation\"\n      });\n    }\n  };\n}\nvar {\n  and,\n  not\n} = createGuards();\nvar machine = createMachine({\n  props({\n    props: props2\n  }) {\n    return {\n      loopFocus: true,\n      openOnClick: false,\n      defaultValue: [],\n      closeOnSelect: !props2.multiple,\n      allowCustomValue: false,\n      inputBehavior: \"none\",\n      selectionBehavior: props2.multiple ? \"clear\" : \"replace\",\n      openOnKeyPress: true,\n      openOnChange: true,\n      composite: true,\n      navigate({\n        node\n      }) {\n        clickIfLink(node);\n      },\n      collection: collection.empty(),\n      ...props2,\n      positioning: {\n        placement: \"bottom\",\n        sameWidth: true,\n        ...props2.positioning\n      },\n      translations: {\n        triggerLabel: \"Toggle suggestions\",\n        clearTriggerLabel: \"Clear value\",\n        ...props2.translations\n      }\n    };\n  },\n  initialState({\n    prop\n  }) {\n    const open = prop(\"open\") || prop(\"defaultOpen\");\n    return open ? \"suggesting\" : \"idle\";\n  },\n  context({\n    prop,\n    bindable,\n    getContext\n  }) {\n    return {\n      currentPlacement: bindable(() => ({\n        defaultValue: void 0\n      })),\n      value: bindable(() => ({\n        defaultValue: prop(\"defaultValue\"),\n        value: prop(\"value\"),\n        isEqual,\n        hash(value) {\n          return value.join(\",\");\n        },\n        onChange(value) {\n          const context = getContext();\n          const prevSelectedItems = context.get(\"selectedItems\");\n          const collection2 = prop(\"collection\");\n          const nextItems = value.map(v => {\n            const item = prevSelectedItems.find(item2 => collection2.getItemValue(item2) === v);\n            return item || collection2.find(v);\n          });\n          context.set(\"selectedItems\", nextItems);\n          context.set(\"valueAsString\", collection2.stringifyItems(nextItems));\n          prop(\"onValueChange\")?.({\n            value,\n            items: nextItems\n          });\n        }\n      })),\n      highlightedValue: bindable(() => ({\n        defaultValue: prop(\"defaultHighlightedValue\") || null,\n        value: prop(\"highlightedValue\"),\n        onChange(value) {\n          const item = prop(\"collection\").find(value);\n          prop(\"onHighlightChange\")?.({\n            highlightedValue: value,\n            highlightedItem: item\n          });\n        }\n      })),\n      inputValue: bindable(() => {\n        let inputValue = prop(\"inputValue\") || prop(\"defaultInputValue\") || \"\";\n        const value = prop(\"defaultValue\") || prop(\"value\") || [];\n        if (!inputValue.trim() && !prop(\"multiple\")) {\n          const valueAsString = prop(\"collection\").stringifyMany(value);\n          inputValue = match(prop(\"selectionBehavior\"), {\n            preserve: inputValue || valueAsString,\n            replace: valueAsString,\n            clear: \"\"\n          });\n        }\n        return {\n          defaultValue: inputValue,\n          value: prop(\"inputValue\"),\n          onChange(value2) {\n            prop(\"onInputValueChange\")?.({\n              inputValue: value2\n            });\n          }\n        };\n      }),\n      highlightedItem: bindable(() => {\n        const highlightedValue = prop(\"highlightedValue\");\n        const highlightedItem = prop(\"collection\").find(highlightedValue);\n        return {\n          defaultValue: highlightedItem\n        };\n      }),\n      selectedItems: bindable(() => {\n        const value = prop(\"value\") || prop(\"defaultValue\") || [];\n        const selectedItems = prop(\"collection\").findMany(value);\n        return {\n          defaultValue: selectedItems\n        };\n      }),\n      valueAsString: bindable(() => {\n        const value = prop(\"value\") || prop(\"defaultValue\") || [];\n        const valueAsString = prop(\"collection\").stringifyMany(value);\n        return {\n          sync: true,\n          defaultValue: valueAsString\n        };\n      })\n    };\n  },\n  computed: {\n    isInputValueEmpty: ({\n      context\n    }) => context.get(\"inputValue\").length === 0,\n    isInteractive: ({\n      prop\n    }) => !(prop(\"readOnly\") || prop(\"disabled\")),\n    autoComplete: ({\n      prop\n    }) => prop(\"inputBehavior\") === \"autocomplete\",\n    autoHighlight: ({\n      prop\n    }) => prop(\"inputBehavior\") === \"autohighlight\",\n    hasSelectedItems: ({\n      context\n    }) => context.get(\"value\").length > 0\n  },\n  watch({\n    context,\n    prop,\n    track,\n    action\n  }) {\n    track([() => context.hash(\"value\")], () => {\n      action([\"syncSelectedItems\"]);\n    });\n    track([() => context.get(\"inputValue\")], () => {\n      action([\"syncInputValue\"]);\n    });\n    track([() => context.get(\"highlightedValue\")], () => {\n      action([\"syncHighlightedItem\", \"autofillInputValue\"]);\n    });\n    track([() => prop(\"open\")], () => {\n      action([\"toggleVisibility\"]);\n    });\n  },\n  on: {\n    \"SELECTED_ITEMS.SYNC\": {\n      actions: [\"syncSelectedItems\"]\n    },\n    \"HIGHLIGHTED_VALUE.SET\": {\n      actions: [\"setHighlightedItem\"]\n    },\n    \"ITEM.SELECT\": {\n      actions: [\"selectItem\"]\n    },\n    \"ITEM.CLEAR\": {\n      actions: [\"clearItem\"]\n    },\n    \"VALUE.SET\": {\n      actions: [\"setValue\"]\n    },\n    \"INPUT_VALUE.SET\": {\n      actions: [\"setInputValue\"]\n    },\n    \"POSITIONING.SET\": {\n      actions: [\"reposition\"]\n    }\n  },\n  states: {\n    idle: {\n      tags: [\"idle\", \"closed\"],\n      entry: [\"scrollContentToTop\", \"clearHighlightedItem\"],\n      on: {\n        \"CONTROLLED.OPEN\": {\n          target: \"interacting\"\n        },\n        \"TRIGGER.CLICK\": [{\n          guard: \"isOpenControlled\",\n          actions: [\"setInitialFocus\", \"highlightFirstSelectedItem\", \"invokeOnOpen\"]\n        }, {\n          target: \"interacting\",\n          actions: [\"setInitialFocus\", \"highlightFirstSelectedItem\", \"invokeOnOpen\"]\n        }],\n        \"INPUT.CLICK\": [{\n          guard: \"isOpenControlled\",\n          actions: [\"highlightFirstSelectedItem\", \"invokeOnOpen\"]\n        }, {\n          target: \"interacting\",\n          actions: [\"highlightFirstSelectedItem\", \"invokeOnOpen\"]\n        }],\n        \"INPUT.FOCUS\": {\n          target: \"focused\"\n        },\n        OPEN: [{\n          guard: \"isOpenControlled\",\n          actions: [\"invokeOnOpen\"]\n        }, {\n          target: \"interacting\",\n          actions: [\"invokeOnOpen\"]\n        }],\n        \"VALUE.CLEAR\": {\n          target: \"focused\",\n          actions: [\"clearInputValue\", \"clearSelectedItems\", \"setInitialFocus\"]\n        }\n      }\n    },\n    focused: {\n      tags: [\"focused\", \"closed\"],\n      entry: [\"scrollContentToTop\", \"clearHighlightedItem\"],\n      on: {\n        \"CONTROLLED.OPEN\": [{\n          guard: \"isChangeEvent\",\n          target: \"suggesting\"\n        }, {\n          target: \"interacting\"\n        }],\n        \"INPUT.CHANGE\": [{\n          guard: and(\"isOpenControlled\", \"openOnChange\"),\n          actions: [\"setInputValue\", \"invokeOnOpen\", \"highlightFirstItemIfNeeded\"]\n        }, {\n          guard: \"openOnChange\",\n          target: \"suggesting\",\n          actions: [\"setInputValue\", \"invokeOnOpen\", \"highlightFirstItemIfNeeded\"]\n        }, {\n          actions: [\"setInputValue\"]\n        }],\n        \"LAYER.INTERACT_OUTSIDE\": {\n          target: \"idle\"\n        },\n        \"INPUT.ESCAPE\": {\n          guard: and(\"isCustomValue\", not(\"allowCustomValue\")),\n          actions: [\"revertInputValue\"]\n        },\n        \"INPUT.BLUR\": {\n          target: \"idle\"\n        },\n        \"INPUT.CLICK\": [{\n          guard: \"isOpenControlled\",\n          actions: [\"highlightFirstSelectedItem\", \"invokeOnOpen\"]\n        }, {\n          target: \"interacting\",\n          actions: [\"highlightFirstSelectedItem\", \"invokeOnOpen\"]\n        }],\n        \"TRIGGER.CLICK\": [{\n          guard: \"isOpenControlled\",\n          actions: [\"setInitialFocus\", \"highlightFirstSelectedItem\", \"invokeOnOpen\"]\n        }, {\n          target: \"interacting\",\n          actions: [\"setInitialFocus\", \"highlightFirstSelectedItem\", \"invokeOnOpen\"]\n        }],\n        \"INPUT.ARROW_DOWN\": [\n        // == group 1 ==\n        {\n          guard: and(\"isOpenControlled\", \"autoComplete\"),\n          actions: [\"invokeOnOpen\"]\n        }, {\n          guard: \"autoComplete\",\n          target: \"interacting\",\n          actions: [\"invokeOnOpen\"]\n        },\n        // == group 2 ==\n        {\n          guard: \"isOpenControlled\",\n          actions: [\"highlightFirstOrSelectedItem\", \"invokeOnOpen\"]\n        }, {\n          target: \"interacting\",\n          actions: [\"highlightFirstOrSelectedItem\", \"invokeOnOpen\"]\n        }],\n        \"INPUT.ARROW_UP\": [\n        // == group 1 ==\n        {\n          guard: \"autoComplete\",\n          target: \"interacting\",\n          actions: [\"invokeOnOpen\"]\n        }, {\n          guard: \"autoComplete\",\n          target: \"interacting\",\n          actions: [\"invokeOnOpen\"]\n        },\n        // == group 2 ==\n        {\n          target: \"interacting\",\n          actions: [\"highlightLastOrSelectedItem\", \"invokeOnOpen\"]\n        }, {\n          target: \"interacting\",\n          actions: [\"highlightLastOrSelectedItem\", \"invokeOnOpen\"]\n        }],\n        OPEN: [{\n          guard: \"isOpenControlled\",\n          actions: [\"invokeOnOpen\"]\n        }, {\n          target: \"interacting\",\n          actions: [\"invokeOnOpen\"]\n        }],\n        \"VALUE.CLEAR\": {\n          actions: [\"clearInputValue\", \"clearSelectedItems\"]\n        }\n      }\n    },\n    interacting: {\n      tags: [\"open\", \"focused\"],\n      entry: [\"setInitialFocus\"],\n      effects: [\"scrollToHighlightedItem\", \"trackDismissableLayer\", \"trackPlacement\", \"hideOtherElements\"],\n      on: {\n        \"CONTROLLED.CLOSE\": [{\n          guard: \"restoreFocus\",\n          target: \"focused\",\n          actions: [\"setFinalFocus\"]\n        }, {\n          target: \"idle\"\n        }],\n        \"INPUT.HOME\": {\n          actions: [\"highlightFirstItem\"]\n        },\n        \"INPUT.END\": {\n          actions: [\"highlightLastItem\"]\n        },\n        \"INPUT.ARROW_DOWN\": [{\n          guard: and(\"autoComplete\", \"isLastItemHighlighted\"),\n          actions: [\"clearHighlightedItem\", \"scrollContentToTop\"]\n        }, {\n          actions: [\"highlightNextItem\"]\n        }],\n        \"INPUT.ARROW_UP\": [{\n          guard: and(\"autoComplete\", \"isFirstItemHighlighted\"),\n          actions: [\"clearHighlightedItem\"]\n        }, {\n          actions: [\"highlightPrevItem\"]\n        }],\n        \"INPUT.ENTER\": [\n        // == group 1 ==\n        {\n          guard: and(\"isOpenControlled\", \"isCustomValue\", not(\"hasHighlightedItem\"), not(\"allowCustomValue\")),\n          actions: [\"revertInputValue\", \"invokeOnClose\"]\n        }, {\n          guard: and(\"isCustomValue\", not(\"hasHighlightedItem\"), not(\"allowCustomValue\")),\n          target: \"focused\",\n          actions: [\"revertInputValue\", \"invokeOnClose\"]\n        },\n        // == group 2 ==\n        {\n          guard: and(\"isOpenControlled\", \"closeOnSelect\"),\n          actions: [\"selectHighlightedItem\", \"invokeOnClose\"]\n        }, {\n          guard: \"closeOnSelect\",\n          target: \"focused\",\n          actions: [\"selectHighlightedItem\", \"invokeOnClose\", \"setFinalFocus\"]\n        }, {\n          actions: [\"selectHighlightedItem\"]\n        }],\n        \"INPUT.CHANGE\": [{\n          guard: \"autoComplete\",\n          target: \"suggesting\",\n          actions: [\"setInputValue\"]\n        }, {\n          target: \"suggesting\",\n          actions: [\"clearHighlightedItem\", \"setInputValue\"]\n        }],\n        \"ITEM.POINTER_MOVE\": {\n          actions: [\"setHighlightedItem\"]\n        },\n        \"ITEM.POINTER_LEAVE\": {\n          actions: [\"clearHighlightedItem\"]\n        },\n        \"ITEM.CLICK\": [{\n          guard: and(\"isOpenControlled\", \"closeOnSelect\"),\n          actions: [\"selectItem\", \"invokeOnClose\"]\n        }, {\n          guard: \"closeOnSelect\",\n          target: \"focused\",\n          actions: [\"selectItem\", \"invokeOnClose\", \"setFinalFocus\"]\n        }, {\n          actions: [\"selectItem\"]\n        }],\n        \"LAYER.ESCAPE\": [{\n          guard: and(\"isOpenControlled\", \"autoComplete\"),\n          actions: [\"syncInputValue\", \"invokeOnClose\"]\n        }, {\n          guard: \"autoComplete\",\n          target: \"focused\",\n          actions: [\"syncInputValue\", \"invokeOnClose\"]\n        }, {\n          guard: \"isOpenControlled\",\n          actions: [\"invokeOnClose\"]\n        }, {\n          target: \"focused\",\n          actions: [\"invokeOnClose\", \"setFinalFocus\"]\n        }],\n        \"TRIGGER.CLICK\": [{\n          guard: \"isOpenControlled\",\n          actions: [\"invokeOnClose\"]\n        }, {\n          target: \"focused\",\n          actions: [\"invokeOnClose\"]\n        }],\n        \"LAYER.INTERACT_OUTSIDE\": [\n        // == group 1 ==\n        {\n          guard: and(\"isOpenControlled\", \"isCustomValue\", not(\"allowCustomValue\")),\n          actions: [\"revertInputValue\", \"invokeOnClose\"]\n        }, {\n          guard: and(\"isCustomValue\", not(\"allowCustomValue\")),\n          target: \"idle\",\n          actions: [\"revertInputValue\", \"invokeOnClose\"]\n        },\n        // == group 2 ==\n        {\n          guard: \"isOpenControlled\",\n          actions: [\"invokeOnClose\"]\n        }, {\n          target: \"idle\",\n          actions: [\"invokeOnClose\"]\n        }],\n        CLOSE: [{\n          guard: \"isOpenControlled\",\n          actions: [\"invokeOnClose\"]\n        }, {\n          target: \"focused\",\n          actions: [\"invokeOnClose\", \"setFinalFocus\"]\n        }],\n        \"VALUE.CLEAR\": [{\n          guard: \"isOpenControlled\",\n          actions: [\"clearInputValue\", \"clearSelectedItems\", \"invokeOnClose\"]\n        }, {\n          target: \"focused\",\n          actions: [\"clearInputValue\", \"clearSelectedItems\", \"invokeOnClose\", \"setFinalFocus\"]\n        }]\n      }\n    },\n    suggesting: {\n      tags: [\"open\", \"focused\"],\n      effects: [\"trackDismissableLayer\", \"scrollToHighlightedItem\", \"trackPlacement\", \"trackChildNodes\", \"hideOtherElements\"],\n      entry: [\"setInitialFocus\"],\n      on: {\n        \"CONTROLLED.CLOSE\": [{\n          guard: \"restoreFocus\",\n          target: \"focused\",\n          actions: [\"setFinalFocus\"]\n        }, {\n          target: \"idle\"\n        }],\n        CHILDREN_CHANGE: {\n          guard: \"autoHighlight\",\n          actions: [\"highlightFirstItem\"]\n        },\n        \"INPUT.ARROW_DOWN\": {\n          target: \"interacting\",\n          actions: [\"highlightNextItem\"]\n        },\n        \"INPUT.ARROW_UP\": {\n          target: \"interacting\",\n          actions: [\"highlightPrevItem\"]\n        },\n        \"INPUT.HOME\": {\n          target: \"interacting\",\n          actions: [\"highlightFirstItem\"]\n        },\n        \"INPUT.END\": {\n          target: \"interacting\",\n          actions: [\"highlightLastItem\"]\n        },\n        \"INPUT.ENTER\": [\n        // == group 1 ==\n        {\n          guard: and(\"isOpenControlled\", \"isCustomValue\", not(\"hasHighlightedItem\"), not(\"allowCustomValue\")),\n          actions: [\"revertInputValue\", \"invokeOnClose\"]\n        }, {\n          guard: and(\"isCustomValue\", not(\"hasHighlightedItem\"), not(\"allowCustomValue\")),\n          target: \"focused\",\n          actions: [\"revertInputValue\", \"invokeOnClose\"]\n        },\n        // == group 2 ==\n        {\n          guard: and(\"isOpenControlled\", \"closeOnSelect\"),\n          actions: [\"selectHighlightedItem\", \"invokeOnClose\"]\n        }, {\n          guard: \"closeOnSelect\",\n          target: \"focused\",\n          actions: [\"selectHighlightedItem\", \"invokeOnClose\", \"setFinalFocus\"]\n        }, {\n          actions: [\"selectHighlightedItem\"]\n        }],\n        \"INPUT.CHANGE\": {\n          actions: [\"setInputValue\"]\n        },\n        \"LAYER.ESCAPE\": [{\n          guard: \"isOpenControlled\",\n          actions: [\"invokeOnClose\"]\n        }, {\n          target: \"focused\",\n          actions: [\"invokeOnClose\"]\n        }],\n        \"ITEM.POINTER_MOVE\": {\n          target: \"interacting\",\n          actions: [\"setHighlightedItem\"]\n        },\n        \"ITEM.POINTER_LEAVE\": {\n          actions: [\"clearHighlightedItem\"]\n        },\n        \"LAYER.INTERACT_OUTSIDE\": [\n        // == group 1 ==\n        {\n          guard: and(\"isOpenControlled\", \"isCustomValue\", not(\"allowCustomValue\")),\n          actions: [\"revertInputValue\", \"invokeOnClose\"]\n        }, {\n          guard: and(\"isCustomValue\", not(\"allowCustomValue\")),\n          target: \"idle\",\n          actions: [\"revertInputValue\", \"invokeOnClose\"]\n        },\n        // == group 2 ==\n        {\n          guard: \"isOpenControlled\",\n          actions: [\"invokeOnClose\"]\n        }, {\n          target: \"idle\",\n          actions: [\"invokeOnClose\"]\n        }],\n        \"TRIGGER.CLICK\": [{\n          guard: \"isOpenControlled\",\n          actions: [\"invokeOnClose\"]\n        }, {\n          target: \"focused\",\n          actions: [\"invokeOnClose\"]\n        }],\n        \"ITEM.CLICK\": [{\n          guard: and(\"isOpenControlled\", \"closeOnSelect\"),\n          actions: [\"selectItem\", \"invokeOnClose\"]\n        }, {\n          guard: \"closeOnSelect\",\n          target: \"focused\",\n          actions: [\"selectItem\", \"invokeOnClose\", \"setFinalFocus\"]\n        }, {\n          actions: [\"selectItem\"]\n        }],\n        CLOSE: [{\n          guard: \"isOpenControlled\",\n          actions: [\"invokeOnClose\"]\n        }, {\n          target: \"focused\",\n          actions: [\"invokeOnClose\", \"setFinalFocus\"]\n        }],\n        \"VALUE.CLEAR\": [{\n          guard: \"isOpenControlled\",\n          actions: [\"clearInputValue\", \"clearSelectedItems\", \"invokeOnClose\"]\n        }, {\n          target: \"focused\",\n          actions: [\"clearInputValue\", \"clearSelectedItems\", \"invokeOnClose\", \"setFinalFocus\"]\n        }]\n      }\n    }\n  },\n  implementations: {\n    guards: {\n      isInputValueEmpty: ({\n        computed\n      }) => computed(\"isInputValueEmpty\"),\n      autoComplete: ({\n        computed,\n        prop\n      }) => computed(\"autoComplete\") && !prop(\"multiple\"),\n      autoHighlight: ({\n        computed\n      }) => computed(\"autoHighlight\"),\n      isFirstItemHighlighted: ({\n        prop,\n        context\n      }) => prop(\"collection\").firstValue === context.get(\"highlightedValue\"),\n      isLastItemHighlighted: ({\n        prop,\n        context\n      }) => prop(\"collection\").lastValue === context.get(\"highlightedValue\"),\n      isCustomValue: ({\n        context\n      }) => context.get(\"inputValue\") !== context.get(\"valueAsString\"),\n      allowCustomValue: ({\n        prop\n      }) => !!prop(\"allowCustomValue\"),\n      hasHighlightedItem: ({\n        context\n      }) => context.get(\"highlightedValue\") != null,\n      closeOnSelect: ({\n        prop\n      }) => !!prop(\"closeOnSelect\"),\n      isOpenControlled: ({\n        prop\n      }) => prop(\"open\") != null,\n      openOnChange: ({\n        prop,\n        context\n      }) => {\n        const openOnChange = prop(\"openOnChange\");\n        if (isBoolean(openOnChange)) return openOnChange;\n        return !!openOnChange?.({\n          inputValue: context.get(\"inputValue\")\n        });\n      },\n      restoreFocus: ({\n        event\n      }) => event.restoreFocus == null ? true : !!event.restoreFocus,\n      isChangeEvent: ({\n        event\n      }) => event.previousEvent?.type === \"INPUT.CHANGE\"\n    },\n    effects: {\n      trackDismissableLayer({\n        send,\n        prop,\n        scope\n      }) {\n        if (prop(\"disableLayer\")) return;\n        const contentEl = () => getContentEl(scope);\n        return trackDismissableElement(contentEl, {\n          defer: true,\n          exclude: () => [getInputEl(scope), getTriggerEl(scope), getClearTriggerEl(scope)],\n          onFocusOutside: prop(\"onFocusOutside\"),\n          onPointerDownOutside: prop(\"onPointerDownOutside\"),\n          onInteractOutside: prop(\"onInteractOutside\"),\n          onEscapeKeyDown(event) {\n            event.preventDefault();\n            event.stopPropagation();\n            send({\n              type: \"LAYER.ESCAPE\"\n            });\n          },\n          onDismiss() {\n            send({\n              type: \"LAYER.INTERACT_OUTSIDE\",\n              restoreFocus: false\n            });\n          }\n        });\n      },\n      hideOtherElements({\n        scope\n      }) {\n        return ariaHidden([getInputEl(scope), getContentEl(scope), getTriggerEl(scope), getClearTriggerEl(scope)]);\n      },\n      trackPlacement({\n        context,\n        prop,\n        scope\n      }) {\n        const controlEl = () => getControlEl(scope);\n        const positionerEl = () => getPositionerEl(scope);\n        context.set(\"currentPlacement\", prop(\"positioning\").placement);\n        return getPlacement(controlEl, positionerEl, {\n          ...prop(\"positioning\"),\n          defer: true,\n          onComplete(data) {\n            context.set(\"currentPlacement\", data.placement);\n          }\n        });\n      },\n      // in event the options are fetched (async), we still want to auto-highlight the first option\n      trackChildNodes({\n        scope,\n        computed,\n        send\n      }) {\n        if (!computed(\"autoHighlight\")) return;\n        const exec = () => send({\n          type: \"CHILDREN_CHANGE\"\n        });\n        const contentEl = () => getContentEl(scope);\n        return observeChildren(contentEl, {\n          callback: exec,\n          defer: true\n        });\n      },\n      scrollToHighlightedItem({\n        context,\n        prop,\n        scope,\n        event\n      }) {\n        const inputEl = getInputEl(scope);\n        let cleanups = [];\n        const exec = immediate => {\n          const pointer = event.current().type.includes(\"POINTER\");\n          const highlightedValue = context.get(\"highlightedValue\");\n          if (pointer || !highlightedValue) return;\n          const itemEl = getItemEl(scope, highlightedValue);\n          const contentEl = getContentEl(scope);\n          const scrollToIndexFn = prop(\"scrollToIndexFn\");\n          if (scrollToIndexFn) {\n            const highlightedIndex = prop(\"collection\").indexOf(highlightedValue);\n            scrollToIndexFn({\n              index: highlightedIndex,\n              immediate\n            });\n            return;\n          }\n          const raf_cleanup = raf(() => {\n            scrollIntoView(itemEl, {\n              rootEl: contentEl,\n              block: \"nearest\"\n            });\n          });\n          cleanups.push(raf_cleanup);\n        };\n        const rafCleanup = raf(() => exec(true));\n        cleanups.push(rafCleanup);\n        const observerCleanup = observeAttributes(inputEl, {\n          attributes: [\"aria-activedescendant\"],\n          callback: () => exec(false)\n        });\n        cleanups.push(observerCleanup);\n        return () => {\n          cleanups.forEach(cleanup => cleanup());\n        };\n      }\n    },\n    actions: {\n      reposition({\n        context,\n        prop,\n        scope,\n        event\n      }) {\n        const controlEl = () => getControlEl(scope);\n        const positionerEl = () => getPositionerEl(scope);\n        getPlacement(controlEl, positionerEl, {\n          ...prop(\"positioning\"),\n          ...event.options,\n          defer: true,\n          listeners: false,\n          onComplete(data) {\n            context.set(\"currentPlacement\", data.placement);\n          }\n        });\n      },\n      setHighlightedItem(params) {\n        const {\n          context,\n          event\n        } = params;\n        if (event.value == null) return;\n        context.set(\"highlightedValue\", event.value);\n      },\n      clearHighlightedItem(params) {\n        const {\n          context\n        } = params;\n        context.set(\"highlightedValue\", null);\n      },\n      selectHighlightedItem(params) {\n        const {\n          context,\n          prop\n        } = params;\n        const highlightedValue = context.get(\"highlightedValue\");\n        if (!highlightedValue) return;\n        const nextValue = prop(\"multiple\") ? addOrRemove(context.get(\"value\"), highlightedValue) : [highlightedValue];\n        prop(\"onSelect\")?.({\n          value: nextValue,\n          itemValue: highlightedValue\n        });\n        context.set(\"value\", nextValue);\n        context.set(\"inputValue\", getInputValue(params));\n      },\n      selectItem(params) {\n        const {\n          context,\n          event,\n          flush,\n          prop\n        } = params;\n        if (event.value == null) return;\n        flush(() => {\n          const nextValue = prop(\"multiple\") ? addOrRemove(context.get(\"value\"), event.value) : [event.value];\n          prop(\"onSelect\")?.({\n            value: nextValue,\n            itemValue: event.value\n          });\n          context.set(\"value\", nextValue);\n          context.set(\"inputValue\", getInputValue(params));\n        });\n      },\n      clearItem(params) {\n        const {\n          context,\n          event,\n          flush\n        } = params;\n        if (event.value == null) return;\n        flush(() => {\n          const nextValue = remove(context.get(\"value\"), event.value);\n          context.set(\"value\", nextValue);\n          context.set(\"inputValue\", getInputValue(params));\n        });\n      },\n      setInitialFocus({\n        scope\n      }) {\n        raf(() => {\n          focusInputEl(scope);\n        });\n      },\n      setFinalFocus({\n        scope\n      }) {\n        raf(() => {\n          const triggerEl = getTriggerEl(scope);\n          if (triggerEl?.dataset.focusable == null) {\n            focusInputEl(scope);\n          } else {\n            focusTriggerEl(scope);\n          }\n        });\n      },\n      syncInputValue({\n        context,\n        scope,\n        event\n      }) {\n        const inputEl = getInputEl(scope);\n        if (!inputEl) return;\n        inputEl.value = context.get(\"inputValue\");\n        queueMicrotask(() => {\n          if (event.current().type === \"INPUT.CHANGE\") return;\n          setCaretToEnd(inputEl);\n        });\n      },\n      setInputValue({\n        context,\n        event\n      }) {\n        context.set(\"inputValue\", event.value);\n      },\n      clearInputValue({\n        context\n      }) {\n        context.set(\"inputValue\", \"\");\n      },\n      revertInputValue({\n        context,\n        prop,\n        computed\n      }) {\n        const selectionBehavior = prop(\"selectionBehavior\");\n        const inputValue = match(selectionBehavior, {\n          replace: computed(\"hasSelectedItems\") ? context.get(\"valueAsString\") : \"\",\n          preserve: context.get(\"inputValue\"),\n          clear: \"\"\n        });\n        context.set(\"inputValue\", inputValue);\n      },\n      setValue(params) {\n        const {\n          context,\n          flush,\n          event\n        } = params;\n        flush(() => {\n          context.set(\"value\", event.value);\n          context.set(\"inputValue\", getInputValue(params));\n        });\n      },\n      clearSelectedItems(params) {\n        const {\n          context,\n          flush\n        } = params;\n        flush(() => {\n          context.set(\"value\", []);\n          context.set(\"inputValue\", getInputValue(params));\n        });\n      },\n      scrollContentToTop({\n        prop,\n        scope\n      }) {\n        const scrollToIndexFn = prop(\"scrollToIndexFn\");\n        if (scrollToIndexFn) {\n          scrollToIndexFn({\n            index: 0,\n            immediate: true\n          });\n        } else {\n          const contentEl = getContentEl(scope);\n          if (!contentEl) return;\n          contentEl.scrollTop = 0;\n        }\n      },\n      invokeOnOpen({\n        prop\n      }) {\n        prop(\"onOpenChange\")?.({\n          open: true\n        });\n      },\n      invokeOnClose({\n        prop\n      }) {\n        prop(\"onOpenChange\")?.({\n          open: false\n        });\n      },\n      highlightFirstItem({\n        context,\n        prop,\n        scope\n      }) {\n        const exec = getContentEl(scope) ? queueMicrotask : raf;\n        exec(() => {\n          const value = prop(\"collection\").firstValue;\n          if (value) context.set(\"highlightedValue\", value);\n        });\n      },\n      highlightFirstItemIfNeeded({\n        computed,\n        action\n      }) {\n        if (!computed(\"autoHighlight\")) return;\n        action([\"highlightFirstItem\"]);\n      },\n      highlightLastItem({\n        context,\n        prop,\n        scope\n      }) {\n        const exec = getContentEl(scope) ? queueMicrotask : raf;\n        exec(() => {\n          const value = prop(\"collection\").lastValue;\n          if (value) context.set(\"highlightedValue\", value);\n        });\n      },\n      highlightNextItem({\n        context,\n        prop\n      }) {\n        let value = null;\n        const highlightedValue = context.get(\"highlightedValue\");\n        const collection2 = prop(\"collection\");\n        if (highlightedValue) {\n          value = collection2.getNextValue(highlightedValue);\n          if (!value && prop(\"loopFocus\")) value = collection2.firstValue;\n        } else {\n          value = collection2.firstValue;\n        }\n        if (value) context.set(\"highlightedValue\", value);\n      },\n      highlightPrevItem({\n        context,\n        prop\n      }) {\n        let value = null;\n        const highlightedValue = context.get(\"highlightedValue\");\n        const collection2 = prop(\"collection\");\n        if (highlightedValue) {\n          value = collection2.getPreviousValue(highlightedValue);\n          if (!value && prop(\"loopFocus\")) value = collection2.lastValue;\n        } else {\n          value = collection2.lastValue;\n        }\n        if (value) context.set(\"highlightedValue\", value);\n      },\n      highlightFirstSelectedItem({\n        context,\n        prop\n      }) {\n        raf(() => {\n          const [value] = prop(\"collection\").sort(context.get(\"value\"));\n          if (value) context.set(\"highlightedValue\", value);\n        });\n      },\n      highlightFirstOrSelectedItem({\n        context,\n        prop,\n        computed\n      }) {\n        raf(() => {\n          let value = null;\n          if (computed(\"hasSelectedItems\")) {\n            value = prop(\"collection\").sort(context.get(\"value\"))[0];\n          } else {\n            value = prop(\"collection\").firstValue;\n          }\n          if (value) context.set(\"highlightedValue\", value);\n        });\n      },\n      highlightLastOrSelectedItem({\n        context,\n        prop,\n        computed\n      }) {\n        raf(() => {\n          const collection2 = prop(\"collection\");\n          let value = null;\n          if (computed(\"hasSelectedItems\")) {\n            value = collection2.sort(context.get(\"value\"))[0];\n          } else {\n            value = collection2.lastValue;\n          }\n          if (value) context.set(\"highlightedValue\", value);\n        });\n      },\n      autofillInputValue({\n        context,\n        computed,\n        prop,\n        event,\n        scope\n      }) {\n        const inputEl = getInputEl(scope);\n        const collection2 = prop(\"collection\");\n        if (!computed(\"autoComplete\") || !inputEl || !event.keypress) return;\n        const valueText = collection2.stringify(context.get(\"highlightedValue\"));\n        raf(() => {\n          inputEl.value = valueText || context.get(\"inputValue\");\n        });\n      },\n      syncSelectedItems(params) {\n        const {\n          context,\n          prop\n        } = params;\n        const inputValue = match(prop(\"selectionBehavior\"), {\n          preserve: context.get(\"inputValue\"),\n          replace: prop(\"collection\").stringifyMany(context.get(\"value\")),\n          clear: \"\"\n        });\n        context.set(\"selectedItems\", getSelectedItems(params));\n        context.set(\"inputValue\", inputValue);\n      },\n      syncHighlightedItem({\n        context,\n        prop\n      }) {\n        const item = prop(\"collection\").find(context.get(\"highlightedValue\"));\n        context.set(\"highlightedItem\", item);\n      },\n      toggleVisibility({\n        event,\n        send,\n        prop\n      }) {\n        send({\n          type: prop(\"open\") ? \"CONTROLLED.OPEN\" : \"CONTROLLED.CLOSE\",\n          previousEvent: event\n        });\n      }\n    }\n  }\n});\nfunction getInputValue({\n  context,\n  prop\n}) {\n  return match(prop(\"selectionBehavior\"), {\n    preserve: context.get(\"inputValue\"),\n    replace: context.get(\"valueAsString\"),\n    clear: \"\"\n  });\n}\nfunction getSelectedItems({\n  context,\n  prop\n}) {\n  const collection2 = prop(\"collection\");\n  return context.get(\"value\").map(v => {\n    const foundItem = context.get(\"selectedItems\").find(item => collection2.getItemValue(item) === v);\n    if (foundItem) return foundItem;\n    return collection2.find(v);\n  });\n}\nvar props = createProps()([\"allowCustomValue\", \"autoFocus\", \"closeOnSelect\", \"collection\", \"composite\", \"defaultHighlightedValue\", \"defaultInputValue\", \"defaultOpen\", \"defaultValue\", \"dir\", \"disabled\", \"disableLayer\", \"form\", \"getRootNode\", \"highlightedValue\", \"id\", \"ids\", \"inputBehavior\", \"inputValue\", \"invalid\", \"loopFocus\", \"multiple\", \"name\", \"navigate\", \"onFocusOutside\", \"onHighlightChange\", \"onInputValueChange\", \"onInteractOutside\", \"onOpenChange\", \"onOpenChange\", \"onPointerDownOutside\", \"onSelect\", \"onValueChange\", \"open\", \"openOnChange\", \"openOnClick\", \"openOnKeyPress\", \"placeholder\", \"positioning\", \"readOnly\", \"required\", \"scrollToIndexFn\", \"selectionBehavior\", \"translations\", \"value\"]);\nvar splitProps = createSplitProps(props);\nvar itemGroupLabelProps = createProps()([\"htmlFor\"]);\nvar splitItemGroupLabelProps = createSplitProps(itemGroupLabelProps);\nvar itemGroupProps = createProps()([\"id\"]);\nvar splitItemGroupProps = createSplitProps(itemGroupProps);\nvar itemProps = createProps()([\"item\", \"persistFocus\"]);\nvar splitItemProps = createSplitProps(itemProps);\nexport { anatomy, collection, connect, itemGroupLabelProps, itemGroupProps, itemProps, machine, props, splitItemGroupLabelProps, splitItemGroupProps, splitItemProps, splitProps };","map":null,"metadata":{},"sourceType":"module"}