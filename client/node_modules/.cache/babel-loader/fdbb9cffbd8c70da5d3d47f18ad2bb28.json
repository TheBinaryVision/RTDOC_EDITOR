{"ast":null,"code":"import { createAnatomy } from '@zag-js/anatomy';\nimport { raf, prevById, nextById, queryAll, dataAttr, isSelfTarget, getEventKey, isSafari, getEventTarget } from '@zag-js/dom-query';\nimport { last, first, ensureProps, isArray, addOrRemove, isEqual, createSplitProps } from '@zag-js/utils';\nimport { createGuards, createMachine } from '@zag-js/core';\nimport { createProps } from '@zag-js/types';\n\n// src/toggle-group.anatomy.ts\nvar anatomy = createAnatomy(\"toggle-group\").parts(\"root\", \"item\");\nvar parts = anatomy.build();\nvar getRootId = ctx => ctx.ids?.root ?? `toggle-group:${ctx.id}`;\nvar getItemId = (ctx, value) => ctx.ids?.item?.(value) ?? `toggle-group:${ctx.id}:${value}`;\nvar getRootEl = ctx => ctx.getById(getRootId(ctx));\nvar getElements = ctx => {\n  const ownerId = CSS.escape(getRootId(ctx));\n  const selector = `[data-ownedby='${ownerId}']:not([data-disabled])`;\n  return queryAll(getRootEl(ctx), selector);\n};\nvar getFirstEl = ctx => first(getElements(ctx));\nvar getLastEl = ctx => last(getElements(ctx));\nvar getNextEl = (ctx, id, loopFocus) => nextById(getElements(ctx), id, loopFocus);\nvar getPrevEl = (ctx, id, loopFocus) => prevById(getElements(ctx), id, loopFocus);\n\n// src/toggle-group.connect.ts\nfunction connect(service, normalize) {\n  const {\n    context,\n    send,\n    prop,\n    scope\n  } = service;\n  const value = context.get(\"value\");\n  const disabled = prop(\"disabled\");\n  const isSingle = !prop(\"multiple\");\n  const rovingFocus = prop(\"rovingFocus\");\n  const isHorizontal = prop(\"orientation\") === \"horizontal\";\n  function getItemState(props2) {\n    const id = getItemId(scope, props2.value);\n    return {\n      id,\n      disabled: Boolean(props2.disabled || disabled),\n      pressed: !!value.includes(props2.value),\n      focused: context.get(\"focusedId\") === id\n    };\n  }\n  return {\n    value,\n    setValue(value2) {\n      send({\n        type: \"VALUE.SET\",\n        value: value2\n      });\n    },\n    getRootProps() {\n      return normalize.element({\n        ...parts.root.attrs,\n        id: getRootId(scope),\n        dir: prop(\"dir\"),\n        role: isSingle ? \"radiogroup\" : \"group\",\n        tabIndex: context.get(\"isTabbingBackward\") ? -1 : 0,\n        \"data-disabled\": dataAttr(disabled),\n        \"data-orientation\": prop(\"orientation\"),\n        \"data-focus\": dataAttr(context.get(\"focusedId\") != null),\n        style: {\n          outline: \"none\"\n        },\n        onMouseDown() {\n          if (disabled) return;\n          send({\n            type: \"ROOT.MOUSE_DOWN\"\n          });\n        },\n        onFocus(event) {\n          if (disabled) return;\n          if (event.currentTarget !== getEventTarget(event)) return;\n          if (context.get(\"isClickFocus\")) return;\n          if (context.get(\"isTabbingBackward\")) return;\n          send({\n            type: \"ROOT.FOCUS\"\n          });\n        },\n        onBlur() {\n          if (disabled) return;\n          send({\n            type: \"ROOT.BLUR\"\n          });\n        }\n      });\n    },\n    getItemState,\n    getItemProps(props2) {\n      const itemState = getItemState(props2);\n      const rovingTabIndex = itemState.focused ? 0 : -1;\n      return normalize.button({\n        ...parts.item.attrs,\n        id: itemState.id,\n        type: \"button\",\n        \"data-ownedby\": getRootId(scope),\n        \"data-focus\": dataAttr(itemState.focused),\n        disabled: itemState.disabled,\n        tabIndex: rovingFocus ? rovingTabIndex : void 0,\n        // radio\n        role: isSingle ? \"radio\" : void 0,\n        \"aria-checked\": isSingle ? itemState.pressed : void 0,\n        \"aria-pressed\": isSingle ? void 0 : itemState.pressed,\n        //\n        \"data-disabled\": dataAttr(itemState.disabled),\n        \"data-orientation\": prop(\"orientation\"),\n        dir: prop(\"dir\"),\n        \"data-state\": itemState.pressed ? \"on\" : \"off\",\n        onFocus() {\n          if (itemState.disabled) return;\n          send({\n            type: \"TOGGLE.FOCUS\",\n            id: itemState.id\n          });\n        },\n        onClick(event) {\n          if (itemState.disabled) return;\n          send({\n            type: \"TOGGLE.CLICK\",\n            id: itemState.id,\n            value: props2.value\n          });\n          if (isSafari()) {\n            event.currentTarget.focus({\n              preventScroll: true\n            });\n          }\n        },\n        onKeyDown(event) {\n          if (event.defaultPrevented) return;\n          if (!isSelfTarget(event)) return;\n          if (itemState.disabled) return;\n          const keyMap = {\n            Tab(event2) {\n              const isShiftTab = event2.shiftKey;\n              send({\n                type: \"TOGGLE.SHIFT_TAB\",\n                isShiftTab\n              });\n            },\n            ArrowLeft() {\n              if (!rovingFocus || !isHorizontal) return;\n              send({\n                type: \"TOGGLE.FOCUS_PREV\"\n              });\n            },\n            ArrowRight() {\n              if (!rovingFocus || !isHorizontal) return;\n              send({\n                type: \"TOGGLE.FOCUS_NEXT\"\n              });\n            },\n            ArrowUp() {\n              if (!rovingFocus || isHorizontal) return;\n              send({\n                type: \"TOGGLE.FOCUS_PREV\"\n              });\n            },\n            ArrowDown() {\n              if (!rovingFocus || isHorizontal) return;\n              send({\n                type: \"TOGGLE.FOCUS_NEXT\"\n              });\n            },\n            Home() {\n              if (!rovingFocus) return;\n              send({\n                type: \"TOGGLE.FOCUS_FIRST\"\n              });\n            },\n            End() {\n              if (!rovingFocus) return;\n              send({\n                type: \"TOGGLE.FOCUS_LAST\"\n              });\n            }\n          };\n          const exec = keyMap[getEventKey(event)];\n          if (exec) {\n            exec(event);\n            if (event.key !== \"Tab\") event.preventDefault();\n          }\n        }\n      });\n    }\n  };\n}\nvar {\n  not,\n  and\n} = createGuards();\nvar machine = createMachine({\n  props({\n    props: props2\n  }) {\n    return {\n      defaultValue: [],\n      orientation: \"horizontal\",\n      rovingFocus: true,\n      loopFocus: true,\n      ...props2\n    };\n  },\n  initialState() {\n    return \"idle\";\n  },\n  context({\n    prop,\n    bindable\n  }) {\n    return {\n      value: bindable(() => ({\n        defaultValue: prop(\"defaultValue\"),\n        value: prop(\"value\"),\n        onChange(value) {\n          prop(\"onValueChange\")?.({\n            value\n          });\n        }\n      })),\n      focusedId: bindable(() => ({\n        defaultValue: null\n      })),\n      isTabbingBackward: bindable(() => ({\n        defaultValue: false\n      })),\n      isClickFocus: bindable(() => ({\n        defaultValue: false\n      })),\n      isWithinToolbar: bindable(() => ({\n        defaultValue: false\n      }))\n    };\n  },\n  computed: {\n    currentLoopFocus: ({\n      context,\n      prop\n    }) => prop(\"loopFocus\") && !context.get(\"isWithinToolbar\")\n  },\n  entry: [\"checkIfWithinToolbar\"],\n  on: {\n    \"VALUE.SET\": {\n      actions: [\"setValue\"]\n    },\n    \"TOGGLE.CLICK\": {\n      actions: [\"setValue\"]\n    },\n    \"ROOT.MOUSE_DOWN\": {\n      actions: [\"setClickFocus\"]\n    }\n  },\n  states: {\n    idle: {\n      on: {\n        \"ROOT.FOCUS\": {\n          target: \"focused\",\n          guard: not(and(\"isClickFocus\", \"isTabbingBackward\")),\n          actions: [\"focusFirstToggle\", \"clearClickFocus\"]\n        },\n        \"TOGGLE.FOCUS\": {\n          target: \"focused\",\n          actions: [\"setFocusedId\"]\n        }\n      }\n    },\n    focused: {\n      on: {\n        \"ROOT.BLUR\": {\n          target: \"idle\",\n          actions: [\"clearIsTabbingBackward\", \"clearFocusedId\"]\n        },\n        \"TOGGLE.FOCUS\": {\n          actions: [\"setFocusedId\"]\n        },\n        \"TOGGLE.FOCUS_NEXT\": {\n          actions: [\"focusNextToggle\"]\n        },\n        \"TOGGLE.FOCUS_PREV\": {\n          actions: [\"focusPrevToggle\"]\n        },\n        \"TOGGLE.FOCUS_FIRST\": {\n          actions: [\"focusFirstToggle\"]\n        },\n        \"TOGGLE.FOCUS_LAST\": {\n          actions: [\"focusLastToggle\"]\n        },\n        \"TOGGLE.SHIFT_TAB\": [{\n          guard: not(\"isFirstToggleFocused\"),\n          target: \"idle\",\n          actions: [\"setIsTabbingBackward\"]\n        }, {\n          actions: [\"setIsTabbingBackward\"]\n        }]\n      }\n    }\n  },\n  implementations: {\n    guards: {\n      isClickFocus: ({\n        context\n      }) => context.get(\"isClickFocus\"),\n      isTabbingBackward: ({\n        context\n      }) => context.get(\"isTabbingBackward\"),\n      isFirstToggleFocused: ({\n        context,\n        scope\n      }) => context.get(\"focusedId\") === getFirstEl(scope)?.id\n    },\n    actions: {\n      setIsTabbingBackward({\n        context\n      }) {\n        context.set(\"isTabbingBackward\", true);\n      },\n      clearIsTabbingBackward({\n        context\n      }) {\n        context.set(\"isTabbingBackward\", false);\n      },\n      setClickFocus({\n        context\n      }) {\n        context.set(\"isClickFocus\", true);\n      },\n      clearClickFocus({\n        context\n      }) {\n        context.set(\"isClickFocus\", false);\n      },\n      checkIfWithinToolbar({\n        context,\n        scope\n      }) {\n        const closestToolbar = getRootEl(scope)?.closest(\"[role=toolbar]\");\n        context.set(\"isWithinToolbar\", !!closestToolbar);\n      },\n      setFocusedId({\n        context,\n        event\n      }) {\n        context.set(\"focusedId\", event.id);\n      },\n      clearFocusedId({\n        context\n      }) {\n        context.set(\"focusedId\", null);\n      },\n      setValue({\n        context,\n        event,\n        prop\n      }) {\n        ensureProps(event, [\"value\"]);\n        let next = context.get(\"value\");\n        if (isArray(event.value)) {\n          next = event.value;\n        } else if (prop(\"multiple\")) {\n          next = addOrRemove(next, event.value);\n        } else {\n          next = isEqual(next, [event.value]) ? [] : [event.value];\n        }\n        context.set(\"value\", next);\n      },\n      focusNextToggle({\n        context,\n        scope,\n        prop\n      }) {\n        raf(() => {\n          const focusedId = context.get(\"focusedId\");\n          if (!focusedId) return;\n          getNextEl(scope, focusedId, prop(\"loopFocus\"))?.focus({\n            preventScroll: true\n          });\n        });\n      },\n      focusPrevToggle({\n        context,\n        scope,\n        prop\n      }) {\n        raf(() => {\n          const focusedId = context.get(\"focusedId\");\n          if (!focusedId) return;\n          getPrevEl(scope, focusedId, prop(\"loopFocus\"))?.focus({\n            preventScroll: true\n          });\n        });\n      },\n      focusFirstToggle({\n        scope\n      }) {\n        raf(() => {\n          getFirstEl(scope)?.focus({\n            preventScroll: true\n          });\n        });\n      },\n      focusLastToggle({\n        scope\n      }) {\n        raf(() => {\n          getLastEl(scope)?.focus({\n            preventScroll: true\n          });\n        });\n      }\n    }\n  }\n});\nvar props = createProps()([\"dir\", \"disabled\", \"getRootNode\", \"id\", \"ids\", \"loopFocus\", \"multiple\", \"onValueChange\", \"orientation\", \"rovingFocus\", \"value\", \"defaultValue\"]);\nvar splitProps = createSplitProps(props);\nvar itemProps = createProps()([\"value\", \"disabled\"]);\nvar splitItemProps = createSplitProps(itemProps);\nexport { anatomy, connect, itemProps, machine, props, splitItemProps, splitProps };","map":null,"metadata":{},"sourceType":"module"}