{"ast":null,"code":"import { createAnatomy } from '@zag-js/anatomy';\nimport { DateFormatter, isEqualDay, CalendarDate, parseDate, isWeekend, isToday } from '@internationalized/date';\nimport { getEndDate, isDateOutsideRange, alignDate, getDecadeRange, getTodayDate, getPreviousSection, getNextSection, getPreviousPage, getNextPage, isDateEqual, constrainValue, formatSelectedDate, isNextRangeInvalid, isPreviousRangeInvalid, parseDateString, getAdjustedDateFn, getWeekDays, getDateRangePreset, getMonthFormatter, getDaysInWeek, getMonthDays, getMonthNames, getYearsRange, isDateUnavailable, getDayFormatter, getUnitDuration } from '@zag-js/date-utils';\nimport { queryAll, setElementValue, raf, query, restoreTextSelection, disableTextSelection, getNativeEvent, dataAttr, ariaAttr, getEventKey, isComposingEvent } from '@zag-js/dom-query';\nimport { getPlacement, getPlacementStyles } from '@zag-js/popper';\nimport { createSplitProps, clampValue, chunk, isValueWithinRange, match } from '@zag-js/utils';\nimport { createGuards, createMachine } from '@zag-js/core';\nimport { trackDismissableElement } from '@zag-js/dismissable';\nimport { createLiveRegion } from '@zag-js/live-region';\nimport { createProps } from '@zag-js/types';\n\n// src/date-picker.anatomy.ts\nvar anatomy = createAnatomy(\"date-picker\").parts(\"clearTrigger\", \"content\", \"control\", \"input\", \"label\", \"monthSelect\", \"nextTrigger\", \"positioner\", \"presetTrigger\", \"prevTrigger\", \"rangeText\", \"root\", \"table\", \"tableBody\", \"tableCell\", \"tableCellTrigger\", \"tableHead\", \"tableHeader\", \"tableRow\", \"trigger\", \"view\", \"viewControl\", \"viewTrigger\", \"yearSelect\");\nvar parts = anatomy.build();\nvar getLabelId = (ctx, index) => ctx.ids?.label?.(index) ?? `datepicker:${ctx.id}:label:${index}`;\nvar getRootId = ctx => ctx.ids?.root ?? `datepicker:${ctx.id}`;\nvar getTableId = (ctx, id) => ctx.ids?.table?.(id) ?? `datepicker:${ctx.id}:table:${id}`;\nvar getContentId = ctx => ctx.ids?.content ?? `datepicker:${ctx.id}:content`;\nvar getCellTriggerId = (ctx, id) => ctx.ids?.cellTrigger?.(id) ?? `datepicker:${ctx.id}:cell-trigger:${id}`;\nvar getPrevTriggerId = (ctx, view) => ctx.ids?.prevTrigger?.(view) ?? `datepicker:${ctx.id}:prev:${view}`;\nvar getNextTriggerId = (ctx, view) => ctx.ids?.nextTrigger?.(view) ?? `datepicker:${ctx.id}:next:${view}`;\nvar getViewTriggerId = (ctx, view) => ctx.ids?.viewTrigger?.(view) ?? `datepicker:${ctx.id}:view:${view}`;\nvar getClearTriggerId = ctx => ctx.ids?.clearTrigger ?? `datepicker:${ctx.id}:clear`;\nvar getControlId = ctx => ctx.ids?.control ?? `datepicker:${ctx.id}:control`;\nvar getInputId = (ctx, index) => ctx.ids?.input?.(index) ?? `datepicker:${ctx.id}:input:${index}`;\nvar getTriggerId = ctx => ctx.ids?.trigger ?? `datepicker:${ctx.id}:trigger`;\nvar getPositionerId = ctx => ctx.ids?.positioner ?? `datepicker:${ctx.id}:positioner`;\nvar getMonthSelectId = ctx => ctx.ids?.monthSelect ?? `datepicker:${ctx.id}:month-select`;\nvar getYearSelectId = ctx => ctx.ids?.yearSelect ?? `datepicker:${ctx.id}:year-select`;\nvar getFocusedCell = (ctx, view) => query(getContentEl(ctx), `[data-part=table-cell-trigger][data-view=${view}][data-focus]:not([data-outside-range])`);\nvar getTriggerEl = ctx => ctx.getById(getTriggerId(ctx));\nvar getContentEl = ctx => ctx.getById(getContentId(ctx));\nvar getInputEls = ctx => queryAll(getControlEl(ctx), `[data-part=input]`);\nvar getYearSelectEl = ctx => ctx.getById(getYearSelectId(ctx));\nvar getMonthSelectEl = ctx => ctx.getById(getMonthSelectId(ctx));\nvar getClearTriggerEl = ctx => ctx.getById(getClearTriggerId(ctx));\nvar getPositionerEl = ctx => ctx.getById(getPositionerId(ctx));\nvar getControlEl = ctx => ctx.getById(getControlId(ctx));\nfunction adjustStartAndEndDate(value) {\n  const [startDate, endDate] = value;\n  if (!startDate || !endDate) return value;\n  return startDate.compare(endDate) <= 0 ? value : [endDate, startDate];\n}\nfunction isDateWithinRange(date, value) {\n  const [startDate, endDate] = value;\n  if (!startDate || !endDate) return false;\n  return startDate.compare(date) <= 0 && endDate.compare(date) >= 0;\n}\nfunction sortDates(values) {\n  return values.slice().sort((a, b) => a.compare(b));\n}\nfunction getRoleDescription(view) {\n  return match(view, {\n    year: \"calendar decade\",\n    month: \"calendar year\",\n    day: \"calendar month\"\n  });\n}\nvar PLACEHOLDERS = {\n  day: \"dd\",\n  month: \"mm\",\n  year: \"yyyy\"\n};\nfunction getInputPlaceholder(locale) {\n  return new DateFormatter(locale).formatToParts(/* @__PURE__ */new Date()).map(item => PLACEHOLDERS[item.type] ?? item.value).join(\"\");\n}\nvar isValidCharacter = (char, separator) => {\n  if (!char) return true;\n  return /\\d/.test(char) || char === separator || char.length !== 1;\n};\nvar isValidDate = value => {\n  return !Number.isNaN(value.day) && !Number.isNaN(value.month) && !Number.isNaN(value.year);\n};\nvar ensureValidCharacters = (value, separator) => {\n  return value.split(\"\").filter(char => isValidCharacter(char, separator)).join(\"\");\n};\nfunction getLocaleSeparator(locale) {\n  const dateFormatter = new Intl.DateTimeFormat(locale);\n  const parts2 = dateFormatter.formatToParts(/* @__PURE__ */new Date());\n  const literalPart = parts2.find(part => part.type === \"literal\");\n  return literalPart ? literalPart.value : \"/\";\n}\nvar defaultTranslations = {\n  dayCell(state) {\n    if (state.unavailable) return `Not available. ${state.formattedDate}`;\n    if (state.selected) return `Selected date. ${state.formattedDate}`;\n    return `Choose ${state.formattedDate}`;\n  },\n  trigger(open) {\n    return open ? \"Close calendar\" : \"Open calendar\";\n  },\n  viewTrigger(view) {\n    return match(view, {\n      year: \"Switch to month view\",\n      month: \"Switch to day view\",\n      day: \"Switch to year view\"\n    });\n  },\n  presetTrigger(value) {\n    return Array.isArray(value) ? `select ${value[0].toString()} to ${value[1].toString()}` : `select ${value}`;\n  },\n  prevTrigger(view) {\n    return match(view, {\n      year: \"Switch to previous decade\",\n      month: \"Switch to previous year\",\n      day: \"Switch to previous month\"\n    });\n  },\n  nextTrigger(view) {\n    return match(view, {\n      year: \"Switch to next decade\",\n      month: \"Switch to next year\",\n      day: \"Switch to next month\"\n    });\n  },\n  // TODO: Revisit this\n  placeholder() {\n    return {\n      day: \"dd\",\n      month: \"mm\",\n      year: \"yyyy\"\n    };\n  },\n  content: \"calendar\",\n  monthSelect: \"Select month\",\n  yearSelect: \"Select year\",\n  clearTrigger: \"Clear selected dates\"\n};\nfunction viewToNumber(view, fallback) {\n  if (!view) return fallback || 0;\n  return view === \"day\" ? 0 : view === \"month\" ? 1 : 2;\n}\nfunction viewNumberToView(viewNumber) {\n  return viewNumber === 0 ? \"day\" : viewNumber === 1 ? \"month\" : \"year\";\n}\nfunction clampView(view, minView, maxView) {\n  return viewNumberToView(clampValue(viewToNumber(view, 0), viewToNumber(minView, 0), viewToNumber(maxView, 2)));\n}\nfunction isAboveMinView(view, minView) {\n  return viewToNumber(view, 0) > viewToNumber(minView, 0);\n}\nfunction isBelowMinView(view, minView) {\n  return viewToNumber(view, 0) < viewToNumber(minView, 0);\n}\nfunction getNextView(view, minView, maxView) {\n  const nextViewNumber = viewToNumber(view, 0) + 1;\n  return clampView(viewNumberToView(nextViewNumber), minView, maxView);\n}\nfunction getPreviousView(view, minView, maxView) {\n  const prevViewNumber = viewToNumber(view, 0) - 1;\n  return clampView(viewNumberToView(prevViewNumber), minView, maxView);\n}\nvar views = [\"day\", \"month\", \"year\"];\nfunction eachView(cb) {\n  views.forEach(view => cb(view));\n}\n\n// src/date-picker.connect.ts\nfunction connect(service, normalize) {\n  const {\n    state,\n    context,\n    prop,\n    send,\n    computed,\n    scope\n  } = service;\n  const startValue = context.get(\"startValue\");\n  const endValue = computed(\"endValue\");\n  const selectedValue = context.get(\"value\");\n  const focusedValue = context.get(\"focusedValue\");\n  const hoveredValue = context.get(\"hoveredValue\");\n  const hoveredRangeValue = hoveredValue ? adjustStartAndEndDate([selectedValue[0], hoveredValue]) : [];\n  const disabled = prop(\"disabled\");\n  const readOnly = prop(\"readOnly\");\n  const interactive = computed(\"isInteractive\");\n  const min = prop(\"min\");\n  const max = prop(\"max\");\n  const locale = prop(\"locale\");\n  const timeZone = prop(\"timeZone\");\n  const startOfWeek = prop(\"startOfWeek\");\n  const focused = state.matches(\"focused\");\n  const open = state.matches(\"open\");\n  const isRangePicker = prop(\"selectionMode\") === \"range\";\n  const isDateUnavailableFn = prop(\"isDateUnavailable\");\n  const currentPlacement = context.get(\"currentPlacement\");\n  const popperStyles = getPlacementStyles({\n    ...prop(\"positioning\"),\n    placement: currentPlacement\n  });\n  const separator = getLocaleSeparator(locale);\n  const translations = {\n    ...defaultTranslations,\n    ...prop(\"translations\")\n  };\n  function getMonthWeeks(from = startValue) {\n    const numOfWeeks = prop(\"fixedWeeks\") ? 6 : void 0;\n    return getMonthDays(from, locale, numOfWeeks, startOfWeek);\n  }\n  function getMonths(props2 = {}) {\n    const {\n      format\n    } = props2;\n    return getMonthNames(locale, format).map((label, index) => ({\n      label,\n      value: index + 1\n    }));\n  }\n  function getYears() {\n    const range = getYearsRange({\n      from: min?.year ?? 1900,\n      to: max?.year ?? 2100\n    });\n    return range.map(year => ({\n      label: year.toString(),\n      value: year\n    }));\n  }\n  function getDecadeYears(year) {\n    const range = getDecadeRange(focusedValue.year);\n    return range.map(year2 => ({\n      label: year2.toString(),\n      value: year2\n    }));\n  }\n  function isUnavailable(date) {\n    return isDateUnavailable(date, isDateUnavailableFn, locale, min, max);\n  }\n  function focusMonth(month) {\n    const date = startValue ?? getTodayDate(timeZone);\n    send({\n      type: \"FOCUS.SET\",\n      value: date.set({\n        month\n      })\n    });\n  }\n  function focusYear(year) {\n    const date = startValue ?? getTodayDate(timeZone);\n    send({\n      type: \"FOCUS.SET\",\n      value: date.set({\n        year\n      })\n    });\n  }\n  function getYearTableCellState(props2) {\n    const {\n      value,\n      disabled: disabled2\n    } = props2;\n    const cellState = {\n      focused: focusedValue.year === props2.value,\n      selectable: isValueWithinRange(value, min?.year ?? 0, max?.year ?? 9999),\n      selected: !!selectedValue.find(date => date.year === value),\n      valueText: value.toString(),\n      get disabled() {\n        return disabled2 || !cellState.selectable;\n      }\n    };\n    return cellState;\n  }\n  function getMonthTableCellState(props2) {\n    const {\n      value,\n      disabled: disabled2\n    } = props2;\n    const normalized = focusedValue.set({\n      month: value\n    });\n    const formatter = getMonthFormatter(locale, timeZone);\n    const cellState = {\n      focused: focusedValue.month === props2.value,\n      selectable: !isDateOutsideRange(normalized, min, max),\n      selected: !!selectedValue.find(date => date.month === value && date.year === focusedValue.year),\n      valueText: formatter.format(normalized.toDate(timeZone)),\n      get disabled() {\n        return disabled2 || !cellState.selectable;\n      }\n    };\n    return cellState;\n  }\n  function getDayTableCellState(props2) {\n    const {\n      value,\n      disabled: disabled2,\n      visibleRange = computed(\"visibleRange\")\n    } = props2;\n    const formatter = getDayFormatter(locale, timeZone);\n    const unitDuration = getUnitDuration(computed(\"visibleDuration\"));\n    const end = visibleRange.start.add(unitDuration).subtract({\n      days: 1\n    });\n    const cellState = {\n      invalid: isDateOutsideRange(value, min, max),\n      disabled: disabled2 || isDateOutsideRange(value, visibleRange.start, end) || isDateOutsideRange(value, min, max),\n      selected: selectedValue.some(date => isDateEqual(value, date)),\n      unavailable: isDateUnavailable(value, isDateUnavailableFn, locale, min, max) && !disabled2,\n      outsideRange: isDateOutsideRange(value, visibleRange.start, end),\n      inRange: isRangePicker && (isDateWithinRange(value, selectedValue) || isDateWithinRange(value, hoveredRangeValue)),\n      firstInRange: isRangePicker && isDateEqual(value, selectedValue[0]),\n      lastInRange: isRangePicker && isDateEqual(value, selectedValue[1]),\n      today: isToday(value, timeZone),\n      weekend: isWeekend(value, locale),\n      formattedDate: formatter.format(value.toDate(timeZone)),\n      get focused() {\n        return isDateEqual(value, focusedValue) && !cellState.outsideRange;\n      },\n      get ariaLabel() {\n        return translations.dayCell(cellState);\n      },\n      get selectable() {\n        return !cellState.disabled && !cellState.unavailable;\n      }\n    };\n    return cellState;\n  }\n  function getTableId2(props2) {\n    const {\n      view = \"day\",\n      id\n    } = props2;\n    return [view, id].filter(Boolean).join(\" \");\n  }\n  return {\n    focused,\n    open,\n    view: context.get(\"view\"),\n    getRangePresetValue(preset) {\n      return getDateRangePreset(preset, locale, timeZone);\n    },\n    getDaysInWeek(week, from = startValue) {\n      return getDaysInWeek(week, from, locale, startOfWeek);\n    },\n    getOffset(duration) {\n      const from = startValue.add(duration);\n      const end = endValue.add(duration);\n      const formatter = getMonthFormatter(locale, timeZone);\n      return {\n        visibleRange: {\n          start: from,\n          end\n        },\n        weeks: getMonthWeeks(from),\n        visibleRangeText: {\n          start: formatter.format(from.toDate(timeZone)),\n          end: formatter.format(end.toDate(timeZone))\n        }\n      };\n    },\n    getMonthWeeks,\n    isUnavailable,\n    weeks: getMonthWeeks(),\n    weekDays: getWeekDays(getTodayDate(timeZone), startOfWeek, timeZone, locale),\n    visibleRangeText: computed(\"visibleRangeText\"),\n    value: selectedValue,\n    valueAsDate: selectedValue.map(date => date.toDate(timeZone)),\n    valueAsString: computed(\"valueAsString\"),\n    focusedValue,\n    focusedValueAsDate: focusedValue?.toDate(timeZone),\n    focusedValueAsString: prop(\"format\")(focusedValue, {\n      locale,\n      timeZone\n    }),\n    visibleRange: computed(\"visibleRange\"),\n    selectToday() {\n      const value = constrainValue(getTodayDate(timeZone), min, max);\n      send({\n        type: \"VALUE.SET\",\n        value\n      });\n    },\n    setValue(values) {\n      const computedValue = values.map(date => constrainValue(date, min, max));\n      send({\n        type: \"VALUE.SET\",\n        value: computedValue\n      });\n    },\n    clearValue() {\n      send({\n        type: \"VALUE.CLEAR\"\n      });\n    },\n    setFocusedValue(value) {\n      send({\n        type: \"FOCUS.SET\",\n        value\n      });\n    },\n    setOpen(nextOpen) {\n      const open2 = state.matches(\"open\");\n      if (open2 === nextOpen) return;\n      send({\n        type: nextOpen ? \"OPEN\" : \"CLOSE\"\n      });\n    },\n    focusMonth,\n    focusYear,\n    getYears,\n    getMonths,\n    getYearsGrid(props2 = {}) {\n      const {\n        columns = 1\n      } = props2;\n      return chunk(getDecadeYears(), columns);\n    },\n    getDecade() {\n      const years = getDecadeRange(focusedValue.year);\n      return {\n        start: years.at(0),\n        end: years.at(-1)\n      };\n    },\n    getMonthsGrid(props2 = {}) {\n      const {\n        columns = 1,\n        format\n      } = props2;\n      return chunk(getMonths({\n        format\n      }), columns);\n    },\n    format(value, opts = {\n      month: \"long\",\n      year: \"numeric\"\n    }) {\n      return new DateFormatter(locale, opts).format(value.toDate(timeZone));\n    },\n    setView(view) {\n      send({\n        type: \"VIEW.SET\",\n        view\n      });\n    },\n    goToNext() {\n      send({\n        type: \"GOTO.NEXT\",\n        view: context.get(\"view\")\n      });\n    },\n    goToPrev() {\n      send({\n        type: \"GOTO.PREV\",\n        view: context.get(\"view\")\n      });\n    },\n    getRootProps() {\n      return normalize.element({\n        ...parts.root.attrs,\n        dir: prop(\"dir\"),\n        id: getRootId(scope),\n        \"data-state\": open ? \"open\" : \"closed\",\n        \"data-disabled\": dataAttr(disabled),\n        \"data-readonly\": dataAttr(readOnly)\n      });\n    },\n    getLabelProps(props2 = {}) {\n      const {\n        index = 0\n      } = props2;\n      return normalize.label({\n        ...parts.label.attrs,\n        id: getLabelId(scope, index),\n        dir: prop(\"dir\"),\n        htmlFor: getInputId(scope, index),\n        \"data-state\": open ? \"open\" : \"closed\",\n        \"data-index\": index,\n        \"data-disabled\": dataAttr(disabled),\n        \"data-readonly\": dataAttr(readOnly)\n      });\n    },\n    getControlProps() {\n      return normalize.element({\n        ...parts.control.attrs,\n        dir: prop(\"dir\"),\n        id: getControlId(scope),\n        \"data-disabled\": dataAttr(disabled)\n      });\n    },\n    getRangeTextProps() {\n      return normalize.element({\n        ...parts.rangeText.attrs,\n        dir: prop(\"dir\")\n      });\n    },\n    getContentProps() {\n      return normalize.element({\n        ...parts.content.attrs,\n        hidden: !open,\n        dir: prop(\"dir\"),\n        \"data-state\": open ? \"open\" : \"closed\",\n        \"data-placement\": currentPlacement,\n        id: getContentId(scope),\n        tabIndex: -1,\n        role: \"application\",\n        \"aria-roledescription\": \"datepicker\",\n        \"aria-label\": translations.content\n      });\n    },\n    getTableProps(props2 = {}) {\n      const {\n        view = \"day\",\n        columns = view === \"day\" ? 7 : 4\n      } = props2;\n      const uid = getTableId2(props2);\n      return normalize.element({\n        ...parts.table.attrs,\n        role: \"grid\",\n        \"data-columns\": columns,\n        \"aria-roledescription\": getRoleDescription(view),\n        id: getTableId(scope, uid),\n        \"aria-readonly\": ariaAttr(readOnly),\n        \"aria-disabled\": ariaAttr(disabled),\n        \"aria-multiselectable\": ariaAttr(prop(\"selectionMode\") !== \"single\"),\n        \"data-view\": view,\n        dir: prop(\"dir\"),\n        tabIndex: -1,\n        onKeyDown(event) {\n          if (event.defaultPrevented) return;\n          const keyMap = {\n            Enter() {\n              if (isUnavailable(focusedValue)) return;\n              send({\n                type: \"TABLE.ENTER\",\n                view,\n                columns,\n                focus: true\n              });\n            },\n            ArrowLeft() {\n              send({\n                type: \"TABLE.ARROW_LEFT\",\n                view,\n                columns,\n                focus: true\n              });\n            },\n            ArrowRight() {\n              send({\n                type: \"TABLE.ARROW_RIGHT\",\n                view,\n                columns,\n                focus: true\n              });\n            },\n            ArrowUp() {\n              send({\n                type: \"TABLE.ARROW_UP\",\n                view,\n                columns,\n                focus: true\n              });\n            },\n            ArrowDown() {\n              send({\n                type: \"TABLE.ARROW_DOWN\",\n                view,\n                columns,\n                focus: true\n              });\n            },\n            PageUp(event2) {\n              send({\n                type: \"TABLE.PAGE_UP\",\n                larger: event2.shiftKey,\n                view,\n                columns,\n                focus: true\n              });\n            },\n            PageDown(event2) {\n              send({\n                type: \"TABLE.PAGE_DOWN\",\n                larger: event2.shiftKey,\n                view,\n                columns,\n                focus: true\n              });\n            },\n            Home() {\n              send({\n                type: \"TABLE.HOME\",\n                view,\n                columns,\n                focus: true\n              });\n            },\n            End() {\n              send({\n                type: \"TABLE.END\",\n                view,\n                columns,\n                focus: true\n              });\n            }\n          };\n          const exec = keyMap[getEventKey(event, {\n            dir: prop(\"dir\")\n          })];\n          if (exec) {\n            exec(event);\n            event.preventDefault();\n            event.stopPropagation();\n          }\n        },\n        onPointerLeave() {\n          send({\n            type: \"TABLE.POINTER_LEAVE\"\n          });\n        },\n        onPointerDown() {\n          send({\n            type: \"TABLE.POINTER_DOWN\",\n            view\n          });\n        },\n        onPointerUp() {\n          send({\n            type: \"TABLE.POINTER_UP\",\n            view\n          });\n        }\n      });\n    },\n    getTableHeadProps(props2 = {}) {\n      const {\n        view = \"day\"\n      } = props2;\n      return normalize.element({\n        ...parts.tableHead.attrs,\n        \"aria-hidden\": true,\n        dir: prop(\"dir\"),\n        \"data-view\": view,\n        \"data-disabled\": dataAttr(disabled)\n      });\n    },\n    getTableHeaderProps(props2 = {}) {\n      const {\n        view = \"day\"\n      } = props2;\n      return normalize.element({\n        ...parts.tableHeader.attrs,\n        dir: prop(\"dir\"),\n        \"data-view\": view,\n        \"data-disabled\": dataAttr(disabled)\n      });\n    },\n    getTableBodyProps(props2 = {}) {\n      const {\n        view = \"day\"\n      } = props2;\n      return normalize.element({\n        ...parts.tableBody.attrs,\n        \"data-view\": view,\n        \"data-disabled\": dataAttr(disabled)\n      });\n    },\n    getTableRowProps(props2 = {}) {\n      const {\n        view = \"day\"\n      } = props2;\n      return normalize.element({\n        ...parts.tableRow.attrs,\n        \"aria-disabled\": ariaAttr(disabled),\n        \"data-disabled\": dataAttr(disabled),\n        \"data-view\": view\n      });\n    },\n    getDayTableCellState,\n    getDayTableCellProps(props2) {\n      const {\n        value\n      } = props2;\n      const cellState = getDayTableCellState(props2);\n      return normalize.element({\n        ...parts.tableCell.attrs,\n        role: \"gridcell\",\n        \"aria-disabled\": ariaAttr(!cellState.selectable),\n        \"aria-selected\": cellState.selected || cellState.inRange,\n        \"aria-invalid\": ariaAttr(cellState.invalid),\n        \"aria-current\": cellState.today ? \"date\" : void 0,\n        \"data-value\": value.toString()\n      });\n    },\n    getDayTableCellTriggerProps(props2) {\n      const {\n        value\n      } = props2;\n      const cellState = getDayTableCellState(props2);\n      return normalize.element({\n        ...parts.tableCellTrigger.attrs,\n        id: getCellTriggerId(scope, value.toString()),\n        role: \"button\",\n        dir: prop(\"dir\"),\n        tabIndex: cellState.focused ? 0 : -1,\n        \"aria-label\": cellState.ariaLabel,\n        \"aria-disabled\": ariaAttr(!cellState.selectable),\n        \"aria-invalid\": ariaAttr(cellState.invalid),\n        \"data-disabled\": dataAttr(!cellState.selectable),\n        \"data-selected\": dataAttr(cellState.selected),\n        \"data-value\": value.toString(),\n        \"data-view\": \"day\",\n        \"data-today\": dataAttr(cellState.today),\n        \"data-focus\": dataAttr(cellState.focused),\n        \"data-unavailable\": dataAttr(cellState.unavailable),\n        \"data-range-start\": dataAttr(cellState.firstInRange),\n        \"data-range-end\": dataAttr(cellState.lastInRange),\n        \"data-in-range\": dataAttr(cellState.inRange),\n        \"data-outside-range\": dataAttr(cellState.outsideRange),\n        \"data-weekend\": dataAttr(cellState.weekend),\n        onClick(event) {\n          if (event.defaultPrevented) return;\n          if (!cellState.selectable) return;\n          send({\n            type: \"CELL.CLICK\",\n            cell: \"day\",\n            value\n          });\n        },\n        onPointerMove(event) {\n          if (event.pointerType === \"touch\" || !cellState.selectable) return;\n          const focus = event.currentTarget.ownerDocument.activeElement !== event.currentTarget;\n          if (hoveredValue && isEqualDay(value, hoveredValue)) return;\n          send({\n            type: \"CELL.POINTER_MOVE\",\n            cell: \"day\",\n            value,\n            focus\n          });\n        }\n      });\n    },\n    getMonthTableCellState,\n    getMonthTableCellProps(props2) {\n      const {\n        value,\n        columns\n      } = props2;\n      const cellState = getMonthTableCellState(props2);\n      return normalize.element({\n        ...parts.tableCell.attrs,\n        dir: prop(\"dir\"),\n        colSpan: columns,\n        role: \"gridcell\",\n        \"aria-selected\": ariaAttr(cellState.selected),\n        \"data-selected\": dataAttr(cellState.selected),\n        \"aria-disabled\": ariaAttr(!cellState.selectable),\n        \"data-value\": value\n      });\n    },\n    getMonthTableCellTriggerProps(props2) {\n      const {\n        value\n      } = props2;\n      const cellState = getMonthTableCellState(props2);\n      return normalize.element({\n        ...parts.tableCellTrigger.attrs,\n        dir: prop(\"dir\"),\n        role: \"button\",\n        id: getCellTriggerId(scope, value.toString()),\n        \"data-selected\": dataAttr(cellState.selected),\n        \"aria-disabled\": ariaAttr(!cellState.selectable),\n        \"data-disabled\": dataAttr(!cellState.selectable),\n        \"data-focus\": dataAttr(cellState.focused),\n        \"aria-label\": cellState.valueText,\n        \"data-view\": \"month\",\n        \"data-value\": value,\n        tabIndex: cellState.focused ? 0 : -1,\n        onClick(event) {\n          if (event.defaultPrevented) return;\n          if (!cellState.selectable) return;\n          send({\n            type: \"CELL.CLICK\",\n            cell: \"month\",\n            value\n          });\n        }\n      });\n    },\n    getYearTableCellState,\n    getYearTableCellProps(props2) {\n      const {\n        value,\n        columns\n      } = props2;\n      const cellState = getYearTableCellState(props2);\n      return normalize.element({\n        ...parts.tableCell.attrs,\n        dir: prop(\"dir\"),\n        colSpan: columns,\n        role: \"gridcell\",\n        \"aria-selected\": ariaAttr(cellState.selected),\n        \"data-selected\": dataAttr(cellState.selected),\n        \"aria-disabled\": ariaAttr(!cellState.selectable),\n        \"data-value\": value\n      });\n    },\n    getYearTableCellTriggerProps(props2) {\n      const {\n        value\n      } = props2;\n      const cellState = getYearTableCellState(props2);\n      return normalize.element({\n        ...parts.tableCellTrigger.attrs,\n        dir: prop(\"dir\"),\n        role: \"button\",\n        id: getCellTriggerId(scope, value.toString()),\n        \"data-selected\": dataAttr(cellState.selected),\n        \"data-focus\": dataAttr(cellState.focused),\n        \"aria-disabled\": ariaAttr(!cellState.selectable),\n        \"data-disabled\": dataAttr(!cellState.selectable),\n        \"aria-label\": cellState.valueText,\n        \"data-value\": value,\n        \"data-view\": \"year\",\n        tabIndex: cellState.focused ? 0 : -1,\n        onClick(event) {\n          if (event.defaultPrevented) return;\n          if (!cellState.selectable) return;\n          send({\n            type: \"CELL.CLICK\",\n            cell: \"year\",\n            value\n          });\n        }\n      });\n    },\n    getNextTriggerProps(props2 = {}) {\n      const {\n        view = \"day\"\n      } = props2;\n      const isDisabled = disabled || !computed(\"isNextVisibleRangeValid\");\n      return normalize.button({\n        ...parts.nextTrigger.attrs,\n        dir: prop(\"dir\"),\n        id: getNextTriggerId(scope, view),\n        type: \"button\",\n        \"aria-label\": translations.nextTrigger(view),\n        disabled: isDisabled,\n        \"data-disabled\": dataAttr(isDisabled),\n        onClick(event) {\n          if (event.defaultPrevented) return;\n          send({\n            type: \"GOTO.NEXT\",\n            view\n          });\n        }\n      });\n    },\n    getPrevTriggerProps(props2 = {}) {\n      const {\n        view = \"day\"\n      } = props2;\n      const isDisabled = disabled || !computed(\"isPrevVisibleRangeValid\");\n      return normalize.button({\n        ...parts.prevTrigger.attrs,\n        dir: prop(\"dir\"),\n        id: getPrevTriggerId(scope, view),\n        type: \"button\",\n        \"aria-label\": translations.prevTrigger(view),\n        disabled: isDisabled,\n        \"data-disabled\": dataAttr(isDisabled),\n        onClick(event) {\n          if (event.defaultPrevented) return;\n          send({\n            type: \"GOTO.PREV\",\n            view\n          });\n        }\n      });\n    },\n    getClearTriggerProps() {\n      return normalize.button({\n        ...parts.clearTrigger.attrs,\n        id: getClearTriggerId(scope),\n        dir: prop(\"dir\"),\n        type: \"button\",\n        \"aria-label\": translations.clearTrigger,\n        hidden: !selectedValue.length,\n        onClick(event) {\n          if (event.defaultPrevented) return;\n          send({\n            type: \"VALUE.CLEAR\"\n          });\n        }\n      });\n    },\n    getTriggerProps() {\n      return normalize.button({\n        ...parts.trigger.attrs,\n        id: getTriggerId(scope),\n        dir: prop(\"dir\"),\n        type: \"button\",\n        \"data-placement\": currentPlacement,\n        \"aria-label\": translations.trigger(open),\n        \"aria-controls\": getContentId(scope),\n        \"data-state\": open ? \"open\" : \"closed\",\n        \"aria-haspopup\": \"grid\",\n        disabled,\n        onClick(event) {\n          if (event.defaultPrevented) return;\n          if (!interactive) return;\n          send({\n            type: \"TRIGGER.CLICK\"\n          });\n        }\n      });\n    },\n    getViewProps(props2 = {}) {\n      const {\n        view = \"day\"\n      } = props2;\n      return normalize.element({\n        ...parts.view.attrs,\n        \"data-view\": view,\n        hidden: context.get(\"view\") !== view\n      });\n    },\n    getViewTriggerProps(props2 = {}) {\n      const {\n        view = \"day\"\n      } = props2;\n      return normalize.button({\n        ...parts.viewTrigger.attrs,\n        \"data-view\": view,\n        dir: prop(\"dir\"),\n        id: getViewTriggerId(scope, view),\n        type: \"button\",\n        disabled,\n        \"aria-label\": translations.viewTrigger(view),\n        onClick(event) {\n          if (event.defaultPrevented) return;\n          if (!interactive) return;\n          send({\n            type: \"VIEW.TOGGLE\",\n            src: \"viewTrigger\"\n          });\n        }\n      });\n    },\n    getViewControlProps(props2 = {}) {\n      const {\n        view = \"day\"\n      } = props2;\n      return normalize.element({\n        ...parts.viewControl.attrs,\n        \"data-view\": view,\n        dir: prop(\"dir\")\n      });\n    },\n    getInputProps(props2 = {}) {\n      const {\n        index = 0,\n        fixOnBlur = true\n      } = props2;\n      return normalize.input({\n        ...parts.input.attrs,\n        id: getInputId(scope, index),\n        autoComplete: \"off\",\n        autoCorrect: \"off\",\n        spellCheck: \"false\",\n        dir: prop(\"dir\"),\n        name: prop(\"name\"),\n        \"data-index\": index,\n        \"data-state\": open ? \"open\" : \"closed\",\n        readOnly,\n        disabled,\n        placeholder: prop(\"placeholder\") || getInputPlaceholder(locale),\n        defaultValue: computed(\"valueAsString\")[index],\n        onBeforeInput(event) {\n          const {\n            data\n          } = getNativeEvent(event);\n          if (!isValidCharacter(data, separator)) {\n            event.preventDefault();\n          }\n        },\n        onFocus() {\n          send({\n            type: \"INPUT.FOCUS\",\n            index\n          });\n        },\n        onBlur(event) {\n          const value = event.currentTarget.value.trim();\n          send({\n            type: \"INPUT.BLUR\",\n            value,\n            index,\n            fixOnBlur\n          });\n        },\n        onKeyDown(event) {\n          if (event.defaultPrevented) return;\n          if (!interactive) return;\n          const keyMap = {\n            Enter(event2) {\n              if (isComposingEvent(event2)) return;\n              if (isUnavailable(focusedValue)) return;\n              if (event2.currentTarget.value.trim() === \"\") return;\n              send({\n                type: \"INPUT.ENTER\",\n                value: event2.currentTarget.value,\n                index\n              });\n            }\n          };\n          const exec = keyMap[event.key];\n          if (exec) {\n            exec(event);\n            event.preventDefault();\n          }\n        },\n        onInput(event) {\n          const value = event.currentTarget.value;\n          send({\n            type: \"INPUT.CHANGE\",\n            value: ensureValidCharacters(value, separator),\n            index\n          });\n        }\n      });\n    },\n    getMonthSelectProps() {\n      return normalize.select({\n        ...parts.monthSelect.attrs,\n        id: getMonthSelectId(scope),\n        \"aria-label\": translations.monthSelect,\n        disabled,\n        dir: prop(\"dir\"),\n        defaultValue: startValue.month,\n        onChange(event) {\n          focusMonth(Number(event.currentTarget.value));\n        }\n      });\n    },\n    getYearSelectProps() {\n      return normalize.select({\n        ...parts.yearSelect.attrs,\n        id: getYearSelectId(scope),\n        disabled,\n        \"aria-label\": translations.yearSelect,\n        dir: prop(\"dir\"),\n        defaultValue: startValue.year,\n        onChange(event) {\n          focusYear(Number(event.currentTarget.value));\n        }\n      });\n    },\n    getPositionerProps() {\n      return normalize.element({\n        id: getPositionerId(scope),\n        ...parts.positioner.attrs,\n        dir: prop(\"dir\"),\n        style: popperStyles.floating\n      });\n    },\n    getPresetTriggerProps(props2) {\n      const value = Array.isArray(props2.value) ? props2.value : getDateRangePreset(props2.value, locale, timeZone);\n      const valueAsString = value.map(item => item.toDate(timeZone).toDateString());\n      return normalize.button({\n        ...parts.presetTrigger.attrs,\n        \"aria-label\": translations.presetTrigger(valueAsString),\n        type: \"button\",\n        onClick(event) {\n          if (event.defaultPrevented) return;\n          send({\n            type: \"PRESET.CLICK\",\n            value\n          });\n        }\n      });\n    }\n  };\n}\nvar {\n  and\n} = createGuards();\nfunction isDateArrayEqual(a, b) {\n  if (a?.length !== b?.length) return false;\n  const len = Math.max(a.length, b.length);\n  for (let i = 0; i < len; i++) {\n    if (!isDateEqual(a[i], b[i])) return false;\n  }\n  return true;\n}\nvar machine = createMachine({\n  props({\n    props: props2\n  }) {\n    const locale = props2.locale || \"en-US\";\n    const timeZone = props2.timeZone || \"UTC\";\n    const selectionMode = props2.selectionMode || \"single\";\n    const numOfMonths = props2.numOfMonths || 1;\n    const defaultValue = props2.defaultValue ? sortDates(props2.defaultValue).map(date => constrainValue(date, props2.min, props2.max)) : void 0;\n    const value = props2.value ? sortDates(props2.value).map(date => constrainValue(date, props2.min, props2.max)) : void 0;\n    let focusedValue = props2.focusedValue || value?.[0] || defaultValue?.[0] || getTodayDate(timeZone);\n    focusedValue = constrainValue(focusedValue, props2.min, props2.max);\n    const minView = \"day\";\n    const maxView = \"year\";\n    const defaultView = clampView(props2.view || minView, minView, maxView);\n    return {\n      locale,\n      numOfMonths,\n      focusedValue,\n      timeZone,\n      defaultValue: defaultValue ?? [],\n      value,\n      selectionMode,\n      defaultView,\n      minView,\n      maxView,\n      closeOnSelect: true,\n      format(date, {\n        locale: locale2,\n        timeZone: timeZone2\n      }) {\n        const formatter = new DateFormatter(locale2, {\n          timeZone: timeZone2,\n          day: \"2-digit\",\n          month: \"2-digit\",\n          year: \"numeric\"\n        });\n        return formatter.format(date.toDate(timeZone2));\n      },\n      parse(value2, {\n        locale: locale2,\n        timeZone: timeZone2\n      }) {\n        return parseDateString(value2, locale2, timeZone2);\n      },\n      ...props2,\n      positioning: {\n        placement: \"bottom\",\n        ...props2.positioning\n      }\n    };\n  },\n  initialState({\n    prop\n  }) {\n    const open = prop(\"open\") || prop(\"defaultOpen\");\n    return open ? \"open\" : \"idle\";\n  },\n  refs() {\n    return {\n      announcer: void 0\n    };\n  },\n  context({\n    prop,\n    bindable,\n    getContext,\n    getComputed\n  }) {\n    return {\n      focusedValue: bindable(() => ({\n        defaultValue: prop(\"focusedValue\"),\n        isEqual: isDateEqual,\n        hash: v => v.toString(),\n        sync: true,\n        onChange(focusedValue) {\n          const context = getContext();\n          const computed = getComputed();\n          prop(\"onFocusChange\")?.({\n            value: context.get(\"value\"),\n            valueAsString: computed(\"valueAsString\"),\n            view: context.get(\"view\"),\n            focusedValue\n          });\n        }\n      })),\n      value: bindable(() => ({\n        defaultValue: prop(\"defaultValue\"),\n        value: prop(\"value\"),\n        isEqual: isDateArrayEqual,\n        hash: v => v.map(date => date.toString()).join(\",\"),\n        onChange(value) {\n          const context = getContext();\n          const valueAsString = value.map(date => prop(\"format\")(date, {\n            locale: prop(\"locale\"),\n            timeZone: prop(\"timeZone\")\n          }));\n          prop(\"onValueChange\")?.({\n            value,\n            valueAsString,\n            view: context.get(\"view\")\n          });\n        }\n      })),\n      inputValue: bindable(() => ({\n        defaultValue: \"\"\n      })),\n      activeIndex: bindable(() => ({\n        defaultValue: 0,\n        sync: true\n      })),\n      hoveredValue: bindable(() => ({\n        defaultValue: null,\n        isEqual: (a, b) => b !== null && a !== null && isDateEqual(a, b)\n      })),\n      view: bindable(() => ({\n        defaultValue: prop(\"defaultView\"),\n        value: prop(\"view\"),\n        onChange(value) {\n          prop(\"onViewChange\")?.({\n            view: value\n          });\n        }\n      })),\n      startValue: bindable(() => {\n        return {\n          defaultValue: alignDate(prop(\"focusedValue\"), \"start\", {\n            months: prop(\"numOfMonths\")\n          }, prop(\"locale\")),\n          isEqual: isDateEqual\n        };\n      }),\n      currentPlacement: bindable(() => ({\n        defaultValue: void 0\n      })),\n      restoreFocus: bindable(() => ({\n        defaultValue: false\n      }))\n    };\n  },\n  computed: {\n    isInteractive: ({\n      prop\n    }) => !prop(\"disabled\") && !prop(\"readOnly\"),\n    visibleDuration: ({\n      prop\n    }) => ({\n      months: prop(\"numOfMonths\")\n    }),\n    endValue: ({\n      context,\n      computed\n    }) => getEndDate(context.get(\"startValue\"), computed(\"visibleDuration\")),\n    visibleRange: ({\n      context,\n      computed\n    }) => ({\n      start: context.get(\"startValue\"),\n      end: computed(\"endValue\")\n    }),\n    visibleRangeText({\n      context,\n      prop,\n      computed\n    }) {\n      const timeZone = prop(\"timeZone\");\n      const formatter = new DateFormatter(prop(\"locale\"), {\n        month: \"long\",\n        year: \"numeric\",\n        timeZone\n      });\n      const start = formatter.format(context.get(\"startValue\").toDate(timeZone));\n      const end = formatter.format(computed(\"endValue\").toDate(timeZone));\n      const formatted = prop(\"selectionMode\") === \"range\" ? `${start} - ${end}` : start;\n      return {\n        start,\n        end,\n        formatted\n      };\n    },\n    isPrevVisibleRangeValid: ({\n      context,\n      prop\n    }) => !isPreviousRangeInvalid(context.get(\"startValue\"), prop(\"min\"), prop(\"max\")),\n    isNextVisibleRangeValid: ({\n      prop,\n      computed\n    }) => !isNextRangeInvalid(computed(\"endValue\"), prop(\"min\"), prop(\"max\")),\n    valueAsString({\n      context,\n      prop\n    }) {\n      const value = context.get(\"value\");\n      return value.map(date => prop(\"format\")(date, {\n        locale: prop(\"locale\"),\n        timeZone: prop(\"timeZone\")\n      }));\n    }\n  },\n  effects: [\"setupLiveRegion\"],\n  watch({\n    track,\n    prop,\n    context,\n    action,\n    computed\n  }) {\n    track([() => prop(\"locale\")], () => {\n      action([\"setStartValue\"]);\n    });\n    track([() => context.hash(\"focusedValue\")], () => {\n      action([\"setStartValue\", \"syncMonthSelectElement\", \"syncYearSelectElement\", \"focusActiveCellIfNeeded\", \"setHoveredValueIfKeyboard\"]);\n    });\n    track([() => context.get(\"inputValue\")], () => {\n      action([\"syncInputValue\"]);\n    });\n    track([() => context.hash(\"value\")], () => {\n      action([\"syncInputElement\"]);\n    });\n    track([() => computed(\"valueAsString\").toString()], () => {\n      action([\"announceValueText\"]);\n    });\n    track([() => context.get(\"view\")], () => {\n      action([\"focusActiveCell\"]);\n    });\n    track([() => prop(\"open\")], () => {\n      action([\"toggleVisibility\"]);\n    });\n  },\n  on: {\n    \"VALUE.SET\": {\n      actions: [\"setDateValue\", \"setFocusedDate\"]\n    },\n    \"VIEW.SET\": {\n      actions: [\"setView\"]\n    },\n    \"FOCUS.SET\": {\n      actions: [\"setFocusedDate\"]\n    },\n    \"VALUE.CLEAR\": {\n      actions: [\"clearDateValue\", \"clearFocusedDate\", \"focusFirstInputElement\"]\n    },\n    \"INPUT.CHANGE\": [{\n      guard: \"isInputValueEmpty\",\n      actions: [\"setInputValue\", \"clearDateValue\", \"clearFocusedDate\"]\n    }, {\n      actions: [\"setInputValue\", \"focusParsedDate\"]\n    }],\n    \"INPUT.ENTER\": {\n      actions: [\"focusParsedDate\", \"selectFocusedDate\"]\n    },\n    \"INPUT.FOCUS\": {\n      actions: [\"setActiveIndex\"]\n    },\n    \"INPUT.BLUR\": [{\n      guard: \"shouldFixOnBlur\",\n      actions: [\"setActiveIndexToStart\", \"selectParsedDate\"]\n    }, {\n      actions: [\"setActiveIndexToStart\"]\n    }],\n    \"PRESET.CLICK\": [{\n      guard: \"isOpenControlled\",\n      actions: [\"setDateValue\", \"setFocusedDate\", \"invokeOnClose\"]\n    }, {\n      target: \"focused\",\n      actions: [\"setDateValue\", \"setFocusedDate\", \"focusInputElement\"]\n    }],\n    \"GOTO.NEXT\": [{\n      guard: \"isYearView\",\n      actions: [\"focusNextDecade\", \"announceVisibleRange\"]\n    }, {\n      guard: \"isMonthView\",\n      actions: [\"focusNextYear\", \"announceVisibleRange\"]\n    }, {\n      actions: [\"focusNextPage\"]\n    }],\n    \"GOTO.PREV\": [{\n      guard: \"isYearView\",\n      actions: [\"focusPreviousDecade\", \"announceVisibleRange\"]\n    }, {\n      guard: \"isMonthView\",\n      actions: [\"focusPreviousYear\", \"announceVisibleRange\"]\n    }, {\n      actions: [\"focusPreviousPage\"]\n    }]\n  },\n  states: {\n    idle: {\n      tags: [\"closed\"],\n      on: {\n        \"CONTROLLED.OPEN\": {\n          target: \"open\",\n          actions: [\"focusFirstSelectedDate\", \"focusActiveCell\"]\n        },\n        \"TRIGGER.CLICK\": [{\n          guard: \"isOpenControlled\",\n          actions: [\"invokeOnOpen\"]\n        }, {\n          target: \"open\",\n          actions: [\"focusFirstSelectedDate\", \"focusActiveCell\", \"invokeOnOpen\"]\n        }],\n        OPEN: [{\n          guard: \"isOpenControlled\",\n          actions: [\"invokeOnOpen\"]\n        }, {\n          target: \"open\",\n          actions: [\"focusFirstSelectedDate\", \"focusActiveCell\", \"invokeOnOpen\"]\n        }]\n      }\n    },\n    focused: {\n      tags: [\"closed\"],\n      on: {\n        \"CONTROLLED.OPEN\": {\n          target: \"open\",\n          actions: [\"focusFirstSelectedDate\", \"focusActiveCell\"]\n        },\n        \"TRIGGER.CLICK\": [{\n          guard: \"isOpenControlled\",\n          actions: [\"invokeOnOpen\"]\n        }, {\n          target: \"open\",\n          actions: [\"focusFirstSelectedDate\", \"focusActiveCell\", \"invokeOnOpen\"]\n        }],\n        OPEN: [{\n          guard: \"isOpenControlled\",\n          actions: [\"invokeOnOpen\"]\n        }, {\n          target: \"open\",\n          actions: [\"focusFirstSelectedDate\", \"focusActiveCell\", \"invokeOnOpen\"]\n        }]\n      }\n    },\n    open: {\n      tags: [\"open\"],\n      effects: [\"trackDismissableElement\", \"trackPositioning\"],\n      exit: [\"clearHoveredDate\", \"resetView\"],\n      on: {\n        \"CONTROLLED.CLOSE\": [{\n          guard: and(\"shouldRestoreFocus\", \"isInteractOutsideEvent\"),\n          target: \"focused\",\n          actions: [\"focusTriggerElement\"]\n        }, {\n          guard: \"shouldRestoreFocus\",\n          target: \"focused\",\n          actions: [\"focusInputElement\"]\n        }, {\n          target: \"idle\"\n        }],\n        \"CELL.CLICK\": [{\n          guard: \"isAboveMinView\",\n          actions: [\"setFocusedValueForView\", \"setPreviousView\"]\n        }, {\n          guard: and(\"isRangePicker\", \"hasSelectedRange\"),\n          actions: [\"setActiveIndexToStart\", \"resetSelection\", \"setActiveIndexToEnd\"]\n        },\n        // === Grouped transitions (based on `closeOnSelect` and `isOpenControlled`) ===\n        {\n          guard: and(\"isRangePicker\", \"isSelectingEndDate\", \"closeOnSelect\", \"isOpenControlled\"),\n          actions: [\"setFocusedDate\", \"setSelectedDate\", \"setActiveIndexToStart\", \"invokeOnClose\", \"setRestoreFocus\"]\n        }, {\n          guard: and(\"isRangePicker\", \"isSelectingEndDate\", \"closeOnSelect\"),\n          target: \"focused\",\n          actions: [\"setFocusedDate\", \"setSelectedDate\", \"setActiveIndexToStart\", \"invokeOnClose\", \"focusInputElement\"]\n        }, {\n          guard: and(\"isRangePicker\", \"isSelectingEndDate\"),\n          actions: [\"setFocusedDate\", \"setSelectedDate\", \"setActiveIndexToStart\", \"clearHoveredDate\"]\n        },\n        // ===\n        {\n          guard: \"isRangePicker\",\n          actions: [\"setFocusedDate\", \"setSelectedDate\", \"setActiveIndexToEnd\"]\n        }, {\n          guard: \"isMultiPicker\",\n          actions: [\"setFocusedDate\", \"toggleSelectedDate\"]\n        },\n        // === Grouped transitions (based on `closeOnSelect` and `isOpenControlled`) ===\n        {\n          guard: and(\"closeOnSelect\", \"isOpenControlled\"),\n          actions: [\"setFocusedDate\", \"setSelectedDate\", \"invokeOnClose\"]\n        }, {\n          guard: \"closeOnSelect\",\n          target: \"focused\",\n          actions: [\"setFocusedDate\", \"setSelectedDate\", \"invokeOnClose\", \"focusInputElement\"]\n        }, {\n          actions: [\"setFocusedDate\", \"setSelectedDate\"]\n        }\n        // ===\n        ],\n        \"CELL.POINTER_MOVE\": {\n          guard: and(\"isRangePicker\", \"isSelectingEndDate\"),\n          actions: [\"setHoveredDate\", \"setFocusedDate\"]\n        },\n        \"TABLE.POINTER_LEAVE\": {\n          guard: \"isRangePicker\",\n          actions: [\"clearHoveredDate\"]\n        },\n        \"TABLE.POINTER_DOWN\": {\n          actions: [\"disableTextSelection\"]\n        },\n        \"TABLE.POINTER_UP\": {\n          actions: [\"enableTextSelection\"]\n        },\n        \"TABLE.ESCAPE\": [{\n          guard: \"isOpenControlled\",\n          actions: [\"focusFirstSelectedDate\", \"invokeOnClose\"]\n        }, {\n          target: \"focused\",\n          actions: [\"focusFirstSelectedDate\", \"invokeOnClose\", \"focusTriggerElement\"]\n        }],\n        \"TABLE.ENTER\": [{\n          guard: \"isAboveMinView\",\n          actions: [\"setPreviousView\"]\n        }, {\n          guard: and(\"isRangePicker\", \"hasSelectedRange\"),\n          actions: [\"setActiveIndexToStart\", \"clearDateValue\", \"setSelectedDate\", \"setActiveIndexToEnd\"]\n        },\n        // === Grouped transitions (based on `closeOnSelect` and `isOpenControlled`) ===\n        {\n          guard: and(\"isRangePicker\", \"isSelectingEndDate\", \"closeOnSelect\", \"isOpenControlled\"),\n          actions: [\"setSelectedDate\", \"setActiveIndexToStart\", \"invokeOnClose\"]\n        }, {\n          guard: and(\"isRangePicker\", \"isSelectingEndDate\", \"closeOnSelect\"),\n          target: \"focused\",\n          actions: [\"setSelectedDate\", \"setActiveIndexToStart\", \"invokeOnClose\", \"focusInputElement\"]\n        }, {\n          guard: and(\"isRangePicker\", \"isSelectingEndDate\"),\n          actions: [\"setSelectedDate\", \"setActiveIndexToStart\"]\n        },\n        // ===\n        {\n          guard: \"isRangePicker\",\n          actions: [\"setSelectedDate\", \"setActiveIndexToEnd\", \"focusNextDay\"]\n        }, {\n          guard: \"isMultiPicker\",\n          actions: [\"toggleSelectedDate\"]\n        },\n        // === Grouped transitions (based on `closeOnSelect` and `isOpenControlled`) ===\n        {\n          guard: and(\"closeOnSelect\", \"isOpenControlled\"),\n          actions: [\"selectFocusedDate\", \"invokeOnClose\"]\n        }, {\n          guard: \"closeOnSelect\",\n          target: \"focused\",\n          actions: [\"selectFocusedDate\", \"invokeOnClose\", \"focusInputElement\"]\n        }, {\n          actions: [\"selectFocusedDate\"]\n        }\n        // ===\n        ],\n        \"TABLE.ARROW_RIGHT\": [{\n          guard: \"isMonthView\",\n          actions: [\"focusNextMonth\"]\n        }, {\n          guard: \"isYearView\",\n          actions: [\"focusNextYear\"]\n        }, {\n          actions: [\"focusNextDay\", \"setHoveredDate\"]\n        }],\n        \"TABLE.ARROW_LEFT\": [{\n          guard: \"isMonthView\",\n          actions: [\"focusPreviousMonth\"]\n        }, {\n          guard: \"isYearView\",\n          actions: [\"focusPreviousYear\"]\n        }, {\n          actions: [\"focusPreviousDay\"]\n        }],\n        \"TABLE.ARROW_UP\": [{\n          guard: \"isMonthView\",\n          actions: [\"focusPreviousMonthColumn\"]\n        }, {\n          guard: \"isYearView\",\n          actions: [\"focusPreviousYearColumn\"]\n        }, {\n          actions: [\"focusPreviousWeek\"]\n        }],\n        \"TABLE.ARROW_DOWN\": [{\n          guard: \"isMonthView\",\n          actions: [\"focusNextMonthColumn\"]\n        }, {\n          guard: \"isYearView\",\n          actions: [\"focusNextYearColumn\"]\n        }, {\n          actions: [\"focusNextWeek\"]\n        }],\n        \"TABLE.PAGE_UP\": {\n          actions: [\"focusPreviousSection\"]\n        },\n        \"TABLE.PAGE_DOWN\": {\n          actions: [\"focusNextSection\"]\n        },\n        \"TABLE.HOME\": [{\n          guard: \"isMonthView\",\n          actions: [\"focusFirstMonth\"]\n        }, {\n          guard: \"isYearView\",\n          actions: [\"focusFirstYear\"]\n        }, {\n          actions: [\"focusSectionStart\"]\n        }],\n        \"TABLE.END\": [{\n          guard: \"isMonthView\",\n          actions: [\"focusLastMonth\"]\n        }, {\n          guard: \"isYearView\",\n          actions: [\"focusLastYear\"]\n        }, {\n          actions: [\"focusSectionEnd\"]\n        }],\n        \"TRIGGER.CLICK\": [{\n          guard: \"isOpenControlled\",\n          actions: [\"invokeOnClose\"]\n        }, {\n          target: \"focused\",\n          actions: [\"invokeOnClose\"]\n        }],\n        \"VIEW.TOGGLE\": {\n          actions: [\"setNextView\"]\n        },\n        INTERACT_OUTSIDE: [{\n          guard: \"isOpenControlled\",\n          actions: [\"setActiveIndexToStart\", \"invokeOnClose\"]\n        }, {\n          guard: \"shouldRestoreFocus\",\n          target: \"focused\",\n          actions: [\"setActiveIndexToStart\", \"invokeOnClose\", \"focusTriggerElement\"]\n        }, {\n          target: \"idle\",\n          actions: [\"setActiveIndexToStart\", \"invokeOnClose\"]\n        }],\n        CLOSE: [{\n          guard: \"isOpenControlled\",\n          actions: [\"setActiveIndexToStart\", \"invokeOnClose\"]\n        }, {\n          target: \"idle\",\n          actions: [\"setActiveIndexToStart\", \"invokeOnClose\"]\n        }]\n      }\n    }\n  },\n  implementations: {\n    guards: {\n      isAboveMinView: ({\n        context,\n        prop\n      }) => isAboveMinView(context.get(\"view\"), prop(\"minView\")),\n      isDayView: ({\n        context,\n        event\n      }) => (event.view || context.get(\"view\")) === \"day\",\n      isMonthView: ({\n        context,\n        event\n      }) => (event.view || context.get(\"view\")) === \"month\",\n      isYearView: ({\n        context,\n        event\n      }) => (event.view || context.get(\"view\")) === \"year\",\n      isRangePicker: ({\n        prop\n      }) => prop(\"selectionMode\") === \"range\",\n      hasSelectedRange: ({\n        context\n      }) => context.get(\"value\").length === 2,\n      isMultiPicker: ({\n        prop\n      }) => prop(\"selectionMode\") === \"multiple\",\n      shouldRestoreFocus: ({\n        context\n      }) => !!context.get(\"restoreFocus\"),\n      isSelectingEndDate: ({\n        context\n      }) => context.get(\"activeIndex\") === 1,\n      closeOnSelect: ({\n        prop\n      }) => !!prop(\"closeOnSelect\"),\n      isOpenControlled: ({\n        prop\n      }) => prop(\"open\") != void 0,\n      isInteractOutsideEvent: ({\n        event\n      }) => event.previousEvent?.type === \"INTERACT_OUTSIDE\",\n      isInputValueEmpty: ({\n        event\n      }) => event.value.trim() === \"\",\n      shouldFixOnBlur: ({\n        event\n      }) => !!event.fixOnBlur\n    },\n    effects: {\n      trackPositioning({\n        context,\n        prop,\n        scope\n      }) {\n        if (!context.get(\"currentPlacement\")) {\n          context.set(\"currentPlacement\", prop(\"positioning\").placement);\n        }\n        const anchorEl = getControlEl(scope);\n        const getPositionerEl2 = () => getPositionerEl(scope);\n        return getPlacement(anchorEl, getPositionerEl2, {\n          ...prop(\"positioning\"),\n          defer: true,\n          onComplete(data) {\n            context.set(\"currentPlacement\", data.placement);\n          }\n        });\n      },\n      setupLiveRegion({\n        scope,\n        refs\n      }) {\n        const doc = scope.getDoc();\n        refs.set(\"announcer\", createLiveRegion({\n          level: \"assertive\",\n          document: doc\n        }));\n        return () => refs.get(\"announcer\")?.destroy?.();\n      },\n      trackDismissableElement({\n        scope,\n        send,\n        context\n      }) {\n        const getContentEl2 = () => getContentEl(scope);\n        return trackDismissableElement(getContentEl2, {\n          defer: true,\n          exclude: [...getInputEls(scope), getTriggerEl(scope), getClearTriggerEl(scope)],\n          onInteractOutside(event) {\n            context.set(\"restoreFocus\", !event.detail.focusable);\n          },\n          onDismiss() {\n            send({\n              type: \"INTERACT_OUTSIDE\"\n            });\n          },\n          onEscapeKeyDown(event) {\n            event.preventDefault();\n            send({\n              type: \"TABLE.ESCAPE\",\n              src: \"dismissable\"\n            });\n          }\n        });\n      }\n    },\n    actions: {\n      setNextView({\n        context,\n        prop\n      }) {\n        const nextView = getNextView(context.get(\"view\"), prop(\"minView\"), prop(\"maxView\"));\n        context.set(\"view\", nextView);\n      },\n      setPreviousView({\n        context,\n        prop\n      }) {\n        const prevView = getPreviousView(context.get(\"view\"), prop(\"minView\"), prop(\"maxView\"));\n        context.set(\"view\", prevView);\n      },\n      setView({\n        context,\n        event\n      }) {\n        context.set(\"view\", event.view);\n      },\n      setRestoreFocus({\n        context\n      }) {\n        context.set(\"restoreFocus\", true);\n      },\n      announceValueText({\n        context,\n        prop,\n        refs\n      }) {\n        const announceText = context.get(\"value\").map(date => formatSelectedDate(date, null, prop(\"locale\"), prop(\"timeZone\")));\n        refs.get(\"announcer\")?.announce(announceText.join(\",\"), 3e3);\n      },\n      announceVisibleRange({\n        computed,\n        refs\n      }) {\n        const {\n          formatted\n        } = computed(\"visibleRangeText\");\n        refs.get(\"announcer\")?.announce(formatted);\n      },\n      disableTextSelection({\n        scope\n      }) {\n        disableTextSelection({\n          target: getContentEl(scope),\n          doc: scope.getDoc()\n        });\n      },\n      enableTextSelection({\n        scope\n      }) {\n        restoreTextSelection({\n          doc: scope.getDoc(),\n          target: getContentEl(scope)\n        });\n      },\n      focusFirstSelectedDate(params) {\n        const {\n          context\n        } = params;\n        if (!context.get(\"value\").length) return;\n        setFocusedValue(params, context.get(\"value\")[0]);\n      },\n      syncInputElement({\n        scope,\n        computed\n      }) {\n        raf(() => {\n          const inputEls = getInputEls(scope);\n          inputEls.forEach((inputEl, index) => {\n            setElementValue(inputEl, computed(\"valueAsString\")[index] || \"\");\n          });\n        });\n      },\n      setFocusedDate(params) {\n        const {\n          event\n        } = params;\n        const value = Array.isArray(event.value) ? event.value[0] : event.value;\n        setFocusedValue(params, value);\n      },\n      setFocusedValueForView(params) {\n        const {\n          context,\n          event\n        } = params;\n        setFocusedValue(params, context.get(\"focusedValue\").set({\n          [context.get(\"view\")]: event.value\n        }));\n      },\n      focusNextMonth(params) {\n        const {\n          context\n        } = params;\n        setFocusedValue(params, context.get(\"focusedValue\").add({\n          months: 1\n        }));\n      },\n      focusPreviousMonth(params) {\n        const {\n          context\n        } = params;\n        setFocusedValue(params, context.get(\"focusedValue\").subtract({\n          months: 1\n        }));\n      },\n      setDateValue({\n        context,\n        event,\n        prop\n      }) {\n        if (!Array.isArray(event.value)) return;\n        const value = event.value.map(date => constrainValue(date, prop(\"min\"), prop(\"max\")));\n        context.set(\"value\", value);\n      },\n      clearDateValue({\n        context\n      }) {\n        context.set(\"value\", []);\n      },\n      setSelectedDate(params) {\n        const {\n          context,\n          event\n        } = params;\n        const values = Array.from(context.get(\"value\"));\n        values[context.get(\"activeIndex\")] = normalizeValue(params, event.value ?? context.get(\"focusedValue\"));\n        context.set(\"value\", adjustStartAndEndDate(values));\n      },\n      resetSelection(params) {\n        const {\n          context,\n          event\n        } = params;\n        context.set(\"value\", [event.value ?? context.get(\"focusedValue\")]);\n      },\n      toggleSelectedDate(params) {\n        const {\n          context,\n          event\n        } = params;\n        const currentValue = normalizeValue(params, event.value ?? context.get(\"focusedValue\"));\n        const index = context.get(\"value\").findIndex(date => isDateEqual(date, currentValue));\n        if (index === -1) {\n          const values = [...context.get(\"value\"), currentValue];\n          context.set(\"value\", sortDates(values));\n        } else {\n          const values = Array.from(context.get(\"value\"));\n          values.splice(index, 1);\n          context.set(\"value\", sortDates(values));\n        }\n      },\n      setHoveredDate({\n        context,\n        event\n      }) {\n        context.set(\"hoveredValue\", event.value);\n      },\n      clearHoveredDate({\n        context\n      }) {\n        context.set(\"hoveredValue\", null);\n      },\n      selectFocusedDate({\n        context,\n        computed\n      }) {\n        const values = Array.from(context.get(\"value\"));\n        const activeIndex = context.get(\"activeIndex\");\n        values[activeIndex] = context.get(\"focusedValue\").copy();\n        context.set(\"value\", adjustStartAndEndDate(values));\n        const valueAsString = computed(\"valueAsString\");\n        context.set(\"inputValue\", valueAsString[activeIndex]);\n      },\n      focusPreviousDay(params) {\n        const {\n          context\n        } = params;\n        const nextValue = context.get(\"focusedValue\").subtract({\n          days: 1\n        });\n        setFocusedValue(params, nextValue);\n      },\n      focusNextDay(params) {\n        const {\n          context\n        } = params;\n        const nextValue = context.get(\"focusedValue\").add({\n          days: 1\n        });\n        setFocusedValue(params, nextValue);\n      },\n      focusPreviousWeek(params) {\n        const {\n          context\n        } = params;\n        const nextValue = context.get(\"focusedValue\").subtract({\n          weeks: 1\n        });\n        setFocusedValue(params, nextValue);\n      },\n      focusNextWeek(params) {\n        const {\n          context\n        } = params;\n        const nextValue = context.get(\"focusedValue\").add({\n          weeks: 1\n        });\n        setFocusedValue(params, nextValue);\n      },\n      focusNextPage(params) {\n        const {\n          context,\n          computed,\n          prop\n        } = params;\n        const nextPage = getNextPage(context.get(\"focusedValue\"), context.get(\"startValue\"), computed(\"visibleDuration\"), prop(\"locale\"), prop(\"min\"), prop(\"max\"));\n        setAdjustedValue(params, nextPage);\n      },\n      focusPreviousPage(params) {\n        const {\n          context,\n          computed,\n          prop\n        } = params;\n        const previousPage = getPreviousPage(context.get(\"focusedValue\"), context.get(\"startValue\"), computed(\"visibleDuration\"), prop(\"locale\"), prop(\"min\"), prop(\"max\"));\n        setAdjustedValue(params, previousPage);\n      },\n      focusSectionStart(params) {\n        const {\n          context\n        } = params;\n        setFocusedValue(params, context.get(\"startValue\").copy());\n      },\n      focusSectionEnd(params) {\n        const {\n          computed\n        } = params;\n        setFocusedValue(params, computed(\"endValue\").copy());\n      },\n      focusNextSection(params) {\n        const {\n          context,\n          event,\n          computed,\n          prop\n        } = params;\n        const nextSection = getNextSection(context.get(\"focusedValue\"), context.get(\"startValue\"), event.larger, computed(\"visibleDuration\"), prop(\"locale\"), prop(\"min\"), prop(\"max\"));\n        if (!nextSection) return;\n        setAdjustedValue(params, nextSection);\n      },\n      focusPreviousSection(params) {\n        const {\n          context,\n          event,\n          computed,\n          prop\n        } = params;\n        const previousSection = getPreviousSection(context.get(\"focusedValue\"), context.get(\"startValue\"), event.larger, computed(\"visibleDuration\"), prop(\"locale\"), prop(\"min\"), prop(\"max\"));\n        if (!previousSection) return;\n        setAdjustedValue(params, previousSection);\n      },\n      focusNextYear(params) {\n        const {\n          context\n        } = params;\n        const nextValue = context.get(\"focusedValue\").add({\n          years: 1\n        });\n        setFocusedValue(params, nextValue);\n      },\n      focusPreviousYear(params) {\n        const {\n          context\n        } = params;\n        const nextValue = context.get(\"focusedValue\").subtract({\n          years: 1\n        });\n        setFocusedValue(params, nextValue);\n      },\n      focusNextDecade(params) {\n        const {\n          context\n        } = params;\n        const nextValue = context.get(\"focusedValue\").add({\n          years: 10\n        });\n        setFocusedValue(params, nextValue);\n      },\n      focusPreviousDecade(params) {\n        const {\n          context\n        } = params;\n        const nextValue = context.get(\"focusedValue\").subtract({\n          years: 10\n        });\n        setFocusedValue(params, nextValue);\n      },\n      clearFocusedDate(params) {\n        const {\n          prop\n        } = params;\n        setFocusedValue(params, getTodayDate(prop(\"timeZone\")));\n      },\n      focusPreviousMonthColumn(params) {\n        const {\n          context,\n          event\n        } = params;\n        const nextValue = context.get(\"focusedValue\").subtract({\n          months: event.columns\n        });\n        setFocusedValue(params, nextValue);\n      },\n      focusNextMonthColumn(params) {\n        const {\n          context,\n          event\n        } = params;\n        const nextValue = context.get(\"focusedValue\").add({\n          months: event.columns\n        });\n        setFocusedValue(params, nextValue);\n      },\n      focusPreviousYearColumn(params) {\n        const {\n          context,\n          event\n        } = params;\n        const nextValue = context.get(\"focusedValue\").subtract({\n          years: event.columns\n        });\n        setFocusedValue(params, nextValue);\n      },\n      focusNextYearColumn(params) {\n        const {\n          context,\n          event\n        } = params;\n        const nextValue = context.get(\"focusedValue\").add({\n          years: event.columns\n        });\n        setFocusedValue(params, nextValue);\n      },\n      focusFirstMonth(params) {\n        const {\n          context\n        } = params;\n        const nextValue = context.get(\"focusedValue\").set({\n          month: 0\n        });\n        setFocusedValue(params, nextValue);\n      },\n      focusLastMonth(params) {\n        const {\n          context\n        } = params;\n        const nextValue = context.get(\"focusedValue\").set({\n          month: 12\n        });\n        setFocusedValue(params, nextValue);\n      },\n      focusFirstYear(params) {\n        const {\n          context\n        } = params;\n        const range = getDecadeRange(context.get(\"focusedValue\").year);\n        const nextValue = context.get(\"focusedValue\").set({\n          year: range[0]\n        });\n        setFocusedValue(params, nextValue);\n      },\n      focusLastYear(params) {\n        const {\n          context\n        } = params;\n        const range = getDecadeRange(context.get(\"focusedValue\").year);\n        const nextValue = context.get(\"focusedValue\").set({\n          year: range[range.length - 1]\n        });\n        setFocusedValue(params, nextValue);\n      },\n      setActiveIndex({\n        context,\n        event\n      }) {\n        context.set(\"activeIndex\", event.index);\n      },\n      setActiveIndexToEnd({\n        context\n      }) {\n        context.set(\"activeIndex\", 1);\n      },\n      setActiveIndexToStart({\n        context\n      }) {\n        context.set(\"activeIndex\", 0);\n      },\n      focusActiveCell({\n        scope,\n        context\n      }) {\n        raf(() => {\n          const view = context.get(\"view\");\n          getFocusedCell(scope, view)?.focus({\n            preventScroll: true\n          });\n        });\n      },\n      focusActiveCellIfNeeded({\n        scope,\n        context,\n        event\n      }) {\n        if (!event.focus) return;\n        raf(() => {\n          const view = context.get(\"view\");\n          getFocusedCell(scope, view)?.focus({\n            preventScroll: true\n          });\n        });\n      },\n      setHoveredValueIfKeyboard({\n        context,\n        event,\n        prop\n      }) {\n        if (!event.type.startsWith(\"TABLE.ARROW\") || prop(\"selectionMode\") !== \"range\" || context.get(\"activeIndex\") === 0) return;\n        context.set(\"hoveredValue\", context.get(\"focusedValue\").copy());\n      },\n      focusTriggerElement({\n        scope\n      }) {\n        raf(() => {\n          getTriggerEl(scope)?.focus({\n            preventScroll: true\n          });\n        });\n      },\n      focusFirstInputElement({\n        scope\n      }) {\n        raf(() => {\n          const [inputEl] = getInputEls(scope);\n          inputEl?.focus({\n            preventScroll: true\n          });\n        });\n      },\n      focusInputElement({\n        scope\n      }) {\n        raf(() => {\n          const inputEls = getInputEls(scope);\n          const lastIndexWithValue = inputEls.findLastIndex(inputEl2 => inputEl2.value !== \"\");\n          const indexToFocus = Math.max(lastIndexWithValue, 0);\n          const inputEl = inputEls[indexToFocus];\n          inputEl?.focus({\n            preventScroll: true\n          });\n          inputEl?.setSelectionRange(inputEl.value.length, inputEl.value.length);\n        });\n      },\n      syncMonthSelectElement({\n        scope,\n        context\n      }) {\n        const monthSelectEl = getMonthSelectEl(scope);\n        setElementValue(monthSelectEl, context.get(\"startValue\").month.toString());\n      },\n      syncYearSelectElement({\n        scope,\n        context\n      }) {\n        const yearSelectEl = getYearSelectEl(scope);\n        setElementValue(yearSelectEl, context.get(\"startValue\").year.toString());\n      },\n      setInputValue({\n        context,\n        event\n      }) {\n        if (context.get(\"activeIndex\") !== event.index) return;\n        context.set(\"inputValue\", event.value);\n      },\n      syncInputValue({\n        scope,\n        context,\n        event\n      }) {\n        queueMicrotask(() => {\n          const inputEls = getInputEls(scope);\n          const idx = event.index ?? context.get(\"activeIndex\");\n          setElementValue(inputEls[idx], context.get(\"inputValue\"));\n        });\n      },\n      focusParsedDate(params) {\n        const {\n          event,\n          prop\n        } = params;\n        if (event.index == null) return;\n        const parse2 = prop(\"parse\");\n        const date = parse2(event.value, {\n          locale: prop(\"locale\"),\n          timeZone: prop(\"timeZone\")\n        });\n        if (!date || !isValidDate(date)) return;\n        setFocusedValue(params, date);\n      },\n      selectParsedDate({\n        context,\n        event,\n        computed,\n        prop\n      }) {\n        if (event.index == null) return;\n        const parse2 = prop(\"parse\");\n        let date = parse2(event.value, {\n          locale: prop(\"locale\"),\n          timeZone: prop(\"timeZone\")\n        });\n        if (!date || !isValidDate(date)) {\n          if (event.value) {\n            date = context.get(\"focusedValue\").copy();\n          }\n        }\n        if (!date) return;\n        const values = Array.from(context.get(\"value\"));\n        values[event.index] = date;\n        context.set(\"value\", values);\n        context.set(\"inputValue\", computed(\"valueAsString\")[event.index]);\n      },\n      resetView({\n        context\n      }) {\n        context.set(\"view\", context.initial(\"view\"));\n      },\n      setStartValue({\n        context,\n        computed,\n        prop\n      }) {\n        const focusedValue = context.get(\"focusedValue\");\n        const outside = isDateOutsideRange(focusedValue, context.get(\"startValue\"), computed(\"endValue\"));\n        if (!outside) return;\n        const startValue = alignDate(focusedValue, \"start\", {\n          months: prop(\"numOfMonths\")\n        }, prop(\"locale\"));\n        context.set(\"startValue\", startValue);\n      },\n      invokeOnOpen({\n        prop\n      }) {\n        prop(\"onOpenChange\")?.({\n          open: true\n        });\n      },\n      invokeOnClose({\n        prop\n      }) {\n        prop(\"onOpenChange\")?.({\n          open: false\n        });\n      },\n      toggleVisibility({\n        event,\n        send,\n        prop\n      }) {\n        send({\n          type: prop(\"open\") ? \"CONTROLLED.OPEN\" : \"CONTROLLED.CLOSE\",\n          previousEvent: event\n        });\n      }\n    }\n  }\n});\nvar normalizeValue = (ctx, value) => {\n  const {\n    context,\n    prop\n  } = ctx;\n  const view = context.get(\"view\");\n  let dateValue = typeof value === \"number\" ? context.get(\"focusedValue\").set({\n    [view]: value\n  }) : value;\n  eachView(view2 => {\n    if (isBelowMinView(view2, prop(\"minView\"))) {\n      dateValue = dateValue.set({\n        [view2]: view2 === \"day\" ? 1 : 0\n      });\n    }\n  });\n  return dateValue;\n};\nfunction setFocusedValue(ctx, mixedValue) {\n  const {\n    context,\n    prop,\n    computed\n  } = ctx;\n  if (!mixedValue) return;\n  const value = normalizeValue(ctx, mixedValue);\n  if (isDateEqual(context.get(\"focusedValue\"), value)) return;\n  const adjustFn = getAdjustedDateFn(computed(\"visibleDuration\"), prop(\"locale\"), prop(\"min\"), prop(\"max\"));\n  const adjustedValue = adjustFn({\n    focusedDate: value,\n    startDate: context.get(\"startValue\")\n  });\n  context.set(\"startValue\", adjustedValue.startDate);\n  context.set(\"focusedValue\", adjustedValue.focusedDate);\n}\nfunction setAdjustedValue(ctx, value) {\n  const {\n    context\n  } = ctx;\n  context.set(\"startValue\", value.startDate);\n  const focusedValue = context.get(\"focusedValue\");\n  if (isDateEqual(focusedValue, value.focusedDate)) return;\n  context.set(\"focusedValue\", value.focusedDate);\n}\nfunction parse(value) {\n  if (Array.isArray(value)) {\n    return value.map(v => parse(v));\n  }\n  if (value instanceof Date) {\n    return new CalendarDate(value.getFullYear(), value.getMonth() + 1, value.getDate());\n  }\n  return parseDate(value);\n}\nvar props = createProps()([\"closeOnSelect\", \"dir\", \"disabled\", \"fixedWeeks\", \"focusedValue\", \"format\", \"parse\", \"placeholder\", \"getRootNode\", \"id\", \"ids\", \"isDateUnavailable\", \"locale\", \"max\", \"min\", \"name\", \"numOfMonths\", \"onFocusChange\", \"onOpenChange\", \"onValueChange\", \"onViewChange\", \"open\", \"defaultOpen\", \"positioning\", \"readOnly\", \"selectionMode\", \"startOfWeek\", \"timeZone\", \"translations\", \"value\", \"defaultView\", \"defaultValue\", \"view\", \"defaultFocusedValue\", \"minView\", \"maxView\"]);\nvar splitProps = createSplitProps(props);\nvar inputProps = createProps()([\"index\", \"fixOnBlur\"]);\nvar splitInputProps = createSplitProps(inputProps);\nvar presetTriggerProps = createProps()([\"value\"]);\nvar splitPresetTriggerProps = createSplitProps(presetTriggerProps);\nvar tableProps = createProps()([\"columns\", \"id\", \"view\"]);\nvar splitTableProps = createSplitProps(tableProps);\nvar tableCellProps = createProps()([\"disabled\", \"value\", \"columns\"]);\nvar splitTableCellProps = createSplitProps(tableCellProps);\nvar viewProps = createProps()([\"view\"]);\nvar splitViewProps = createSplitProps(viewProps);\nexport { anatomy, connect, inputProps, machine, parse, presetTriggerProps, props, splitInputProps, splitPresetTriggerProps, splitProps, splitTableCellProps, splitTableProps, splitViewProps, tableCellProps, tableProps, viewProps };","map":null,"metadata":{},"sourceType":"module"}