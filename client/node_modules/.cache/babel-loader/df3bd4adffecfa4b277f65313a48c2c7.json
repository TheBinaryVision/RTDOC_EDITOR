{"ast":null,"code":"import { createAnatomy } from '@zag-js/anatomy';\nimport { addDomEvent, getOverflowAncestors, isComposingEvent, dataAttr } from '@zag-js/dom-query';\nimport { trackFocusVisible, isFocusVisible } from '@zag-js/focus-visible';\nimport { getPlacement, getPlacementStyles } from '@zag-js/popper';\nimport { proxy, subscribe } from '@zag-js/store';\nimport { createGuards, createMachine } from '@zag-js/core';\nimport { createProps } from '@zag-js/types';\nimport { createSplitProps } from '@zag-js/utils';\n\n// src/tooltip.anatomy.ts\nvar anatomy = createAnatomy(\"tooltip\").parts(\"trigger\", \"arrow\", \"arrowTip\", \"positioner\", \"content\");\nvar parts = anatomy.build();\n\n// src/tooltip.dom.ts\nvar getTriggerId = scope => scope.ids?.trigger ?? `tooltip:${scope.id}:trigger`;\nvar getContentId = scope => scope.ids?.content ?? `tooltip:${scope.id}:content`;\nvar getArrowId = scope => scope.ids?.arrow ?? `tooltip:${scope.id}:arrow`;\nvar getPositionerId = scope => scope.ids?.positioner ?? `tooltip:${scope.id}:popper`;\nvar getTriggerEl = scope => scope.getById(getTriggerId(scope));\nvar getPositionerEl = scope => scope.getById(getPositionerId(scope));\nvar store = proxy({\n  id: null\n});\n\n// src/tooltip.connect.ts\nfunction connect(service, normalize) {\n  const {\n    state,\n    context,\n    send,\n    scope,\n    prop,\n    event: _event\n  } = service;\n  const id = prop(\"id\");\n  const hasAriaLabel = !!prop(\"aria-label\");\n  const open = state.matches(\"open\", \"closing\");\n  const triggerId = getTriggerId(scope);\n  const contentId = getContentId(scope);\n  const disabled = prop(\"disabled\");\n  const popperStyles = getPlacementStyles({\n    ...prop(\"positioning\"),\n    placement: context.get(\"currentPlacement\")\n  });\n  return {\n    open,\n    setOpen(nextOpen) {\n      const open2 = state.matches(\"open\", \"closing\");\n      if (open2 === nextOpen) return;\n      send({\n        type: nextOpen ? \"open\" : \"close\"\n      });\n    },\n    reposition(options = {}) {\n      send({\n        type: \"positioning.set\",\n        options\n      });\n    },\n    getTriggerProps() {\n      return normalize.button({\n        ...parts.trigger.attrs,\n        id: triggerId,\n        dir: prop(\"dir\"),\n        \"data-expanded\": dataAttr(open),\n        \"data-state\": open ? \"open\" : \"closed\",\n        \"aria-describedby\": open ? contentId : void 0,\n        onClick(event) {\n          if (event.defaultPrevented) return;\n          if (disabled) return;\n          if (!prop(\"closeOnClick\")) return;\n          send({\n            type: \"close\",\n            src: \"trigger.click\"\n          });\n        },\n        onFocus(event) {\n          queueMicrotask(() => {\n            if (event.defaultPrevented) return;\n            if (disabled) return;\n            if (_event.src === \"trigger.pointerdown\") return;\n            if (!isFocusVisible()) return;\n            send({\n              type: \"open\",\n              src: \"trigger.focus\"\n            });\n          });\n        },\n        onBlur(event) {\n          if (event.defaultPrevented) return;\n          if (disabled) return;\n          if (id === store.id) {\n            send({\n              type: \"close\",\n              src: \"trigger.blur\"\n            });\n          }\n        },\n        onPointerDown(event) {\n          if (event.defaultPrevented) return;\n          if (disabled) return;\n          if (!prop(\"closeOnPointerDown\")) return;\n          if (id === store.id) {\n            send({\n              type: \"close\",\n              src: \"trigger.pointerdown\"\n            });\n          }\n        },\n        onPointerMove(event) {\n          if (event.defaultPrevented) return;\n          if (disabled) return;\n          if (event.pointerType === \"touch\") return;\n          send({\n            type: \"pointer.move\"\n          });\n        },\n        onPointerLeave() {\n          if (disabled) return;\n          send({\n            type: \"pointer.leave\"\n          });\n        },\n        onPointerCancel() {\n          if (disabled) return;\n          send({\n            type: \"pointer.leave\"\n          });\n        }\n      });\n    },\n    getArrowProps() {\n      return normalize.element({\n        id: getArrowId(scope),\n        ...parts.arrow.attrs,\n        dir: prop(\"dir\"),\n        style: popperStyles.arrow\n      });\n    },\n    getArrowTipProps() {\n      return normalize.element({\n        ...parts.arrowTip.attrs,\n        dir: prop(\"dir\"),\n        style: popperStyles.arrowTip\n      });\n    },\n    getPositionerProps() {\n      return normalize.element({\n        id: getPositionerId(scope),\n        ...parts.positioner.attrs,\n        dir: prop(\"dir\"),\n        style: popperStyles.floating\n      });\n    },\n    getContentProps() {\n      return normalize.element({\n        ...parts.content.attrs,\n        dir: prop(\"dir\"),\n        hidden: !open,\n        \"data-state\": open ? \"open\" : \"closed\",\n        role: hasAriaLabel ? void 0 : \"tooltip\",\n        id: hasAriaLabel ? void 0 : contentId,\n        \"data-placement\": context.get(\"currentPlacement\"),\n        onPointerEnter() {\n          send({\n            type: \"content.pointer.move\"\n          });\n        },\n        onPointerLeave() {\n          send({\n            type: \"content.pointer.leave\"\n          });\n        },\n        style: {\n          pointerEvents: prop(\"interactive\") ? \"auto\" : \"none\"\n        }\n      });\n    }\n  };\n}\nvar {\n  and,\n  not\n} = createGuards();\nvar machine = createMachine({\n  initialState: ({\n    prop\n  }) => {\n    const open = prop(\"open\") || prop(\"defaultOpen\");\n    return open ? \"open\" : \"closed\";\n  },\n  props({\n    props: props2\n  }) {\n    return {\n      id: \"x\",\n      openDelay: 1e3,\n      closeDelay: 500,\n      closeOnPointerDown: true,\n      closeOnEscape: true,\n      interactive: false,\n      closeOnScroll: true,\n      closeOnClick: true,\n      disabled: false,\n      ...props2,\n      positioning: {\n        placement: \"bottom\",\n        ...props2.positioning\n      }\n    };\n  },\n  effects: [\"trackFocusVisible\", \"trackStore\"],\n  context: ({\n    bindable\n  }) => ({\n    currentPlacement: bindable(() => ({\n      defaultValue: void 0\n    })),\n    hasPointerMoveOpened: bindable(() => ({\n      defaultValue: false\n    }))\n  }),\n  watch({\n    track,\n    action,\n    prop\n  }) {\n    track([() => prop(\"disabled\")], () => {\n      action([\"closeIfDisabled\"]);\n    });\n    track([() => prop(\"open\")], () => {\n      action([\"toggleVisibility\"]);\n    });\n  },\n  states: {\n    closed: {\n      entry: [\"clearGlobalId\"],\n      on: {\n        \"controlled.open\": {\n          target: \"open\"\n        },\n        open: [{\n          guard: \"isOpenControlled\",\n          actions: [\"invokeOnOpen\"]\n        }, {\n          target: \"open\",\n          actions: [\"invokeOnOpen\"]\n        }],\n        \"pointer.leave\": {\n          actions: [\"clearPointerMoveOpened\"]\n        },\n        \"pointer.move\": [{\n          guard: and(\"noVisibleTooltip\", not(\"hasPointerMoveOpened\")),\n          target: \"opening\"\n        }, {\n          guard: not(\"hasPointerMoveOpened\"),\n          target: \"open\",\n          actions: [\"setPointerMoveOpened\", \"invokeOnOpen\"]\n        }]\n      }\n    },\n    opening: {\n      effects: [\"trackScroll\", \"trackPointerlockChange\", \"waitForOpenDelay\"],\n      on: {\n        \"after.openDelay\": [{\n          guard: \"isOpenControlled\",\n          actions: [\"setPointerMoveOpened\", \"invokeOnOpen\"]\n        }, {\n          target: \"open\",\n          actions: [\"setPointerMoveOpened\", \"invokeOnOpen\"]\n        }],\n        \"controlled.open\": {\n          target: \"open\"\n        },\n        \"controlled.close\": {\n          target: \"closed\"\n        },\n        open: [{\n          guard: \"isOpenControlled\",\n          actions: [\"invokeOnOpen\"]\n        }, {\n          target: \"open\",\n          actions: [\"invokeOnOpen\"]\n        }],\n        \"pointer.leave\": [{\n          guard: \"isOpenControlled\",\n          // We trigger toggleVisibility manually since the `ctx.open` has not changed yet (at this point)\n          actions: [\"clearPointerMoveOpened\", \"invokeOnClose\", \"toggleVisibility\"]\n        }, {\n          target: \"closed\",\n          actions: [\"clearPointerMoveOpened\", \"invokeOnClose\"]\n        }],\n        close: [{\n          guard: \"isOpenControlled\",\n          // We trigger toggleVisibility manually since the `ctx.open` has not changed yet (at this point)\n          actions: [\"invokeOnClose\", \"toggleVisibility\"]\n        }, {\n          target: \"closed\",\n          actions: [\"invokeOnClose\"]\n        }]\n      }\n    },\n    open: {\n      effects: [\"trackEscapeKey\", \"trackScroll\", \"trackPointerlockChange\", \"trackPositioning\"],\n      entry: [\"setGlobalId\"],\n      on: {\n        \"controlled.close\": {\n          target: \"closed\"\n        },\n        close: [{\n          guard: \"isOpenControlled\",\n          actions: [\"invokeOnClose\"]\n        }, {\n          target: \"closed\",\n          actions: [\"invokeOnClose\"]\n        }],\n        \"pointer.leave\": [{\n          guard: \"isVisible\",\n          target: \"closing\",\n          actions: [\"clearPointerMoveOpened\"]\n        },\n        // == group ==\n        {\n          guard: \"isOpenControlled\",\n          actions: [\"clearPointerMoveOpened\", \"invokeOnClose\"]\n        }, {\n          target: \"closed\",\n          actions: [\"clearPointerMoveOpened\", \"invokeOnClose\"]\n        }],\n        \"content.pointer.leave\": {\n          guard: \"isInteractive\",\n          target: \"closing\"\n        },\n        \"positioning.set\": {\n          actions: [\"reposition\"]\n        }\n      }\n    },\n    closing: {\n      effects: [\"trackPositioning\", \"waitForCloseDelay\"],\n      on: {\n        \"after.closeDelay\": [{\n          guard: \"isOpenControlled\",\n          actions: [\"invokeOnClose\"]\n        }, {\n          target: \"closed\",\n          actions: [\"invokeOnClose\"]\n        }],\n        \"controlled.close\": {\n          target: \"closed\"\n        },\n        \"controlled.open\": {\n          target: \"open\"\n        },\n        close: [{\n          guard: \"isOpenControlled\",\n          actions: [\"invokeOnClose\"]\n        }, {\n          target: \"closed\",\n          actions: [\"invokeOnClose\"]\n        }],\n        \"pointer.move\": [{\n          guard: \"isOpenControlled\",\n          // We trigger toggleVisibility manually since the `ctx.open` has not changed yet (at this point)\n          actions: [\"setPointerMoveOpened\", \"invokeOnOpen\", \"toggleVisibility\"]\n        }, {\n          target: \"open\",\n          actions: [\"setPointerMoveOpened\", \"invokeOnOpen\"]\n        }],\n        \"content.pointer.move\": {\n          guard: \"isInteractive\",\n          target: \"open\"\n        },\n        \"positioning.set\": {\n          actions: [\"reposition\"]\n        }\n      }\n    }\n  },\n  implementations: {\n    guards: {\n      noVisibleTooltip: () => store.id === null,\n      isVisible: ({\n        prop\n      }) => prop(\"id\") === store.id,\n      isInteractive: ({\n        prop\n      }) => !!prop(\"interactive\"),\n      hasPointerMoveOpened: ({\n        context\n      }) => context.get(\"hasPointerMoveOpened\"),\n      isOpenControlled: ({\n        prop\n      }) => prop(\"open\") !== void 0\n    },\n    actions: {\n      setGlobalId: ({\n        prop\n      }) => {\n        store.id = prop(\"id\");\n      },\n      clearGlobalId: ({\n        prop\n      }) => {\n        if (prop(\"id\") === store.id) {\n          store.id = null;\n        }\n      },\n      invokeOnOpen: ({\n        prop\n      }) => {\n        prop(\"onOpenChange\")?.({\n          open: true\n        });\n      },\n      invokeOnClose: ({\n        prop\n      }) => {\n        prop(\"onOpenChange\")?.({\n          open: false\n        });\n      },\n      closeIfDisabled: ({\n        prop,\n        send\n      }) => {\n        if (!prop(\"disabled\")) return;\n        send({\n          type: \"close\",\n          src: \"disabled.change\"\n        });\n      },\n      reposition: ({\n        context,\n        event,\n        prop,\n        scope\n      }) => {\n        if (event.type !== \"positioning.set\") return;\n        const getPositionerEl2 = () => getPositionerEl(scope);\n        return getPlacement(getTriggerEl(scope), getPositionerEl2, {\n          ...prop(\"positioning\"),\n          ...event.options,\n          defer: true,\n          listeners: false,\n          onComplete(data) {\n            context.set(\"currentPlacement\", data.placement);\n          }\n        });\n      },\n      toggleVisibility: ({\n        prop,\n        event,\n        send\n      }) => {\n        queueMicrotask(() => {\n          send({\n            type: prop(\"open\") ? \"controlled.open\" : \"controlled.close\",\n            previousEvent: event\n          });\n        });\n      },\n      setPointerMoveOpened: ({\n        context\n      }) => {\n        context.set(\"hasPointerMoveOpened\", true);\n      },\n      clearPointerMoveOpened: ({\n        context\n      }) => {\n        context.set(\"hasPointerMoveOpened\", false);\n      }\n    },\n    effects: {\n      trackFocusVisible: ({\n        scope\n      }) => {\n        return trackFocusVisible({\n          root: scope.getRootNode?.()\n        });\n      },\n      trackPositioning: ({\n        context,\n        prop,\n        scope\n      }) => {\n        if (!context.get(\"currentPlacement\")) {\n          context.set(\"currentPlacement\", prop(\"positioning\").placement);\n        }\n        const getPositionerEl2 = () => getPositionerEl(scope);\n        return getPlacement(getTriggerEl(scope), getPositionerEl2, {\n          ...prop(\"positioning\"),\n          defer: true,\n          onComplete(data) {\n            context.set(\"currentPlacement\", data.placement);\n          }\n        });\n      },\n      trackPointerlockChange: ({\n        send,\n        scope\n      }) => {\n        const doc = scope.getDoc();\n        const onChange = () => send({\n          type: \"close\",\n          src: \"pointerlock:change\"\n        });\n        return addDomEvent(doc, \"pointerlockchange\", onChange, false);\n      },\n      trackScroll: ({\n        send,\n        prop,\n        scope\n      }) => {\n        if (!prop(\"closeOnScroll\")) return;\n        const triggerEl = getTriggerEl(scope);\n        if (!triggerEl) return;\n        const overflowParents = getOverflowAncestors(triggerEl);\n        const cleanups = overflowParents.map(overflowParent => {\n          const onScroll = () => {\n            send({\n              type: \"close\",\n              src: \"scroll\"\n            });\n          };\n          return addDomEvent(overflowParent, \"scroll\", onScroll, {\n            passive: true,\n            capture: true\n          });\n        });\n        return () => {\n          cleanups.forEach(fn => fn?.());\n        };\n      },\n      trackStore: ({\n        prop,\n        send\n      }) => {\n        let cleanup;\n        queueMicrotask(() => {\n          cleanup = subscribe(store, () => {\n            if (store.id !== prop(\"id\")) {\n              send({\n                type: \"close\",\n                src: \"id.change\"\n              });\n            }\n          });\n        });\n        return () => cleanup?.();\n      },\n      trackEscapeKey: ({\n        send,\n        prop\n      }) => {\n        if (!prop(\"closeOnEscape\")) return;\n        const onKeyDown = event => {\n          if (isComposingEvent(event)) return;\n          if (event.key !== \"Escape\") return;\n          event.stopPropagation();\n          send({\n            type: \"close\",\n            src: \"keydown.escape\"\n          });\n        };\n        return addDomEvent(document, \"keydown\", onKeyDown, true);\n      },\n      waitForOpenDelay: ({\n        send,\n        prop\n      }) => {\n        const id = setTimeout(() => {\n          send({\n            type: \"after.openDelay\"\n          });\n        }, prop(\"openDelay\"));\n        return () => clearTimeout(id);\n      },\n      waitForCloseDelay: ({\n        send,\n        prop\n      }) => {\n        const id = setTimeout(() => {\n          send({\n            type: \"after.closeDelay\"\n          });\n        }, prop(\"closeDelay\"));\n        return () => clearTimeout(id);\n      }\n    }\n  }\n});\nvar props = createProps()([\"aria-label\", \"closeDelay\", \"closeOnEscape\", \"closeOnPointerDown\", \"closeOnScroll\", \"closeOnClick\", \"dir\", \"disabled\", \"getRootNode\", \"id\", \"ids\", \"interactive\", \"onOpenChange\", \"defaultOpen\", \"open\", \"openDelay\", \"positioning\"]);\nvar splitProps = createSplitProps(props);\nexport { anatomy, connect, machine, props, splitProps };","map":null,"metadata":{},"sourceType":"module"}