{"ast":null,"code":"import { createAnatomy } from '@zag-js/anatomy';\nimport { dispatchInputCheckedEvent, setElementChecked, trackFormControl, trackPress, dataAttr, visuallyHiddenStyle, getEventTarget, isSafari } from '@zag-js/dom-query';\nimport { trackFocusVisible, isFocusVisible } from '@zag-js/focus-visible';\nimport { createGuards, createMachine } from '@zag-js/core';\nimport { createProps } from '@zag-js/types';\nimport { createSplitProps } from '@zag-js/utils';\n\n// src/switch.anatomy.ts\nvar anatomy = createAnatomy(\"switch\").parts(\"root\", \"label\", \"control\", \"thumb\");\nvar parts = anatomy.build();\n\n// src/switch.dom.ts\nvar getRootId = ctx => ctx.ids?.root ?? `switch:${ctx.id}`;\nvar getLabelId = ctx => ctx.ids?.label ?? `switch:${ctx.id}:label`;\nvar getThumbId = ctx => ctx.ids?.thumb ?? `switch:${ctx.id}:thumb`;\nvar getControlId = ctx => ctx.ids?.control ?? `switch:${ctx.id}:control`;\nvar getHiddenInputId = ctx => ctx.ids?.hiddenInput ?? `switch:${ctx.id}:input`;\nvar getRootEl = ctx => ctx.getById(getRootId(ctx));\nvar getHiddenInputEl = ctx => ctx.getById(getHiddenInputId(ctx));\n\n// src/switch.connect.ts\nfunction connect(service, normalize) {\n  const {\n    context,\n    send,\n    prop,\n    scope\n  } = service;\n  const disabled = prop(\"disabled\");\n  const readOnly = prop(\"readOnly\");\n  const checked = !!context.get(\"checked\");\n  const focused = !disabled && context.get(\"focused\");\n  const focusVisible = !disabled && context.get(\"focusVisible\");\n  const dataAttrs = {\n    \"data-active\": dataAttr(context.get(\"active\")),\n    \"data-focus\": dataAttr(focused),\n    \"data-focus-visible\": dataAttr(focusVisible),\n    \"data-readonly\": dataAttr(readOnly),\n    \"data-hover\": dataAttr(context.get(\"hovered\")),\n    \"data-disabled\": dataAttr(disabled),\n    \"data-state\": checked ? \"checked\" : \"unchecked\",\n    \"data-invalid\": dataAttr(prop(\"invalid\"))\n  };\n  return {\n    checked,\n    disabled,\n    focused,\n    setChecked(checked2) {\n      send({\n        type: \"CHECKED.SET\",\n        checked: checked2,\n        isTrusted: false\n      });\n    },\n    toggleChecked() {\n      send({\n        type: \"CHECKED.TOGGLE\",\n        checked,\n        isTrusted: false\n      });\n    },\n    getRootProps() {\n      return normalize.label({\n        ...parts.root.attrs,\n        ...dataAttrs,\n        dir: prop(\"dir\"),\n        id: getRootId(scope),\n        htmlFor: getHiddenInputId(scope),\n        onPointerMove() {\n          if (disabled) return;\n          send({\n            type: \"CONTEXT.SET\",\n            context: {\n              hovered: true\n            }\n          });\n        },\n        onPointerLeave() {\n          if (disabled) return;\n          send({\n            type: \"CONTEXT.SET\",\n            context: {\n              hovered: false\n            }\n          });\n        },\n        onClick(event) {\n          if (disabled) return;\n          const target = getEventTarget(event);\n          if (target === getHiddenInputEl(scope)) {\n            event.stopPropagation();\n          }\n          if (isSafari()) {\n            getHiddenInputEl(scope)?.focus();\n          }\n        }\n      });\n    },\n    getLabelProps() {\n      return normalize.element({\n        ...parts.label.attrs,\n        ...dataAttrs,\n        dir: prop(\"dir\"),\n        id: getLabelId(scope)\n      });\n    },\n    getThumbProps() {\n      return normalize.element({\n        ...parts.thumb.attrs,\n        ...dataAttrs,\n        dir: prop(\"dir\"),\n        id: getThumbId(scope),\n        \"aria-hidden\": true\n      });\n    },\n    getControlProps() {\n      return normalize.element({\n        ...parts.control.attrs,\n        ...dataAttrs,\n        dir: prop(\"dir\"),\n        id: getControlId(scope),\n        \"aria-hidden\": true\n      });\n    },\n    getHiddenInputProps() {\n      return normalize.input({\n        id: getHiddenInputId(scope),\n        type: \"checkbox\",\n        required: prop(\"required\"),\n        defaultChecked: checked,\n        disabled,\n        \"aria-labelledby\": getLabelId(scope),\n        \"aria-invalid\": prop(\"invalid\"),\n        name: prop(\"name\"),\n        form: prop(\"form\"),\n        value: prop(\"value\"),\n        style: visuallyHiddenStyle,\n        onFocus() {\n          const focusVisible2 = isFocusVisible();\n          send({\n            type: \"CONTEXT.SET\",\n            context: {\n              focused: true,\n              focusVisible: focusVisible2\n            }\n          });\n        },\n        onBlur() {\n          send({\n            type: \"CONTEXT.SET\",\n            context: {\n              focused: false,\n              focusVisible: false\n            }\n          });\n        },\n        onClick(event) {\n          if (readOnly) {\n            event.preventDefault();\n            return;\n          }\n          const checked2 = event.currentTarget.checked;\n          send({\n            type: \"CHECKED.SET\",\n            checked: checked2,\n            isTrusted: true\n          });\n        }\n      });\n    }\n  };\n}\nvar {\n  not\n} = createGuards();\nvar machine = createMachine({\n  props({\n    props: props2\n  }) {\n    return {\n      defaultChecked: false,\n      label: \"switch\",\n      value: \"on\",\n      ...props2\n    };\n  },\n  initialState() {\n    return \"ready\";\n  },\n  context({\n    prop,\n    bindable\n  }) {\n    return {\n      checked: bindable(() => ({\n        defaultValue: prop(\"defaultChecked\"),\n        value: prop(\"checked\"),\n        onChange(value) {\n          prop(\"onCheckedChange\")?.({\n            checked: value\n          });\n        }\n      })),\n      fieldsetDisabled: bindable(() => ({\n        defaultValue: false\n      })),\n      focusVisible: bindable(() => ({\n        defaultValue: false\n      })),\n      active: bindable(() => ({\n        defaultValue: false\n      })),\n      focused: bindable(() => ({\n        defaultValue: false\n      })),\n      hovered: bindable(() => ({\n        defaultValue: false\n      }))\n    };\n  },\n  computed: {\n    isDisabled: ({\n      context,\n      prop\n    }) => prop(\"disabled\") || context.get(\"fieldsetDisabled\")\n  },\n  watch({\n    track,\n    prop,\n    context,\n    action\n  }) {\n    track([() => prop(\"disabled\")], () => {\n      action([\"removeFocusIfNeeded\"]);\n    });\n    track([() => context.get(\"checked\")], () => {\n      action([\"syncInputElement\"]);\n    });\n  },\n  effects: [\"trackFormControlState\", \"trackPressEvent\", \"trackFocusVisible\"],\n  on: {\n    \"CHECKED.TOGGLE\": [{\n      guard: not(\"isTrusted\"),\n      actions: [\"toggleChecked\", \"dispatchChangeEvent\"]\n    }, {\n      actions: [\"toggleChecked\"]\n    }],\n    \"CHECKED.SET\": [{\n      guard: not(\"isTrusted\"),\n      actions: [\"setChecked\", \"dispatchChangeEvent\"]\n    }, {\n      actions: [\"setChecked\"]\n    }],\n    \"CONTEXT.SET\": {\n      actions: [\"setContext\"]\n    }\n  },\n  states: {\n    ready: {}\n  },\n  implementations: {\n    guards: {\n      isTrusted: ({\n        event\n      }) => !!event.isTrusted\n    },\n    effects: {\n      trackPressEvent({\n        computed,\n        scope,\n        context\n      }) {\n        if (computed(\"isDisabled\")) return;\n        return trackPress({\n          pointerNode: getRootEl(scope),\n          keyboardNode: getHiddenInputEl(scope),\n          isValidKey: event => event.key === \" \",\n          onPress: () => context.set(\"active\", false),\n          onPressStart: () => context.set(\"active\", true),\n          onPressEnd: () => context.set(\"active\", false)\n        });\n      },\n      trackFocusVisible({\n        computed,\n        scope\n      }) {\n        if (computed(\"isDisabled\")) return;\n        return trackFocusVisible({\n          root: scope.getRootNode()\n        });\n      },\n      trackFormControlState({\n        context,\n        send,\n        scope\n      }) {\n        return trackFormControl(getHiddenInputEl(scope), {\n          onFieldsetDisabledChange(disabled) {\n            context.set(\"fieldsetDisabled\", disabled);\n          },\n          onFormReset() {\n            const checked = context.initial(\"checked\");\n            send({\n              type: \"CHECKED.SET\",\n              checked: !!checked,\n              src: \"form-reset\"\n            });\n          }\n        });\n      }\n    },\n    actions: {\n      setContext({\n        context,\n        event\n      }) {\n        for (const key in event.context) {\n          context.set(key, event.context[key]);\n        }\n      },\n      syncInputElement({\n        context,\n        scope\n      }) {\n        const inputEl = getHiddenInputEl(scope);\n        if (!inputEl) return;\n        setElementChecked(inputEl, !!context.get(\"checked\"));\n      },\n      removeFocusIfNeeded({\n        context,\n        prop\n      }) {\n        if (prop(\"disabled\")) {\n          context.set(\"focused\", false);\n        }\n      },\n      setChecked({\n        context,\n        event\n      }) {\n        context.set(\"checked\", event.checked);\n      },\n      toggleChecked({\n        context\n      }) {\n        context.set(\"checked\", !context.get(\"checked\"));\n      },\n      dispatchChangeEvent({\n        context,\n        scope\n      }) {\n        const inputEl = getHiddenInputEl(scope);\n        dispatchInputCheckedEvent(inputEl, {\n          checked: context.get(\"checked\")\n        });\n      }\n    }\n  }\n});\nvar props = createProps()([\"checked\", \"defaultChecked\", \"dir\", \"disabled\", \"form\", \"getRootNode\", \"id\", \"ids\", \"invalid\", \"label\", \"name\", \"onCheckedChange\", \"readOnly\", \"required\", \"value\"]);\nvar splitProps = createSplitProps(props);\nexport { anatomy, connect, machine, props, splitProps };","map":null,"metadata":{},"sourceType":"module"}