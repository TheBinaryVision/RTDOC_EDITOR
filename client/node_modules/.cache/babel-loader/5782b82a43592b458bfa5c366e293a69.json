{"ast":null,"code":"import { createAnatomy } from '@zag-js/anatomy';\nimport { TreeCollection, filePathToTree } from '@zag-js/collection';\nimport { getByTypeahead, dataAttr, isComposingEvent, getEventTarget, isEditableElement, getEventKey, isModifierKey } from '@zag-js/dom-query';\nimport { first, uniq, addOrRemove, remove, add, isEqual, createSplitProps } from '@zag-js/utils';\nimport { createGuards, createMachine } from '@zag-js/core';\nimport { createProps } from '@zag-js/types';\n\n// src/tree-view.anatomy.ts\nvar anatomy = createAnatomy(\"tree-view\").parts(\"root\", \"label\", \"tree\", \"item\", \"itemIndicator\", \"itemText\", \"branch\", \"branchControl\", \"branchTrigger\", \"branchContent\", \"branchText\", \"branchIndicator\", \"branchIndentGuide\");\nvar parts = anatomy.build();\nvar collection = options => {\n  return new TreeCollection(options);\n};\ncollection.empty = () => {\n  return new TreeCollection({\n    rootNode: {\n      children: []\n    }\n  });\n};\nfunction filePathCollection(paths) {\n  return filePathToTree(paths);\n}\n\n// src/tree-view.dom.ts\nvar getRootId = ctx => ctx.ids?.root ?? `tree:${ctx.id}:root`;\nvar getLabelId = ctx => ctx.ids?.label ?? `tree:${ctx.id}:label`;\nvar getNodeId = (ctx, value) => ctx.ids?.node?.(value) ?? `tree:${ctx.id}:node:${value}`;\nvar getTreeId = ctx => ctx.ids?.tree ?? `tree:${ctx.id}:tree`;\nvar focusNode = (ctx, value) => {\n  if (value == null) return;\n  const nodeId = getNodeId(ctx, value);\n  ctx.getById(nodeId)?.focus({\n    preventScroll: true\n  });\n};\n\n// src/tree-view.utils.ts\nfunction skipFn(params) {\n  const {\n    prop,\n    context\n  } = params;\n  return function skip({\n    indexPath\n  }) {\n    const paths = prop(\"collection\").getValuePath(indexPath).slice(0, -1);\n    return paths.some(value => !context.get(\"expandedValue\").includes(value));\n  };\n}\nfunction getVisibleNodes(params) {\n  const {\n    prop\n  } = params;\n  const nodes = [];\n  prop(\"collection\").visit({\n    skip: skipFn(params),\n    onEnter: (node, indexPath) => {\n      nodes.push({\n        node,\n        indexPath\n      });\n    }\n  });\n  return nodes;\n}\n\n// src/tree-view.connect.ts\nfunction connect(service, normalize) {\n  const {\n    context,\n    scope,\n    computed,\n    prop,\n    send\n  } = service;\n  const collection2 = prop(\"collection\");\n  const expandedValue = Array.from(context.get(\"expandedValue\"));\n  const selectedValue = Array.from(context.get(\"selectedValue\"));\n  const isTypingAhead = computed(\"isTypingAhead\");\n  const focusedValue = context.get(\"focusedValue\");\n  function getNodeState(props2) {\n    const {\n      node,\n      indexPath\n    } = props2;\n    const value = collection2.getNodeValue(node);\n    return {\n      value,\n      valuePath: collection2.getValuePath(indexPath),\n      disabled: Boolean(node.disabled),\n      focused: focusedValue == null ? isEqual(indexPath, [0]) : focusedValue === value,\n      selected: selectedValue.includes(value),\n      expanded: expandedValue.includes(value),\n      depth: indexPath.length,\n      isBranch: collection2.isBranchNode(node)\n    };\n  }\n  return {\n    collection: collection2,\n    expandedValue,\n    selectedValue,\n    expand(value) {\n      if (!value) return send({\n        type: \"EXPANDED.ALL\"\n      });\n      const _expandedValue = uniq(expandedValue.concat(...value));\n      send({\n        type: \"EXPANDED.SET\",\n        value: _expandedValue,\n        src: \"expand\"\n      });\n    },\n    collapse(value) {\n      if (!value) return send({\n        type: \"EXPANDED.SET\",\n        value: [],\n        src: \"collapseAll\"\n      });\n      const _expandedValue = uniq(remove(expandedValue, ...value));\n      send({\n        type: \"EXPANDED.SET\",\n        value: _expandedValue,\n        src: \"collapse\"\n      });\n    },\n    deselect(value) {\n      if (!value) return send({\n        type: \"SELECTED.SET\",\n        value: [],\n        src: \"deselectAll\"\n      });\n      const _selectedValue = uniq(remove(selectedValue, ...value));\n      send({\n        type: \"SELECTED.SET\",\n        value: _selectedValue,\n        src: \"deselect\"\n      });\n    },\n    select(value) {\n      if (!value) return send({\n        type: \"SELECTED.ALL\"\n      });\n      const nextValue = [];\n      if (prop(\"selectionMode\") === \"single\") {\n        if (value.length > 0) nextValue.push(value[value.length - 1]);\n      } else {\n        nextValue.push(...selectedValue, ...value);\n      }\n      send({\n        type: \"SELECTED.SET\",\n        value: nextValue,\n        src: \"select\"\n      });\n    },\n    getVisibleNodes() {\n      return getVisibleNodes(service);\n    },\n    focus(value) {\n      focusNode(scope, value);\n    },\n    selectParent(value) {\n      const parentNode = collection2.getParentNode(value);\n      if (!parentNode) return;\n      const _selectedValue = add(selectedValue, collection2.getNodeValue(parentNode));\n      send({\n        type: \"SELECTED.SET\",\n        value: _selectedValue,\n        src: \"select.parent\"\n      });\n    },\n    expandParent(value) {\n      const parentNode = collection2.getParentNode(value);\n      if (!parentNode) return;\n      const _expandedValue = add(expandedValue, collection2.getNodeValue(parentNode));\n      send({\n        type: \"EXPANDED.SET\",\n        value: _expandedValue,\n        src: \"expand.parent\"\n      });\n    },\n    setExpandedValue(value) {\n      const _expandedValue = uniq(value);\n      send({\n        type: \"EXPANDED.SET\",\n        value: _expandedValue\n      });\n    },\n    setSelectedValue(value) {\n      const _selectedValue = uniq(value);\n      send({\n        type: \"SELECTED.SET\",\n        value: _selectedValue\n      });\n    },\n    getRootProps() {\n      return normalize.element({\n        ...parts.root.attrs,\n        id: getRootId(scope),\n        dir: prop(\"dir\")\n      });\n    },\n    getLabelProps() {\n      return normalize.element({\n        ...parts.label.attrs,\n        id: getLabelId(scope),\n        dir: prop(\"dir\")\n      });\n    },\n    getTreeProps() {\n      return normalize.element({\n        ...parts.tree.attrs,\n        id: getTreeId(scope),\n        dir: prop(\"dir\"),\n        role: \"tree\",\n        \"aria-label\": \"Tree View\",\n        \"aria-labelledby\": getLabelId(scope),\n        \"aria-multiselectable\": prop(\"selectionMode\") === \"multiple\" || void 0,\n        tabIndex: -1,\n        onKeyDown(event) {\n          if (event.defaultPrevented) return;\n          if (isComposingEvent(event)) return;\n          const target = getEventTarget(event);\n          if (isEditableElement(target)) return;\n          const node = target?.closest(\"[data-part=branch-control], [data-part=item]\");\n          if (!node) return;\n          const nodeId = node.dataset.value;\n          if (nodeId == null) {\n            console.warn(`[zag-js/tree-view] Node id not found for node`, node);\n            return;\n          }\n          const isBranchNode = node.matches(\"[data-part=branch-control]\");\n          const keyMap = {\n            ArrowDown(event2) {\n              if (isModifierKey(event2)) return;\n              event2.preventDefault();\n              send({\n                type: \"NODE.ARROW_DOWN\",\n                id: nodeId,\n                shiftKey: event2.shiftKey\n              });\n            },\n            ArrowUp(event2) {\n              if (isModifierKey(event2)) return;\n              event2.preventDefault();\n              send({\n                type: \"NODE.ARROW_UP\",\n                id: nodeId,\n                shiftKey: event2.shiftKey\n              });\n            },\n            ArrowLeft(event2) {\n              if (isModifierKey(event2) || node.dataset.disabled) return;\n              event2.preventDefault();\n              send({\n                type: isBranchNode ? \"BRANCH_NODE.ARROW_LEFT\" : \"NODE.ARROW_LEFT\",\n                id: nodeId\n              });\n            },\n            ArrowRight(event2) {\n              if (!isBranchNode || node.dataset.disabled) return;\n              event2.preventDefault();\n              send({\n                type: \"BRANCH_NODE.ARROW_RIGHT\",\n                id: nodeId\n              });\n            },\n            Home(event2) {\n              if (isModifierKey(event2)) return;\n              event2.preventDefault();\n              send({\n                type: \"NODE.HOME\",\n                id: nodeId,\n                shiftKey: event2.shiftKey\n              });\n            },\n            End(event2) {\n              if (isModifierKey(event2)) return;\n              event2.preventDefault();\n              send({\n                type: \"NODE.END\",\n                id: nodeId,\n                shiftKey: event2.shiftKey\n              });\n            },\n            Space(event2) {\n              if (node.dataset.disabled) return;\n              if (isTypingAhead) {\n                send({\n                  type: \"TREE.TYPEAHEAD\",\n                  key: event2.key\n                });\n              } else {\n                keyMap.Enter?.(event2);\n              }\n            },\n            Enter(event2) {\n              if (node.dataset.disabled) return;\n              const isLink = target?.closest(\"a[href]\");\n              if (!isLink) event2.preventDefault();\n              send({\n                type: isBranchNode ? \"BRANCH_NODE.CLICK\" : \"NODE.CLICK\",\n                id: nodeId,\n                src: \"keyboard\"\n              });\n            },\n            \"*\"(event2) {\n              if (node.dataset.disabled) return;\n              event2.preventDefault();\n              send({\n                type: \"SIBLINGS.EXPAND\",\n                id: nodeId\n              });\n            },\n            a(event2) {\n              if (!event2.metaKey || node.dataset.disabled) return;\n              event2.preventDefault();\n              send({\n                type: \"SELECTED.ALL\",\n                moveFocus: true\n              });\n            }\n          };\n          const key = getEventKey(event, {\n            dir: prop(\"dir\")\n          });\n          const exec = keyMap[key];\n          if (exec) {\n            exec(event);\n            return;\n          }\n          if (!isTypingAhead) return;\n          const isValidTypeahead = event.key.length === 1 && !isModifierKey(event);\n          if (!isValidTypeahead) return;\n          send({\n            type: \"TREE.TYPEAHEAD\",\n            key: event.key,\n            id: nodeId\n          });\n          event.preventDefault();\n        }\n      });\n    },\n    getNodeState,\n    getItemProps(props2) {\n      const itemState = getNodeState(props2);\n      return normalize.element({\n        ...parts.item.attrs,\n        id: getNodeId(scope, itemState.value),\n        dir: prop(\"dir\"),\n        \"data-ownedby\": getTreeId(scope),\n        \"data-path\": props2.indexPath.join(\"/\"),\n        \"data-value\": itemState.value,\n        tabIndex: itemState.focused ? 0 : -1,\n        \"data-focus\": dataAttr(itemState.focused),\n        role: \"treeitem\",\n        \"aria-current\": itemState.selected ? \"true\" : void 0,\n        \"aria-selected\": itemState.disabled ? void 0 : itemState.selected,\n        \"data-selected\": dataAttr(itemState.selected),\n        \"aria-disabled\": itemState.disabled,\n        \"data-disabled\": dataAttr(itemState.disabled),\n        \"aria-level\": itemState.depth,\n        \"data-depth\": itemState.depth,\n        style: {\n          \"--depth\": itemState.depth\n        },\n        onFocus(event) {\n          event.stopPropagation();\n          send({\n            type: \"NODE.FOCUS\",\n            id: itemState.value\n          });\n        },\n        onClick(event) {\n          if (itemState.disabled) return;\n          const isMetaKey = event.metaKey || event.ctrlKey;\n          send({\n            type: \"NODE.CLICK\",\n            id: itemState.value,\n            shiftKey: event.shiftKey,\n            ctrlKey: isMetaKey\n          });\n          event.stopPropagation();\n          const isLink = event.currentTarget.matches(\"a[href]\");\n          if (!isLink) event.preventDefault();\n        }\n      });\n    },\n    getItemTextProps(props2) {\n      const itemState = getNodeState(props2);\n      return normalize.element({\n        ...parts.itemText.attrs,\n        \"data-disabled\": dataAttr(itemState.disabled),\n        \"data-selected\": dataAttr(itemState.selected),\n        \"data-focus\": dataAttr(itemState.focused)\n      });\n    },\n    getItemIndicatorProps(props2) {\n      const itemState = getNodeState(props2);\n      return normalize.element({\n        ...parts.itemIndicator.attrs,\n        \"aria-hidden\": true,\n        \"data-disabled\": dataAttr(itemState.disabled),\n        \"data-selected\": dataAttr(itemState.selected),\n        \"data-focus\": dataAttr(itemState.focused),\n        hidden: !itemState.selected\n      });\n    },\n    getBranchProps(props2) {\n      const nodeState = getNodeState(props2);\n      return normalize.element({\n        ...parts.branch.attrs,\n        \"data-depth\": nodeState.depth,\n        dir: prop(\"dir\"),\n        \"data-branch\": nodeState.value,\n        role: \"treeitem\",\n        \"data-ownedby\": getTreeId(scope),\n        \"data-value\": nodeState.value,\n        \"aria-level\": nodeState.depth,\n        \"aria-selected\": nodeState.disabled ? void 0 : nodeState.selected,\n        \"data-path\": props2.indexPath.join(\"/\"),\n        \"data-selected\": dataAttr(nodeState.selected),\n        \"aria-expanded\": nodeState.expanded,\n        \"data-state\": nodeState.expanded ? \"open\" : \"closed\",\n        \"aria-disabled\": nodeState.disabled,\n        \"data-disabled\": dataAttr(nodeState.disabled),\n        style: {\n          \"--depth\": nodeState.depth\n        }\n      });\n    },\n    getBranchIndicatorProps(props2) {\n      const nodeState = getNodeState(props2);\n      return normalize.element({\n        ...parts.branchIndicator.attrs,\n        \"aria-hidden\": true,\n        \"data-state\": nodeState.expanded ? \"open\" : \"closed\",\n        \"data-disabled\": dataAttr(nodeState.disabled),\n        \"data-selected\": dataAttr(nodeState.selected),\n        \"data-focus\": dataAttr(nodeState.focused)\n      });\n    },\n    getBranchTriggerProps(props2) {\n      const nodeState = getNodeState(props2);\n      return normalize.element({\n        ...parts.branchTrigger.attrs,\n        role: \"button\",\n        dir: prop(\"dir\"),\n        \"data-disabled\": dataAttr(nodeState.disabled),\n        \"data-state\": nodeState.expanded ? \"open\" : \"closed\",\n        \"data-value\": nodeState.value,\n        onClick(event) {\n          if (nodeState.disabled) return;\n          send({\n            type: \"BRANCH_TOGGLE.CLICK\",\n            id: nodeState.value\n          });\n          event.stopPropagation();\n        }\n      });\n    },\n    getBranchControlProps(props2) {\n      const nodeState = getNodeState(props2);\n      return normalize.element({\n        ...parts.branchControl.attrs,\n        role: \"button\",\n        id: getNodeId(scope, nodeState.value),\n        dir: prop(\"dir\"),\n        tabIndex: nodeState.focused ? 0 : -1,\n        \"data-path\": props2.indexPath.join(\"/\"),\n        \"data-state\": nodeState.expanded ? \"open\" : \"closed\",\n        \"data-disabled\": dataAttr(nodeState.disabled),\n        \"data-selected\": dataAttr(nodeState.selected),\n        \"data-focus\": dataAttr(nodeState.focused),\n        \"data-value\": nodeState.value,\n        \"data-depth\": nodeState.depth,\n        onFocus(event) {\n          send({\n            type: \"NODE.FOCUS\",\n            id: nodeState.value\n          });\n          event.stopPropagation();\n        },\n        onClick(event) {\n          if (nodeState.disabled) return;\n          const isMetaKey = event.metaKey || event.ctrlKey;\n          send({\n            type: \"BRANCH_NODE.CLICK\",\n            id: nodeState.value,\n            shiftKey: event.shiftKey,\n            ctrlKey: isMetaKey\n          });\n          event.stopPropagation();\n        }\n      });\n    },\n    getBranchTextProps(props2) {\n      const nodeState = getNodeState(props2);\n      return normalize.element({\n        ...parts.branchText.attrs,\n        dir: prop(\"dir\"),\n        \"data-disabled\": dataAttr(nodeState.disabled),\n        \"data-state\": nodeState.expanded ? \"open\" : \"closed\"\n      });\n    },\n    getBranchContentProps(props2) {\n      const nodeState = getNodeState(props2);\n      return normalize.element({\n        ...parts.branchContent.attrs,\n        role: \"group\",\n        dir: prop(\"dir\"),\n        \"data-state\": nodeState.expanded ? \"open\" : \"closed\",\n        \"data-depth\": nodeState.depth,\n        \"data-path\": props2.indexPath.join(\"/\"),\n        \"data-value\": nodeState.value,\n        hidden: !nodeState.expanded\n      });\n    },\n    getBranchIndentGuideProps(props2) {\n      const nodeState = getNodeState(props2);\n      return normalize.element({\n        ...parts.branchIndentGuide.attrs,\n        \"data-depth\": nodeState.depth\n      });\n    }\n  };\n}\nvar {\n  and\n} = createGuards();\nvar machine = createMachine({\n  props({\n    props: props2\n  }) {\n    return {\n      selectionMode: \"single\",\n      collection: collection.empty(),\n      typeahead: true,\n      expandOnClick: true,\n      defaultExpandedValue: [],\n      defaultSelectedValue: [],\n      ...props2\n    };\n  },\n  initialState() {\n    return \"idle\";\n  },\n  context({\n    prop,\n    bindable,\n    getContext\n  }) {\n    return {\n      expandedValue: bindable(() => ({\n        defaultValue: prop(\"defaultExpandedValue\"),\n        value: prop(\"expandedValue\"),\n        isEqual: isEqual,\n        onChange(value) {\n          const ctx = getContext();\n          const focusedValue = ctx.get(\"focusedValue\");\n          prop(\"onExpandedChange\")?.({\n            expandedValue: value,\n            focusedValue\n          });\n        }\n      })),\n      selectedValue: bindable(() => ({\n        defaultValue: prop(\"defaultSelectedValue\"),\n        value: prop(\"selectedValue\"),\n        isEqual: isEqual,\n        onChange(value) {\n          const ctx = getContext();\n          const focusedValue = ctx.get(\"focusedValue\");\n          prop(\"onSelectionChange\")?.({\n            selectedValue: value,\n            focusedValue\n          });\n        }\n      })),\n      focusedValue: bindable(() => ({\n        defaultValue: prop(\"focusedValue\"),\n        onChange(value) {\n          prop(\"onFocusChange\")?.({\n            focusedValue: value\n          });\n        }\n      }))\n    };\n  },\n  refs() {\n    return {\n      typeaheadState: {\n        ...getByTypeahead.defaultOptions\n      }\n    };\n  },\n  computed: {\n    isMultipleSelection: ({\n      prop\n    }) => prop(\"selectionMode\") === \"multiple\",\n    isTypingAhead: ({\n      refs\n    }) => refs.get(\"typeaheadState\").keysSoFar.length > 0\n  },\n  on: {\n    \"EXPANDED.SET\": {\n      actions: [\"setExpanded\"]\n    },\n    \"SELECTED.SET\": {\n      actions: [\"setSelected\"]\n    },\n    \"SELECTED.ALL\": [{\n      guard: and(\"isMultipleSelection\", \"moveFocus\"),\n      actions: [\"selectAllNodes\", \"focusTreeLastNode\"]\n    }, {\n      guard: \"isMultipleSelection\",\n      actions: [\"selectAllNodes\"]\n    }],\n    \"EXPANDED.ALL\": {\n      actions: [\"expandAllBranches\"]\n    }\n  },\n  states: {\n    idle: {\n      on: {\n        \"NODE.FOCUS\": {\n          actions: [\"setFocusedNode\"]\n        },\n        \"NODE.ARROW_DOWN\": [{\n          guard: and(\"isShiftKey\", \"isMultipleSelection\"),\n          actions: [\"focusTreeNextNode\", \"extendSelectionToNextNode\"]\n        }, {\n          actions: [\"focusTreeNextNode\"]\n        }],\n        \"NODE.ARROW_UP\": [{\n          guard: and(\"isShiftKey\", \"isMultipleSelection\"),\n          actions: [\"focusTreePrevNode\", \"extendSelectionToPrevNode\"]\n        }, {\n          actions: [\"focusTreePrevNode\"]\n        }],\n        \"NODE.ARROW_LEFT\": {\n          actions: [\"focusBranchNode\"]\n        },\n        \"BRANCH_NODE.ARROW_LEFT\": [{\n          guard: \"isBranchExpanded\",\n          actions: [\"collapseBranch\"]\n        }, {\n          actions: [\"focusBranchNode\"]\n        }],\n        \"BRANCH_NODE.ARROW_RIGHT\": [{\n          guard: and(\"isBranchFocused\", \"isBranchExpanded\"),\n          actions: [\"focusBranchFirstNode\"]\n        }, {\n          actions: [\"expandBranch\"]\n        }],\n        \"SIBLINGS.EXPAND\": {\n          actions: [\"expandSiblingBranches\"]\n        },\n        \"NODE.HOME\": [{\n          guard: and(\"isShiftKey\", \"isMultipleSelection\"),\n          actions: [\"extendSelectionToFirstNode\", \"focusTreeFirstNode\"]\n        }, {\n          actions: [\"focusTreeFirstNode\"]\n        }],\n        \"NODE.END\": [{\n          guard: and(\"isShiftKey\", \"isMultipleSelection\"),\n          actions: [\"extendSelectionToLastNode\", \"focusTreeLastNode\"]\n        }, {\n          actions: [\"focusTreeLastNode\"]\n        }],\n        \"NODE.CLICK\": [{\n          guard: and(\"isCtrlKey\", \"isMultipleSelection\"),\n          actions: [\"toggleNodeSelection\"]\n        }, {\n          guard: and(\"isShiftKey\", \"isMultipleSelection\"),\n          actions: [\"extendSelectionToNode\"]\n        }, {\n          actions: [\"selectNode\"]\n        }],\n        \"BRANCH_NODE.CLICK\": [{\n          guard: and(\"isCtrlKey\", \"isMultipleSelection\"),\n          actions: [\"toggleNodeSelection\"]\n        }, {\n          guard: and(\"isShiftKey\", \"isMultipleSelection\"),\n          actions: [\"extendSelectionToNode\"]\n        }, {\n          guard: \"openOnClick\",\n          actions: [\"selectNode\", \"toggleBranchNode\"]\n        }, {\n          actions: [\"selectNode\"]\n        }],\n        \"BRANCH_TOGGLE.CLICK\": {\n          actions: [\"toggleBranchNode\"]\n        },\n        \"TREE.TYPEAHEAD\": {\n          actions: [\"focusMatchedNode\"]\n        }\n      }\n    }\n  },\n  implementations: {\n    guards: {\n      isBranchFocused: ({\n        context,\n        event\n      }) => context.get(\"focusedValue\") === event.id,\n      isBranchExpanded: ({\n        context,\n        event\n      }) => context.get(\"expandedValue\").includes(event.id),\n      isShiftKey: ({\n        event\n      }) => event.shiftKey,\n      isCtrlKey: ({\n        event\n      }) => event.ctrlKey,\n      hasSelectedItems: ({\n        context\n      }) => context.get(\"selectedValue\").length > 0,\n      isMultipleSelection: ({\n        prop\n      }) => prop(\"selectionMode\") === \"multiple\",\n      moveFocus: ({\n        event\n      }) => !!event.moveFocus,\n      openOnClick: ({\n        prop\n      }) => !!prop(\"expandOnClick\")\n    },\n    actions: {\n      selectNode({\n        context,\n        event\n      }) {\n        context.set(\"selectedValue\", [event.id]);\n      },\n      setFocusedNode({\n        context,\n        event\n      }) {\n        context.set(\"focusedValue\", event.id);\n      },\n      clearFocusedNode({\n        context\n      }) {\n        context.set(\"focusedValue\", null);\n      },\n      clearSelectedItem({\n        context\n      }) {\n        context.set(\"selectedValue\", []);\n      },\n      toggleBranchNode({\n        context,\n        event\n      }) {\n        context.set(\"expandedValue\", prev => addOrRemove(prev, event.id));\n      },\n      expandBranch({\n        context,\n        event\n      }) {\n        context.set(\"expandedValue\", prev => add(prev, event.id));\n      },\n      collapseBranch({\n        context,\n        event\n      }) {\n        context.set(\"expandedValue\", prev => remove(prev, event.id));\n      },\n      setExpanded({\n        context,\n        event\n      }) {\n        context.set(\"expandedValue\", event.value);\n      },\n      setSelected({\n        context,\n        event\n      }) {\n        context.set(\"selectedValue\", event.value);\n      },\n      focusTreeFirstNode({\n        prop,\n        scope\n      }) {\n        const collection2 = prop(\"collection\");\n        const firstNode = collection2.getFirstNode();\n        const firstValue = collection2.getNodeValue(firstNode);\n        focusNode(scope, firstValue);\n      },\n      focusTreeLastNode({\n        prop,\n        scope\n      }) {\n        const collection2 = prop(\"collection\");\n        const lastNode = collection2.getLastNode();\n        const lastValue = collection2.getNodeValue(lastNode);\n        focusNode(scope, lastValue);\n      },\n      focusBranchFirstNode({\n        event,\n        prop,\n        scope\n      }) {\n        const collection2 = prop(\"collection\");\n        const branchNode = collection2.findNode(event.id);\n        const firstNode = collection2.getFirstNode(branchNode);\n        const firstValue = collection2.getNodeValue(firstNode);\n        focusNode(scope, firstValue);\n      },\n      focusTreeNextNode(params) {\n        const {\n          event,\n          prop,\n          scope\n        } = params;\n        const collection2 = prop(\"collection\");\n        const nextNode = collection2.getNextNode(event.id, {\n          skip: skipFn(params)\n        });\n        if (!nextNode) return;\n        const nextValue = collection2.getNodeValue(nextNode);\n        focusNode(scope, nextValue);\n      },\n      focusTreePrevNode(params) {\n        const {\n          event,\n          prop,\n          scope\n        } = params;\n        const collection2 = prop(\"collection\");\n        const prevNode = collection2.getPreviousNode(event.id, {\n          skip: skipFn(params)\n        });\n        if (!prevNode) return;\n        const prevValue = collection2.getNodeValue(prevNode);\n        focusNode(scope, prevValue);\n      },\n      focusBranchNode({\n        event,\n        prop,\n        scope\n      }) {\n        const collection2 = prop(\"collection\");\n        const parentNode = collection2.getParentNode(event.id);\n        const parentValue = parentNode ? collection2.getNodeValue(parentNode) : void 0;\n        focusNode(scope, parentValue);\n      },\n      selectAllNodes({\n        context,\n        prop\n      }) {\n        context.set(\"selectedValue\", prop(\"collection\").getValues());\n      },\n      focusMatchedNode(params) {\n        const {\n          context,\n          prop,\n          refs,\n          event,\n          scope\n        } = params;\n        const nodes = getVisibleNodes(params);\n        const elements = nodes.map(({\n          node: node2\n        }) => ({\n          textContent: prop(\"collection\").stringifyNode(node2),\n          id: prop(\"collection\").getNodeValue(node2)\n        }));\n        const node = getByTypeahead(elements, {\n          state: refs.get(\"typeaheadState\"),\n          activeId: context.get(\"focusedValue\"),\n          key: event.key\n        });\n        focusNode(scope, node?.id);\n      },\n      toggleNodeSelection({\n        context,\n        event\n      }) {\n        const selectedValue = addOrRemove(context.get(\"selectedValue\"), event.id);\n        context.set(\"selectedValue\", selectedValue);\n      },\n      expandAllBranches({\n        context,\n        prop\n      }) {\n        const nextValue = prop(\"collection\").getBranchValues();\n        context.set(\"expandedValue\", nextValue);\n      },\n      expandSiblingBranches({\n        context,\n        event,\n        prop\n      }) {\n        const collection2 = prop(\"collection\");\n        const indexPath = collection2.getIndexPath(event.id);\n        if (!indexPath) return;\n        const nodes = collection2.getSiblingNodes(indexPath);\n        const values = nodes.map(node => collection2.getNodeValue(node));\n        context.set(\"expandedValue\", uniq(values));\n      },\n      extendSelectionToNode(params) {\n        const {\n          context,\n          event,\n          prop\n        } = params;\n        const collection2 = prop(\"collection\");\n        const anchorValue = first(context.get(\"selectedValue\")) || collection2.getNodeValue(collection2.getFirstNode());\n        const targetValue = event.id;\n        let values = [anchorValue, targetValue];\n        let hits = 0;\n        const visibleNodes = getVisibleNodes(params);\n        visibleNodes.forEach(({\n          node\n        }) => {\n          const nodeValue = collection2.getNodeValue(node);\n          if (hits === 1) values.push(nodeValue);\n          if (nodeValue === anchorValue || nodeValue === targetValue) hits++;\n        });\n        context.set(\"selectedValue\", uniq(values));\n      },\n      extendSelectionToNextNode(params) {\n        const {\n          context,\n          event,\n          prop\n        } = params;\n        const collection2 = prop(\"collection\");\n        const nextNode = collection2.getNextNode(event.id, {\n          skip: skipFn(params)\n        });\n        if (!nextNode) return;\n        const values = new Set(context.get(\"selectedValue\"));\n        const nextValue = collection2.getNodeValue(nextNode);\n        if (nextValue == null) return;\n        if (values.has(event.id) && values.has(nextValue)) {\n          values.delete(event.id);\n        } else if (!values.has(nextValue)) {\n          values.add(nextValue);\n        }\n        context.set(\"selectedValue\", Array.from(values));\n      },\n      extendSelectionToPrevNode(params) {\n        const {\n          context,\n          event,\n          prop\n        } = params;\n        const collection2 = prop(\"collection\");\n        const prevNode = collection2.getPreviousNode(event.id, {\n          skip: skipFn(params)\n        });\n        if (!prevNode) return;\n        const values = new Set(context.get(\"selectedValue\"));\n        const prevValue = collection2.getNodeValue(prevNode);\n        if (prevValue == null) return;\n        if (values.has(event.id) && values.has(prevValue)) {\n          values.delete(event.id);\n        } else if (!values.has(prevValue)) {\n          values.add(prevValue);\n        }\n        context.set(\"selectedValue\", Array.from(values));\n      },\n      extendSelectionToFirstNode(params) {\n        const {\n          context,\n          prop\n        } = params;\n        const collection2 = prop(\"collection\");\n        const currentSelection = first(context.get(\"selectedValue\"));\n        const values = [];\n        collection2.visit({\n          skip: skipFn(params),\n          onEnter: node => {\n            const nodeValue = collection2.getNodeValue(node);\n            values.push(nodeValue);\n            if (nodeValue === currentSelection) {\n              return \"stop\";\n            }\n          }\n        });\n        context.set(\"selectedValue\", values);\n      },\n      extendSelectionToLastNode(params) {\n        const {\n          context,\n          prop\n        } = params;\n        const collection2 = prop(\"collection\");\n        const currentSelection = first(context.get(\"selectedValue\"));\n        const values = [];\n        let current = false;\n        collection2.visit({\n          skip: skipFn(params),\n          onEnter: node => {\n            const nodeValue = collection2.getNodeValue(node);\n            if (nodeValue === currentSelection) current = true;\n            if (current) values.push(nodeValue);\n          }\n        });\n        context.set(\"selectedValue\", values);\n      }\n    }\n  }\n});\nvar props = createProps()([\"ids\", \"collection\", \"dir\", \"expandedValue\", \"expandOnClick\", \"focusedValue\", \"getRootNode\", \"id\", \"onExpandedChange\", \"onFocusChange\", \"onSelectionChange\", \"selectedValue\", \"selectionMode\", \"typeahead\", \"defaultExpandedValue\", \"defaultSelectedValue\"]);\nvar splitProps = createSplitProps(props);\nvar itemProps = createProps()([\"node\", \"indexPath\"]);\nvar splitItemProps = createSplitProps(itemProps);\nexport { anatomy, collection, connect, filePathCollection, itemProps, machine, props, splitItemProps, splitProps };","map":null,"metadata":{},"sourceType":"module"}