{"ast":null,"code":"import { createAnatomy } from '@zag-js/anatomy';\nimport { createGuards, createMachine, mergeProps } from '@zag-js/core';\nimport { isEditableElement, raf, getInitialFocus, contains, observeAttributes, addDomEvent, getEventTarget, getByTypeahead, clickIfLink, getWindow, scrollIntoView, queryAll, dataAttr, isDownloadingEvent, isOpeningInNewTab, isSelfTarget, isValidTabEvent, getEventKey, isPrintableKey, isModifierKey, isContextMenuEvent, getEventPoint, ariaAttr, isAnchorElement, isHTMLElement } from '@zag-js/dom-query';\nimport { getPlacementSide, getPlacement, getPlacementStyles } from '@zag-js/popper';\nimport { last, first, createSplitProps, prev, next } from '@zag-js/utils';\nimport { trackDismissableElement } from '@zag-js/dismissable';\nimport { getElementPolygon, isPointInPolygon } from '@zag-js/rect-utils';\nimport { createProps } from '@zag-js/types';\n\n// src/menu.anatomy.ts\nvar anatomy = createAnatomy(\"menu\").parts(\"arrow\", \"arrowTip\", \"content\", \"contextTrigger\", \"indicator\", \"item\", \"itemGroup\", \"itemGroupLabel\", \"itemIndicator\", \"itemText\", \"positioner\", \"separator\", \"trigger\", \"triggerItem\");\nvar parts = anatomy.build();\nvar getTriggerId = ctx => ctx.ids?.trigger ?? `menu:${ctx.id}:trigger`;\nvar getContextTriggerId = ctx => ctx.ids?.contextTrigger ?? `menu:${ctx.id}:ctx-trigger`;\nvar getContentId = ctx => ctx.ids?.content ?? `menu:${ctx.id}:content`;\nvar getArrowId = ctx => ctx.ids?.arrow ?? `menu:${ctx.id}:arrow`;\nvar getPositionerId = ctx => ctx.ids?.positioner ?? `menu:${ctx.id}:popper`;\nvar getGroupId = (ctx, id) => ctx.ids?.group?.(id) ?? `menu:${ctx.id}:group:${id}`;\nvar getItemId = (ctx, id) => `${ctx.id}/${id}`;\nvar getItemValue = el => el?.dataset.value ?? null;\nvar getGroupLabelId = (ctx, id) => ctx.ids?.groupLabel?.(id) ?? `menu:${ctx.id}:group-label:${id}`;\nvar getContentEl = ctx => ctx.getById(getContentId(ctx));\nvar getPositionerEl = ctx => ctx.getById(getPositionerId(ctx));\nvar getTriggerEl = ctx => ctx.getById(getTriggerId(ctx));\nvar getItemEl = (ctx, value) => value ? ctx.getById(getItemId(ctx, value)) : null;\nvar getContextTriggerEl = ctx => ctx.getById(getContextTriggerId(ctx));\nvar getElements = ctx => {\n  const ownerId = CSS.escape(getContentId(ctx));\n  const selector = `[role^=\"menuitem\"][data-ownedby=${ownerId}]:not([data-disabled])`;\n  return queryAll(getContentEl(ctx), selector);\n};\nvar getFirstEl = ctx => first(getElements(ctx));\nvar getLastEl = ctx => last(getElements(ctx));\nvar isMatch = (el, value) => {\n  if (!value) return false;\n  return el.id === value || el.dataset.value === value;\n};\nvar getNextEl = (ctx, opts) => {\n  const items = getElements(ctx);\n  const index = items.findIndex(el => isMatch(el, opts.value));\n  return next(items, index, {\n    loop: opts.loop ?? opts.loopFocus\n  });\n};\nvar getPrevEl = (ctx, opts) => {\n  const items = getElements(ctx);\n  const index = items.findIndex(el => isMatch(el, opts.value));\n  return prev(items, index, {\n    loop: opts.loop ?? opts.loopFocus\n  });\n};\nvar getElemByKey = (ctx, opts) => {\n  const items = getElements(ctx);\n  const item = items.find(el => isMatch(el, opts.value));\n  return getByTypeahead(items, {\n    state: opts.typeaheadState,\n    key: opts.key,\n    activeId: item?.id ?? null\n  });\n};\nvar isTargetDisabled = v => {\n  return isHTMLElement(v) && (v.dataset.disabled === \"\" || v.hasAttribute(\"disabled\"));\n};\nvar isTriggerItem = el => {\n  return !!el?.getAttribute(\"role\")?.startsWith(\"menuitem\") && !!el?.hasAttribute(\"aria-controls\");\n};\nvar itemSelectEvent = \"menu:select\";\nfunction dispatchSelectionEvent(el, value) {\n  if (!el) return;\n  const win = getWindow(el);\n  const event = new win.CustomEvent(itemSelectEvent, {\n    detail: {\n      value\n    }\n  });\n  el.dispatchEvent(event);\n}\n\n// src/menu.connect.ts\nfunction connect(service, normalize) {\n  const {\n    context,\n    send,\n    state,\n    computed,\n    prop,\n    scope\n  } = service;\n  const open = state.hasTag(\"open\");\n  const isSubmenu = computed(\"isSubmenu\");\n  const isTypingAhead = computed(\"isTypingAhead\");\n  const composite = prop(\"composite\");\n  const currentPlacement = context.get(\"currentPlacement\");\n  const anchorPoint = context.get(\"anchorPoint\");\n  const highlightedValue = context.get(\"highlightedValue\");\n  const popperStyles = getPlacementStyles({\n    ...prop(\"positioning\"),\n    placement: anchorPoint ? \"bottom\" : currentPlacement\n  });\n  function getItemState(props2) {\n    return {\n      id: getItemId(scope, props2.value),\n      disabled: !!props2.disabled,\n      highlighted: highlightedValue === props2.value\n    };\n  }\n  function getOptionItemProps(props2) {\n    const valueText = props2.valueText ?? props2.value;\n    return {\n      ...props2,\n      id: props2.value,\n      valueText\n    };\n  }\n  function getOptionItemState(props2) {\n    const itemState = getItemState(getOptionItemProps(props2));\n    return {\n      ...itemState,\n      checked: !!props2.checked\n    };\n  }\n  function getItemProps(props2) {\n    const {\n      closeOnSelect,\n      valueText,\n      value\n    } = props2;\n    const itemState = getItemState(props2);\n    const id = getItemId(scope, value);\n    return normalize.element({\n      ...parts.item.attrs,\n      id,\n      role: \"menuitem\",\n      \"aria-disabled\": ariaAttr(itemState.disabled),\n      \"data-disabled\": dataAttr(itemState.disabled),\n      \"data-ownedby\": getContentId(scope),\n      \"data-highlighted\": dataAttr(itemState.highlighted),\n      \"data-value\": value,\n      \"data-valuetext\": valueText,\n      onDragStart(event) {\n        const isLink = event.currentTarget.matches(\"a[href]\");\n        if (isLink) event.preventDefault();\n      },\n      onPointerMove(event) {\n        if (itemState.disabled) return;\n        if (event.pointerType !== \"mouse\") return;\n        const target = event.currentTarget;\n        if (itemState.highlighted) return;\n        send({\n          type: \"ITEM_POINTERMOVE\",\n          id,\n          target,\n          closeOnSelect\n        });\n      },\n      onPointerLeave(event) {\n        if (itemState.disabled) return;\n        if (event.pointerType !== \"mouse\") return;\n        const pointerMoved = service.event.previous()?.type.includes(\"POINTER\");\n        if (!pointerMoved) return;\n        const target = event.currentTarget;\n        send({\n          type: \"ITEM_POINTERLEAVE\",\n          id,\n          target,\n          closeOnSelect\n        });\n      },\n      onPointerDown(event) {\n        if (itemState.disabled) return;\n        const target = event.currentTarget;\n        send({\n          type: \"ITEM_POINTERDOWN\",\n          target,\n          id,\n          closeOnSelect\n        });\n      },\n      onClick(event) {\n        if (isDownloadingEvent(event)) return;\n        if (isOpeningInNewTab(event)) return;\n        if (itemState.disabled) return;\n        const target = event.currentTarget;\n        send({\n          type: \"ITEM_CLICK\",\n          target,\n          id,\n          closeOnSelect\n        });\n      }\n    });\n  }\n  return {\n    highlightedValue,\n    open,\n    setOpen(nextOpen) {\n      const open2 = state.hasTag(\"open\");\n      if (open2 === nextOpen) return;\n      send({\n        type: nextOpen ? \"OPEN\" : \"CLOSE\"\n      });\n    },\n    setHighlightedValue(value) {\n      send({\n        type: \"HIGHLIGHTED.SET\",\n        value\n      });\n    },\n    setParent(parent) {\n      send({\n        type: \"PARENT.SET\",\n        value: parent,\n        id: parent.prop(\"id\")\n      });\n    },\n    setChild(child) {\n      send({\n        type: \"CHILD.SET\",\n        value: child,\n        id: child.prop(\"id\")\n      });\n    },\n    reposition(options = {}) {\n      send({\n        type: \"POSITIONING.SET\",\n        options\n      });\n    },\n    addItemListener(props2) {\n      const node = scope.getById(props2.id);\n      if (!node) return;\n      const listener = () => props2.onSelect?.();\n      node.addEventListener(itemSelectEvent, listener);\n      return () => node.removeEventListener(itemSelectEvent, listener);\n    },\n    getContextTriggerProps() {\n      return normalize.element({\n        ...parts.contextTrigger.attrs,\n        dir: prop(\"dir\"),\n        id: getContextTriggerId(scope),\n        onPointerDown(event) {\n          if (event.pointerType === \"mouse\") return;\n          const point = getEventPoint(event);\n          send({\n            type: \"CONTEXT_MENU_START\",\n            point\n          });\n        },\n        onPointerCancel(event) {\n          if (event.pointerType === \"mouse\") return;\n          send({\n            type: \"CONTEXT_MENU_CANCEL\"\n          });\n        },\n        onPointerMove(event) {\n          if (event.pointerType === \"mouse\") return;\n          send({\n            type: \"CONTEXT_MENU_CANCEL\"\n          });\n        },\n        onPointerUp(event) {\n          if (event.pointerType === \"mouse\") return;\n          send({\n            type: \"CONTEXT_MENU_CANCEL\"\n          });\n        },\n        onContextMenu(event) {\n          const point = getEventPoint(event);\n          send({\n            type: \"CONTEXT_MENU\",\n            point\n          });\n          event.preventDefault();\n        },\n        style: {\n          WebkitTouchCallout: \"none\",\n          WebkitUserSelect: \"none\",\n          userSelect: \"none\"\n        }\n      });\n    },\n    getTriggerItemProps(childApi) {\n      const triggerProps = childApi.getTriggerProps();\n      return mergeProps(getItemProps({\n        value: triggerProps.id\n      }), triggerProps);\n    },\n    getTriggerProps() {\n      return normalize.button({\n        ...(isSubmenu ? parts.triggerItem.attrs : parts.trigger.attrs),\n        \"data-placement\": context.get(\"currentPlacement\"),\n        type: \"button\",\n        dir: prop(\"dir\"),\n        id: getTriggerId(scope),\n        \"data-uid\": prop(\"id\"),\n        \"aria-haspopup\": composite ? \"menu\" : \"dialog\",\n        \"aria-controls\": getContentId(scope),\n        \"aria-expanded\": open || void 0,\n        \"data-state\": open ? \"open\" : \"closed\",\n        onPointerMove(event) {\n          if (event.pointerType !== \"mouse\") return;\n          const disabled = isTargetDisabled(event.currentTarget);\n          if (disabled || !isSubmenu) return;\n          const point = getEventPoint(event);\n          send({\n            type: \"TRIGGER_POINTERMOVE\",\n            target: event.currentTarget,\n            point\n          });\n        },\n        onPointerLeave(event) {\n          if (isTargetDisabled(event.currentTarget)) return;\n          if (event.pointerType !== \"mouse\") return;\n          if (!isSubmenu) return;\n          const point = getEventPoint(event);\n          send({\n            type: \"TRIGGER_POINTERLEAVE\",\n            target: event.currentTarget,\n            point\n          });\n        },\n        onPointerDown(event) {\n          if (isTargetDisabled(event.currentTarget)) return;\n          if (isContextMenuEvent(event)) return;\n          event.preventDefault();\n        },\n        onClick(event) {\n          if (event.defaultPrevented) return;\n          if (isTargetDisabled(event.currentTarget)) return;\n          send({\n            type: \"TRIGGER_CLICK\",\n            target: event.currentTarget\n          });\n        },\n        onBlur() {\n          send({\n            type: \"TRIGGER_BLUR\"\n          });\n        },\n        onFocus() {\n          send({\n            type: \"TRIGGER_FOCUS\"\n          });\n        },\n        onKeyDown(event) {\n          if (event.defaultPrevented) return;\n          const keyMap = {\n            ArrowDown() {\n              send({\n                type: \"ARROW_DOWN\"\n              });\n            },\n            ArrowUp() {\n              send({\n                type: \"ARROW_UP\"\n              });\n            },\n            Enter() {\n              send({\n                type: \"ARROW_DOWN\",\n                src: \"enter\"\n              });\n            },\n            Space() {\n              send({\n                type: \"ARROW_DOWN\",\n                src: \"space\"\n              });\n            }\n          };\n          const key = getEventKey(event, {\n            orientation: \"vertical\",\n            dir: prop(\"dir\")\n          });\n          const exec = keyMap[key];\n          if (exec) {\n            event.preventDefault();\n            exec(event);\n          }\n        }\n      });\n    },\n    getIndicatorProps() {\n      return normalize.element({\n        ...parts.indicator.attrs,\n        dir: prop(\"dir\"),\n        \"data-state\": open ? \"open\" : \"closed\"\n      });\n    },\n    getPositionerProps() {\n      return normalize.element({\n        ...parts.positioner.attrs,\n        dir: prop(\"dir\"),\n        id: getPositionerId(scope),\n        style: popperStyles.floating\n      });\n    },\n    getArrowProps() {\n      return normalize.element({\n        id: getArrowId(scope),\n        ...parts.arrow.attrs,\n        dir: prop(\"dir\"),\n        style: popperStyles.arrow\n      });\n    },\n    getArrowTipProps() {\n      return normalize.element({\n        ...parts.arrowTip.attrs,\n        dir: prop(\"dir\"),\n        style: popperStyles.arrowTip\n      });\n    },\n    getContentProps() {\n      return normalize.element({\n        ...parts.content.attrs,\n        id: getContentId(scope),\n        \"aria-label\": prop(\"aria-label\"),\n        hidden: !open,\n        \"data-state\": open ? \"open\" : \"closed\",\n        role: composite ? \"menu\" : \"dialog\",\n        tabIndex: 0,\n        dir: prop(\"dir\"),\n        \"aria-activedescendant\": computed(\"highlightedId\") || void 0,\n        \"aria-labelledby\": getTriggerId(scope),\n        \"data-placement\": currentPlacement,\n        onPointerEnter(event) {\n          if (event.pointerType !== \"mouse\") return;\n          send({\n            type: \"MENU_POINTERENTER\"\n          });\n        },\n        onKeyDown(event) {\n          if (event.defaultPrevented) return;\n          if (!isSelfTarget(event)) return;\n          const target = getEventTarget(event);\n          const sameMenu = target?.closest(\"[role=menu]\") === event.currentTarget || target === event.currentTarget;\n          if (!sameMenu) return;\n          if (event.key === \"Tab\") {\n            const valid = isValidTabEvent(event);\n            if (!valid) {\n              event.preventDefault();\n              return;\n            }\n          }\n          const item = getItemEl(scope, highlightedValue);\n          const keyMap = {\n            ArrowDown() {\n              send({\n                type: \"ARROW_DOWN\"\n              });\n            },\n            ArrowUp() {\n              send({\n                type: \"ARROW_UP\"\n              });\n            },\n            ArrowLeft() {\n              send({\n                type: \"ARROW_LEFT\"\n              });\n            },\n            ArrowRight() {\n              send({\n                type: \"ARROW_RIGHT\"\n              });\n            },\n            Enter() {\n              send({\n                type: \"ENTER\"\n              });\n              if (isAnchorElement(item)) {\n                prop(\"navigate\")?.({\n                  value: highlightedValue,\n                  node: item\n                });\n              }\n            },\n            Space(event2) {\n              if (isTypingAhead) {\n                send({\n                  type: \"TYPEAHEAD\",\n                  key: event2.key\n                });\n              } else {\n                keyMap.Enter?.(event2);\n              }\n            },\n            Home() {\n              send({\n                type: \"HOME\"\n              });\n            },\n            End() {\n              send({\n                type: \"END\"\n              });\n            }\n          };\n          const key = getEventKey(event, {\n            dir: prop(\"dir\")\n          });\n          const exec = keyMap[key];\n          if (exec) {\n            exec(event);\n            event.stopPropagation();\n            event.preventDefault();\n            return;\n          }\n          if (!prop(\"typeahead\")) return;\n          if (!isPrintableKey(event)) return;\n          if (isModifierKey(event)) return;\n          if (isEditableElement(target)) return;\n          send({\n            type: \"TYPEAHEAD\",\n            key: event.key\n          });\n          event.preventDefault();\n        }\n      });\n    },\n    getSeparatorProps() {\n      return normalize.element({\n        ...parts.separator.attrs,\n        role: \"separator\",\n        dir: prop(\"dir\"),\n        \"aria-orientation\": \"horizontal\"\n      });\n    },\n    getItemState,\n    getItemProps,\n    getOptionItemState,\n    getOptionItemProps(props2) {\n      const {\n        type,\n        disabled,\n        onCheckedChange,\n        closeOnSelect\n      } = props2;\n      const option = getOptionItemProps(props2);\n      const itemState = getOptionItemState(props2);\n      return {\n        ...getItemProps(option),\n        ...normalize.element({\n          \"data-type\": type,\n          ...parts.item.attrs,\n          dir: prop(\"dir\"),\n          \"data-value\": option.value,\n          role: `menuitem${type}`,\n          \"aria-checked\": !!itemState.checked,\n          \"data-state\": itemState.checked ? \"checked\" : \"unchecked\",\n          onClick(event) {\n            if (disabled) return;\n            if (isDownloadingEvent(event)) return;\n            if (isOpeningInNewTab(event)) return;\n            const target = event.currentTarget;\n            send({\n              type: \"ITEM_CLICK\",\n              target,\n              option,\n              closeOnSelect\n            });\n            onCheckedChange?.(!itemState.checked);\n          }\n        })\n      };\n    },\n    getItemIndicatorProps(props2) {\n      const itemState = getOptionItemState(props2);\n      return normalize.element({\n        ...parts.itemIndicator.attrs,\n        dir: prop(\"dir\"),\n        \"data-disabled\": dataAttr(itemState.disabled),\n        \"data-highlighted\": dataAttr(itemState.highlighted),\n        \"data-state\": itemState.checked ? \"checked\" : \"unchecked\",\n        hidden: !itemState.checked\n      });\n    },\n    getItemTextProps(props2) {\n      const itemState = getOptionItemState(props2);\n      return normalize.element({\n        ...parts.itemText.attrs,\n        dir: prop(\"dir\"),\n        \"data-disabled\": dataAttr(itemState.disabled),\n        \"data-highlighted\": dataAttr(itemState.highlighted),\n        \"data-state\": itemState.checked ? \"checked\" : \"unchecked\"\n      });\n    },\n    getItemGroupLabelProps(props2) {\n      return normalize.element({\n        ...parts.itemGroupLabel.attrs,\n        id: getGroupLabelId(scope, props2.htmlFor),\n        dir: prop(\"dir\")\n      });\n    },\n    getItemGroupProps(props2) {\n      return normalize.element({\n        id: getGroupId(scope, props2.id),\n        ...parts.itemGroup.attrs,\n        dir: prop(\"dir\"),\n        \"aria-labelledby\": getGroupLabelId(scope, props2.id),\n        role: \"group\"\n      });\n    }\n  };\n}\nvar {\n  not,\n  and,\n  or\n} = createGuards();\nvar machine = createMachine({\n  props({\n    props: props2\n  }) {\n    return {\n      closeOnSelect: true,\n      typeahead: true,\n      composite: true,\n      loopFocus: false,\n      navigate(details) {\n        clickIfLink(details.node);\n      },\n      ...props2,\n      positioning: {\n        placement: \"bottom-start\",\n        gutter: 8,\n        ...props2.positioning\n      }\n    };\n  },\n  initialState({\n    prop\n  }) {\n    const open = prop(\"open\") || prop(\"defaultOpen\");\n    return open ? \"open\" : \"idle\";\n  },\n  context({\n    bindable,\n    prop\n  }) {\n    return {\n      suspendPointer: bindable(() => ({\n        defaultValue: false\n      })),\n      highlightedValue: bindable(() => ({\n        defaultValue: prop(\"defaultHighlightedValue\") || null,\n        value: prop(\"highlightedValue\"),\n        onChange(value) {\n          prop(\"onHighlightChange\")?.({\n            highlightedValue: value\n          });\n        }\n      })),\n      lastHighlightedValue: bindable(() => ({\n        defaultValue: null\n      })),\n      currentPlacement: bindable(() => ({\n        defaultValue: void 0\n      })),\n      intentPolygon: bindable(() => ({\n        defaultValue: null\n      })),\n      anchorPoint: bindable(() => ({\n        defaultValue: null,\n        hash(value) {\n          return `x: ${value?.x}, y: ${value?.y}`;\n        }\n      }))\n    };\n  },\n  refs() {\n    return {\n      parent: null,\n      children: {},\n      typeaheadState: {\n        ...getByTypeahead.defaultOptions\n      },\n      positioningOverride: {}\n    };\n  },\n  computed: {\n    isSubmenu: ({\n      refs\n    }) => refs.get(\"parent\") != null,\n    isRtl: ({\n      prop\n    }) => prop(\"dir\") === \"rtl\",\n    isTypingAhead: ({\n      refs\n    }) => refs.get(\"typeaheadState\").keysSoFar !== \"\",\n    highlightedId: ({\n      context,\n      scope,\n      refs\n    }) => resolveItemId(refs.get(\"children\"), context.get(\"highlightedValue\"), scope)\n  },\n  watch({\n    track,\n    action,\n    context,\n    computed,\n    prop\n  }) {\n    track([() => computed(\"isSubmenu\")], () => {\n      action([\"setSubmenuPlacement\"]);\n    });\n    track([() => context.hash(\"anchorPoint\")], () => {\n      action([\"reposition\"]);\n    });\n    track([() => prop(\"open\")], () => {\n      action([\"toggleVisibility\"]);\n    });\n  },\n  on: {\n    \"PARENT.SET\": {\n      actions: [\"setParentMenu\"]\n    },\n    \"CHILD.SET\": {\n      actions: [\"setChildMenu\"]\n    },\n    OPEN: [{\n      guard: \"isOpenControlled\",\n      actions: [\"invokeOnOpen\"]\n    }, {\n      target: \"open\",\n      actions: [\"invokeOnOpen\"]\n    }],\n    OPEN_AUTOFOCUS: [{\n      guard: \"isOpenControlled\",\n      actions: [\"invokeOnOpen\"]\n    }, {\n      // internal: true,\n      target: \"open\",\n      actions: [\"highlightFirstItem\", \"invokeOnOpen\"]\n    }],\n    CLOSE: [{\n      guard: \"isOpenControlled\",\n      actions: [\"invokeOnClose\"]\n    }, {\n      target: \"closed\",\n      actions: [\"invokeOnClose\"]\n    }],\n    \"HIGHLIGHTED.RESTORE\": {\n      actions: [\"restoreHighlightedItem\"]\n    },\n    \"HIGHLIGHTED.SET\": {\n      actions: [\"setHighlightedItem\"]\n    }\n  },\n  states: {\n    idle: {\n      tags: [\"closed\"],\n      on: {\n        \"CONTROLLED.OPEN\": {\n          target: \"open\"\n        },\n        \"CONTROLLED.CLOSE\": {\n          target: \"closed\"\n        },\n        CONTEXT_MENU_START: {\n          target: \"opening:contextmenu\",\n          actions: [\"setAnchorPoint\"]\n        },\n        CONTEXT_MENU: [{\n          guard: \"isOpenControlled\",\n          actions: [\"setAnchorPoint\", \"invokeOnOpen\"]\n        }, {\n          target: \"open\",\n          actions: [\"setAnchorPoint\", \"invokeOnOpen\"]\n        }],\n        TRIGGER_CLICK: [{\n          guard: \"isOpenControlled\",\n          actions: [\"invokeOnOpen\"]\n        }, {\n          target: \"open\",\n          actions: [\"invokeOnOpen\"]\n        }],\n        TRIGGER_FOCUS: {\n          guard: not(\"isSubmenu\"),\n          target: \"closed\"\n        },\n        TRIGGER_POINTERMOVE: {\n          guard: \"isSubmenu\",\n          target: \"opening\"\n        }\n      }\n    },\n    \"opening:contextmenu\": {\n      tags: [\"closed\"],\n      effects: [\"waitForLongPress\"],\n      on: {\n        \"CONTROLLED.OPEN\": {\n          target: \"open\"\n        },\n        \"CONTROLLED.CLOSE\": {\n          target: \"closed\"\n        },\n        CONTEXT_MENU_CANCEL: [{\n          guard: \"isOpenControlled\",\n          actions: [\"invokeOnClose\"]\n        }, {\n          target: \"closed\",\n          actions: [\"invokeOnClose\"]\n        }],\n        \"LONG_PRESS.OPEN\": [{\n          guard: \"isOpenControlled\",\n          actions: [\"invokeOnOpen\"]\n        }, {\n          target: \"open\",\n          actions: [\"invokeOnOpen\"]\n        }]\n      }\n    },\n    opening: {\n      tags: [\"closed\"],\n      effects: [\"waitForOpenDelay\"],\n      on: {\n        \"CONTROLLED.OPEN\": {\n          target: \"open\"\n        },\n        \"CONTROLLED.CLOSE\": {\n          target: \"closed\"\n        },\n        BLUR: [{\n          guard: \"isOpenControlled\",\n          actions: [\"invokeOnClose\"]\n        }, {\n          target: \"closed\",\n          actions: [\"invokeOnClose\"]\n        }],\n        TRIGGER_POINTERLEAVE: [{\n          guard: \"isOpenControlled\",\n          actions: [\"invokeOnClose\"]\n        }, {\n          target: \"closed\",\n          actions: [\"invokeOnClose\"]\n        }],\n        \"DELAY.OPEN\": [{\n          guard: \"isOpenControlled\",\n          actions: [\"invokeOnOpen\"]\n        }, {\n          target: \"open\",\n          actions: [\"invokeOnOpen\"]\n        }]\n      }\n    },\n    closing: {\n      tags: [\"open\"],\n      effects: [\"trackPointerMove\", \"trackInteractOutside\", \"waitForCloseDelay\"],\n      on: {\n        \"CONTROLLED.OPEN\": {\n          target: \"open\"\n        },\n        \"CONTROLLED.CLOSE\": {\n          target: \"closed\",\n          actions: [\"focusParentMenu\", \"restoreParentHighlightedItem\"]\n        },\n        // don't invoke on open here since the menu is still open (we're only keeping it open)\n        MENU_POINTERENTER: {\n          target: \"open\",\n          actions: [\"clearIntentPolygon\"]\n        },\n        POINTER_MOVED_AWAY_FROM_SUBMENU: [{\n          guard: \"isOpenControlled\",\n          actions: [\"invokeOnClose\"]\n        }, {\n          target: \"closed\",\n          actions: [\"focusParentMenu\", \"restoreParentHighlightedItem\"]\n        }],\n        \"DELAY.CLOSE\": [{\n          guard: \"isOpenControlled\",\n          actions: [\"invokeOnClose\"]\n        }, {\n          target: \"closed\",\n          actions: [\"focusParentMenu\", \"restoreParentHighlightedItem\", \"invokeOnClose\"]\n        }]\n      }\n    },\n    closed: {\n      tags: [\"closed\"],\n      entry: [\"clearHighlightedItem\", \"focusTrigger\", \"resumePointer\"],\n      on: {\n        \"CONTROLLED.OPEN\": [{\n          guard: or(\"isOpenAutoFocusEvent\", \"isArrowDownEvent\"),\n          target: \"open\",\n          actions: [\"highlightFirstItem\"]\n        }, {\n          guard: \"isArrowUpEvent\",\n          target: \"open\",\n          actions: [\"highlightLastItem\"]\n        }, {\n          target: \"open\"\n        }],\n        CONTEXT_MENU_START: {\n          target: \"opening:contextmenu\",\n          actions: [\"setAnchorPoint\"]\n        },\n        CONTEXT_MENU: [{\n          guard: \"isOpenControlled\",\n          actions: [\"setAnchorPoint\", \"invokeOnOpen\"]\n        }, {\n          target: \"open\",\n          actions: [\"setAnchorPoint\", \"invokeOnOpen\"]\n        }],\n        TRIGGER_CLICK: [{\n          guard: \"isOpenControlled\",\n          actions: [\"invokeOnOpen\"]\n        }, {\n          target: \"open\",\n          actions: [\"invokeOnOpen\"]\n        }],\n        TRIGGER_POINTERMOVE: {\n          guard: \"isTriggerItem\",\n          target: \"opening\"\n        },\n        TRIGGER_BLUR: {\n          target: \"idle\"\n        },\n        ARROW_DOWN: [{\n          guard: \"isOpenControlled\",\n          actions: [\"invokeOnOpen\"]\n        }, {\n          target: \"open\",\n          actions: [\"highlightFirstItem\", \"invokeOnOpen\"]\n        }],\n        ARROW_UP: [{\n          guard: \"isOpenControlled\",\n          actions: [\"invokeOnOpen\"]\n        }, {\n          target: \"open\",\n          actions: [\"highlightLastItem\", \"invokeOnOpen\"]\n        }]\n      }\n    },\n    open: {\n      tags: [\"open\"],\n      effects: [\"trackInteractOutside\", \"trackPositioning\", \"scrollToHighlightedItem\"],\n      entry: [\"focusMenu\", \"resumePointer\"],\n      on: {\n        \"CONTROLLED.CLOSE\": [{\n          target: \"closed\",\n          guard: \"isArrowLeftEvent\",\n          actions: [\"focusParentMenu\"]\n        }, {\n          target: \"closed\"\n        }],\n        TRIGGER_CLICK: [{\n          guard: and(not(\"isTriggerItem\"), \"isOpenControlled\"),\n          actions: [\"invokeOnClose\"]\n        }, {\n          guard: not(\"isTriggerItem\"),\n          target: \"closed\",\n          actions: [\"invokeOnClose\"]\n        }],\n        CONTEXT_MENU: {\n          actions: [\"setAnchorPoint\", \"focusMenu\"]\n        },\n        ARROW_UP: {\n          actions: [\"highlightPrevItem\", \"focusMenu\"]\n        },\n        ARROW_DOWN: {\n          actions: [\"highlightNextItem\", \"focusMenu\"]\n        },\n        ARROW_LEFT: [{\n          guard: and(\"isSubmenu\", \"isOpenControlled\"),\n          actions: [\"invokeOnClose\"]\n        }, {\n          guard: \"isSubmenu\",\n          target: \"closed\",\n          actions: [\"focusParentMenu\", \"invokeOnClose\"]\n        }],\n        HOME: {\n          actions: [\"highlightFirstItem\", \"focusMenu\"]\n        },\n        END: {\n          actions: [\"highlightLastItem\", \"focusMenu\"]\n        },\n        ARROW_RIGHT: {\n          guard: \"isTriggerItemHighlighted\",\n          actions: [\"openSubmenu\"]\n        },\n        ENTER: [{\n          guard: \"isTriggerItemHighlighted\",\n          actions: [\"openSubmenu\"]\n        }, {\n          actions: [\"clickHighlightedItem\"]\n        }],\n        ITEM_POINTERMOVE: [{\n          guard: not(\"isPointerSuspended\"),\n          actions: [\"setHighlightedItem\", \"focusMenu\"]\n        }, {\n          actions: [\"setLastHighlightedItem\"]\n        }],\n        ITEM_POINTERLEAVE: {\n          guard: and(not(\"isPointerSuspended\"), not(\"isTriggerItem\")),\n          actions: [\"clearHighlightedItem\"]\n        },\n        ITEM_CLICK: [\n        // == grouped ==\n        {\n          guard: and(not(\"isTriggerItemHighlighted\"), not(\"isHighlightedItemEditable\"), \"closeOnSelect\", \"isOpenControlled\"),\n          actions: [\"invokeOnSelect\", \"setOptionState\", \"closeRootMenu\", \"invokeOnClose\"]\n        }, {\n          guard: and(not(\"isTriggerItemHighlighted\"), not(\"isHighlightedItemEditable\"), \"closeOnSelect\"),\n          target: \"closed\",\n          actions: [\"invokeOnSelect\", \"setOptionState\", \"closeRootMenu\", \"invokeOnClose\"]\n        },\n        //\n        {\n          guard: and(not(\"isTriggerItemHighlighted\"), not(\"isHighlightedItemEditable\")),\n          actions: [\"invokeOnSelect\", \"setOptionState\"]\n        }, {\n          actions: [\"setHighlightedItem\"]\n        }],\n        TRIGGER_POINTERMOVE: {\n          guard: \"isTriggerItem\",\n          actions: [\"setIntentPolygon\"]\n        },\n        TRIGGER_POINTERLEAVE: {\n          target: \"closing\"\n        },\n        ITEM_POINTERDOWN: {\n          actions: [\"setHighlightedItem\"]\n        },\n        TYPEAHEAD: {\n          actions: [\"highlightMatchedItem\"]\n        },\n        FOCUS_MENU: {\n          actions: [\"focusMenu\"]\n        },\n        \"POSITIONING.SET\": {\n          actions: [\"reposition\"]\n        }\n      }\n    }\n  },\n  implementations: {\n    guards: {\n      closeOnSelect: ({\n        prop,\n        event\n      }) => !!(event?.closeOnSelect ?? prop(\"closeOnSelect\")),\n      // whether the trigger is also a menu item\n      isTriggerItem: ({\n        event\n      }) => isTriggerItem(event.target),\n      // whether the trigger item is the active item\n      isTriggerItemHighlighted: ({\n        event,\n        scope,\n        computed\n      }) => {\n        const target = event.target ?? scope.getById(computed(\"highlightedId\"));\n        return !!target?.hasAttribute(\"aria-controls\");\n      },\n      isSubmenu: ({\n        computed\n      }) => computed(\"isSubmenu\"),\n      isPointerSuspended: ({\n        context\n      }) => context.get(\"suspendPointer\"),\n      isHighlightedItemEditable: ({\n        scope,\n        computed\n      }) => isEditableElement(scope.getById(computed(\"highlightedId\"))),\n      // guard assertions (for controlled mode)\n      isOpenControlled: ({\n        prop\n      }) => prop(\"open\") !== void 0,\n      isArrowLeftEvent: ({\n        event\n      }) => event.previousEvent?.type === \"ARROW_LEFT\",\n      isArrowUpEvent: ({\n        event\n      }) => event.previousEvent?.type === \"ARROW_UP\",\n      isArrowDownEvent: ({\n        event\n      }) => event.previousEvent?.type === \"ARROW_DOWN\",\n      isOpenAutoFocusEvent: ({\n        event\n      }) => event.previousEvent?.type === \"OPEN_AUTOFOCUS\"\n    },\n    effects: {\n      waitForOpenDelay({\n        send\n      }) {\n        const timer = setTimeout(() => {\n          send({\n            type: \"DELAY.OPEN\"\n          });\n        }, 100);\n        return () => clearTimeout(timer);\n      },\n      waitForCloseDelay({\n        send\n      }) {\n        const timer = setTimeout(() => {\n          send({\n            type: \"DELAY.CLOSE\"\n          });\n        }, 300);\n        return () => clearTimeout(timer);\n      },\n      waitForLongPress({\n        send\n      }) {\n        const timer = setTimeout(() => {\n          send({\n            type: \"LONG_PRESS.OPEN\"\n          });\n        }, 700);\n        return () => clearTimeout(timer);\n      },\n      trackPositioning({\n        context,\n        prop,\n        scope,\n        refs\n      }) {\n        if (!!getContextTriggerEl(scope)) return;\n        const positioning = {\n          ...prop(\"positioning\"),\n          ...refs.get(\"positioningOverride\")\n        };\n        context.set(\"currentPlacement\", positioning.placement);\n        const getPositionerEl2 = () => getPositionerEl(scope);\n        return getPlacement(getTriggerEl(scope), getPositionerEl2, {\n          ...positioning,\n          defer: true,\n          onComplete(data) {\n            context.set(\"currentPlacement\", data.placement);\n          }\n        });\n      },\n      trackInteractOutside({\n        refs,\n        scope,\n        prop,\n        computed,\n        send\n      }) {\n        const getContentEl2 = () => getContentEl(scope);\n        let restoreFocus = true;\n        return trackDismissableElement(getContentEl2, {\n          defer: true,\n          exclude: [getTriggerEl(scope)],\n          onInteractOutside: prop(\"onInteractOutside\"),\n          onFocusOutside: prop(\"onFocusOutside\"),\n          onEscapeKeyDown(event) {\n            prop(\"onEscapeKeyDown\")?.(event);\n            if (computed(\"isSubmenu\")) event.preventDefault();\n            closeRootMenu({\n              parent: refs.get(\"parent\")\n            });\n          },\n          onPointerDownOutside(event) {\n            const target = getEventTarget(event.detail.originalEvent);\n            const isWithinContextTrigger = contains(getContextTriggerEl(scope), target);\n            if (isWithinContextTrigger && event.detail.contextmenu) {\n              event.preventDefault();\n              return;\n            }\n            restoreFocus = !event.detail.focusable;\n            prop(\"onPointerDownOutside\")?.(event);\n          },\n          onDismiss() {\n            send({\n              type: \"CLOSE\",\n              src: \"interact-outside\",\n              restoreFocus\n            });\n          }\n        });\n      },\n      trackPointerMove({\n        context,\n        scope,\n        send,\n        refs,\n        flush\n      }) {\n        const parent = refs.get(\"parent\");\n        flush(() => {\n          parent.context.set(\"suspendPointer\", true);\n        });\n        const doc = scope.getDoc();\n        return addDomEvent(doc, \"pointermove\", e => {\n          const isMovingToSubmenu = isWithinPolygon(context.get(\"intentPolygon\"), {\n            x: e.clientX,\n            y: e.clientY\n          });\n          if (!isMovingToSubmenu) {\n            send({\n              type: \"POINTER_MOVED_AWAY_FROM_SUBMENU\"\n            });\n            parent.context.set(\"suspendPointer\", false);\n          }\n        });\n      },\n      scrollToHighlightedItem({\n        event,\n        scope,\n        computed\n      }) {\n        const exec = () => {\n          if (event.type.startsWith(\"ITEM_POINTER\")) return;\n          const itemEl = scope.getById(computed(\"highlightedId\"));\n          const contentEl2 = getContentEl(scope);\n          scrollIntoView(itemEl, {\n            rootEl: contentEl2,\n            block: \"nearest\"\n          });\n        };\n        raf(() => exec());\n        const contentEl = () => getContentEl(scope);\n        return observeAttributes(contentEl, {\n          defer: true,\n          attributes: [\"aria-activedescendant\"],\n          callback: exec\n        });\n      }\n    },\n    actions: {\n      setAnchorPoint({\n        context,\n        event\n      }) {\n        context.set(\"anchorPoint\", event.point);\n      },\n      setSubmenuPlacement({\n        computed,\n        refs\n      }) {\n        if (!computed(\"isSubmenu\")) return;\n        const placement = computed(\"isRtl\") ? \"left-start\" : \"right-start\";\n        refs.set(\"positioningOverride\", {\n          placement,\n          gutter: 0\n        });\n      },\n      reposition({\n        context,\n        scope,\n        prop,\n        event,\n        refs\n      }) {\n        const getPositionerEl2 = () => getPositionerEl(scope);\n        const anchorPoint = context.get(\"anchorPoint\");\n        const getAnchorRect = anchorPoint ? () => ({\n          width: 0,\n          height: 0,\n          ...anchorPoint\n        }) : void 0;\n        const positioning = {\n          ...prop(\"positioning\"),\n          ...refs.get(\"positioningOverride\")\n        };\n        getPlacement(getTriggerEl(scope), getPositionerEl2, {\n          ...positioning,\n          defer: true,\n          getAnchorRect,\n          ...(event.options ?? {}),\n          listeners: false,\n          onComplete(data) {\n            context.set(\"currentPlacement\", data.placement);\n          }\n        });\n      },\n      setOptionState({\n        event\n      }) {\n        if (!event.option) return;\n        const {\n          checked,\n          onCheckedChange,\n          type\n        } = event.option;\n        if (type === \"radio\") {\n          onCheckedChange?.(true);\n        } else if (type === \"checkbox\") {\n          onCheckedChange?.(!checked);\n        }\n      },\n      clickHighlightedItem({\n        scope,\n        computed\n      }) {\n        const itemEl = scope.getById(computed(\"highlightedId\"));\n        if (!itemEl || itemEl.dataset.disabled) return;\n        queueMicrotask(() => itemEl.click());\n      },\n      setIntentPolygon({\n        context,\n        scope,\n        event\n      }) {\n        const menu = getContentEl(scope);\n        const placement = context.get(\"currentPlacement\");\n        if (!menu || !placement) return;\n        const rect = menu.getBoundingClientRect();\n        const polygon = getElementPolygon(rect, placement);\n        if (!polygon) return;\n        const rightSide = getPlacementSide(placement) === \"right\";\n        const bleed = rightSide ? -5 : 5;\n        context.set(\"intentPolygon\", [{\n          ...event.point,\n          x: event.point.x + bleed\n        }, ...polygon]);\n      },\n      clearIntentPolygon({\n        context\n      }) {\n        context.set(\"intentPolygon\", null);\n      },\n      resumePointer({\n        refs,\n        flush\n      }) {\n        const parent = refs.get(\"parent\");\n        if (!parent) return;\n        flush(() => {\n          parent.context.set(\"suspendPointer\", false);\n        });\n      },\n      setHighlightedItem({\n        context,\n        event\n      }) {\n        const value = event.value || getItemValue(event.target);\n        context.set(\"highlightedValue\", value);\n      },\n      clearHighlightedItem({\n        context\n      }) {\n        context.set(\"highlightedValue\", null);\n      },\n      focusMenu({\n        scope\n      }) {\n        raf(() => {\n          const contentEl = getContentEl(scope);\n          const initialFocusEl = getInitialFocus({\n            root: contentEl,\n            enabled: !contains(contentEl, scope.getActiveElement()),\n            filter(node) {\n              return !node.role?.startsWith(\"menuitem\");\n            }\n          });\n          initialFocusEl?.focus({\n            preventScroll: true\n          });\n        });\n      },\n      highlightFirstItem({\n        context,\n        scope\n      }) {\n        const fn = getContentEl(scope) ? queueMicrotask : raf;\n        fn(() => {\n          const first2 = getFirstEl(scope);\n          if (!first2) return;\n          context.set(\"highlightedValue\", getItemValue(first2));\n        });\n      },\n      highlightLastItem({\n        context,\n        scope\n      }) {\n        const fn = getContentEl(scope) ? queueMicrotask : raf;\n        fn(() => {\n          const last2 = getLastEl(scope);\n          if (!last2) return;\n          context.set(\"highlightedValue\", getItemValue(last2));\n        });\n      },\n      highlightNextItem({\n        context,\n        scope,\n        event,\n        prop\n      }) {\n        const next2 = getNextEl(scope, {\n          loop: event.loop,\n          value: context.get(\"highlightedValue\"),\n          loopFocus: prop(\"loopFocus\")\n        });\n        context.set(\"highlightedValue\", getItemValue(next2));\n      },\n      highlightPrevItem({\n        context,\n        scope,\n        event,\n        prop\n      }) {\n        const prev2 = getPrevEl(scope, {\n          loop: event.loop,\n          value: context.get(\"highlightedValue\"),\n          loopFocus: prop(\"loopFocus\")\n        });\n        context.set(\"highlightedValue\", getItemValue(prev2));\n      },\n      invokeOnSelect({\n        context,\n        prop,\n        scope\n      }) {\n        const value = context.get(\"highlightedValue\");\n        if (value == null) return;\n        const node = getItemEl(scope, value);\n        dispatchSelectionEvent(node, value);\n        prop(\"onSelect\")?.({\n          value\n        });\n      },\n      focusTrigger({\n        scope,\n        context,\n        event,\n        computed\n      }) {\n        if (computed(\"isSubmenu\") || context.get(\"anchorPoint\") || event.restoreFocus === false) return;\n        queueMicrotask(() => getTriggerEl(scope)?.focus({\n          preventScroll: true\n        }));\n      },\n      highlightMatchedItem({\n        scope,\n        context,\n        event,\n        refs\n      }) {\n        const node = getElemByKey(scope, {\n          key: event.key,\n          value: context.get(\"highlightedValue\"),\n          typeaheadState: refs.get(\"typeaheadState\")\n        });\n        if (!node) return;\n        context.set(\"highlightedValue\", getItemValue(node));\n      },\n      setParentMenu({\n        refs,\n        event\n      }) {\n        refs.set(\"parent\", event.value);\n      },\n      setChildMenu({\n        refs,\n        event\n      }) {\n        const children = refs.get(\"children\");\n        children[event.id] = event.value;\n        refs.set(\"children\", children);\n      },\n      closeRootMenu({\n        refs\n      }) {\n        closeRootMenu({\n          parent: refs.get(\"parent\")\n        });\n      },\n      openSubmenu({\n        refs,\n        scope,\n        computed\n      }) {\n        const item = scope.getById(computed(\"highlightedId\"));\n        const id = item?.getAttribute(\"data-uid\");\n        const children = refs.get(\"children\");\n        const child = id ? children[id] : null;\n        child?.send({\n          type: \"OPEN_AUTOFOCUS\"\n        });\n      },\n      focusParentMenu({\n        refs\n      }) {\n        refs.get(\"parent\")?.send({\n          type: \"FOCUS_MENU\"\n        });\n      },\n      setLastHighlightedItem({\n        context,\n        event\n      }) {\n        context.set(\"lastHighlightedValue\", getItemValue(event.target));\n      },\n      restoreHighlightedItem({\n        context\n      }) {\n        if (!context.get(\"lastHighlightedValue\")) return;\n        context.set(\"highlightedValue\", context.get(\"lastHighlightedValue\"));\n        context.set(\"lastHighlightedValue\", null);\n      },\n      restoreParentHighlightedItem({\n        refs\n      }) {\n        refs.get(\"parent\")?.send({\n          type: \"HIGHLIGHTED.RESTORE\"\n        });\n      },\n      invokeOnOpen({\n        prop\n      }) {\n        prop(\"onOpenChange\")?.({\n          open: true\n        });\n      },\n      invokeOnClose({\n        prop\n      }) {\n        prop(\"onOpenChange\")?.({\n          open: false\n        });\n      },\n      toggleVisibility({\n        prop,\n        event,\n        send\n      }) {\n        send({\n          type: prop(\"open\") ? \"CONTROLLED.OPEN\" : \"CONTROLLED.CLOSE\",\n          previousEvent: event\n        });\n      }\n    }\n  }\n});\nfunction closeRootMenu(ctx) {\n  let parent = ctx.parent;\n  while (parent && parent.computed(\"isSubmenu\")) {\n    parent = parent.refs.get(\"parent\");\n  }\n  parent?.send({\n    type: \"CLOSE\"\n  });\n}\nfunction isWithinPolygon(polygon, point) {\n  if (!polygon) return false;\n  return isPointInPolygon(polygon, point);\n}\nfunction resolveItemId(children, value, scope) {\n  const hasChildren = Object.keys(children).length > 0;\n  if (!value) return null;\n  if (!hasChildren) {\n    return getItemId(scope, value);\n  }\n  for (const id in children) {\n    const childMenu = children[id];\n    const childTriggerId = getTriggerId(childMenu.scope);\n    if (childTriggerId === value) {\n      return childTriggerId;\n    }\n  }\n  return getItemId(scope, value);\n}\nvar props = createProps()([\"anchorPoint\", \"aria-label\", \"closeOnSelect\", \"composite\", \"defaultHighlightedValue\", \"defaultOpen\", \"dir\", \"getRootNode\", \"highlightedValue\", \"id\", \"ids\", \"loopFocus\", \"navigate\", \"onEscapeKeyDown\", \"onFocusOutside\", \"onHighlightChange\", \"onInteractOutside\", \"onOpenChange\", \"onPointerDownOutside\", \"onSelect\", \"open\", \"positioning\", \"typeahead\"]);\nvar splitProps = createSplitProps(props);\nvar itemProps = createProps()([\"closeOnSelect\", \"disabled\", \"value\", \"valueText\"]);\nvar splitItemProps = createSplitProps(itemProps);\nvar itemGroupLabelProps = createProps()([\"htmlFor\"]);\nvar splitItemGroupLabelProps = createSplitProps(itemGroupLabelProps);\nvar itemGroupProps = createProps()([\"id\"]);\nvar splitItemGroupProps = createSplitProps(itemGroupProps);\nvar optionItemProps = createProps()([\"checked\", \"closeOnSelect\", \"disabled\", \"onCheckedChange\", \"type\", \"value\", \"valueText\"]);\nvar splitOptionItemProps = createSplitProps(optionItemProps);\nexport { anatomy, connect, itemGroupLabelProps, itemGroupProps, itemProps, machine, optionItemProps, props, splitItemGroupLabelProps, splitItemGroupProps, splitItemProps, splitOptionItemProps, splitProps };","map":null,"metadata":{},"sourceType":"module"}