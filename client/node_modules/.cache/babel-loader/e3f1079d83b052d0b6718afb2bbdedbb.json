{"ast":null,"code":"import { createAnatomy } from '@zag-js/anatomy';\nimport { raf, getComputedStyle, setStyle, getEventTarget, nextTick, dataAttr } from '@zag-js/dom-query';\nimport { createMachine } from '@zag-js/core';\nimport { createProps } from '@zag-js/types';\nimport { createSplitProps } from '@zag-js/utils';\n\n// src/collapsible.anatomy.ts\nvar anatomy = createAnatomy(\"collapsible\").parts(\"root\", \"trigger\", \"content\", \"indicator\");\nvar parts = anatomy.build();\n\n// src/collapsible.dom.ts\nvar getRootId = ctx => ctx.ids?.root ?? `collapsible:${ctx.id}`;\nvar getContentId = ctx => ctx.ids?.content ?? `collapsible:${ctx.id}:content`;\nvar getTriggerId = ctx => ctx.ids?.trigger ?? `collapsible:${ctx.id}:trigger`;\nvar getContentEl = ctx => ctx.getById(getContentId(ctx));\n\n// src/collapsible.connect.ts\nfunction connect(service, normalize) {\n  const {\n    state,\n    send,\n    context,\n    scope,\n    prop\n  } = service;\n  const visible = state.matches(\"open\") || state.matches(\"closing\");\n  const open = state.matches(\"open\");\n  const {\n    width,\n    height\n  } = context.get(\"size\");\n  const disabled = !!prop(\"disabled\");\n  const skip = !context.get(\"initial\") && open;\n  const dir = \"ltr\";\n  return {\n    disabled,\n    visible,\n    open,\n    measureSize() {\n      send({\n        type: \"size.measure\"\n      });\n    },\n    setOpen(nextOpen) {\n      const open2 = state.matches(\"open\");\n      if (open2 === nextOpen) return;\n      send({\n        type: nextOpen ? \"open\" : \"close\"\n      });\n    },\n    getRootProps() {\n      return normalize.element({\n        ...parts.root.attrs,\n        \"data-state\": open ? \"open\" : \"closed\",\n        dir,\n        id: getRootId(scope)\n      });\n    },\n    getContentProps() {\n      return normalize.element({\n        ...parts.content.attrs,\n        \"data-collapsible\": \"\",\n        \"data-state\": skip ? void 0 : open ? \"open\" : \"closed\",\n        id: getContentId(scope),\n        \"data-disabled\": dataAttr(disabled),\n        hidden: !visible,\n        style: {\n          \"--height\": height != null ? `${height}px` : void 0,\n          \"--width\": width != null ? `${width}px` : void 0\n        }\n      });\n    },\n    getTriggerProps() {\n      return normalize.element({\n        ...parts.trigger.attrs,\n        id: getTriggerId(scope),\n        dir,\n        type: \"button\",\n        \"data-state\": open ? \"open\" : \"closed\",\n        \"data-disabled\": dataAttr(disabled),\n        \"aria-controls\": getContentId(scope),\n        \"aria-expanded\": visible || false,\n        onClick(event) {\n          if (event.defaultPrevented) return;\n          if (disabled) return;\n          send({\n            type: open ? \"close\" : \"open\"\n          });\n        }\n      });\n    },\n    getIndicatorProps() {\n      return normalize.element({\n        ...parts.indicator.attrs,\n        dir,\n        \"data-state\": open ? \"open\" : \"closed\",\n        \"data-disabled\": dataAttr(disabled)\n      });\n    }\n  };\n}\nvar machine = createMachine({\n  initialState({\n    prop\n  }) {\n    const open = prop(\"open\") || prop(\"defaultOpen\");\n    return open ? \"open\" : \"closed\";\n  },\n  context({\n    bindable\n  }) {\n    return {\n      size: bindable(() => ({\n        defaultValue: {\n          height: 0,\n          width: 0\n        }\n      })),\n      initial: bindable(() => ({\n        defaultValue: false\n      }))\n    };\n  },\n  refs() {\n    return {\n      cleanup: void 0,\n      stylesRef: void 0\n    };\n  },\n  watch({\n    track,\n    prop,\n    action\n  }) {\n    track([() => prop(\"open\")], () => {\n      action([\"setInitial\", \"computeSize\", \"toggleVisibility\"]);\n    });\n  },\n  exit: [\"clearInitial\", \"cleanupNode\"],\n  states: {\n    closed: {\n      on: {\n        \"controlled.open\": {\n          target: \"open\"\n        },\n        open: [{\n          guard: \"isOpenControlled\",\n          actions: [\"invokeOnOpen\"]\n        }, {\n          target: \"open\",\n          actions: [\"setInitial\", \"computeSize\", \"invokeOnOpen\"]\n        }]\n      }\n    },\n    closing: {\n      effects: [\"trackExitAnimation\"],\n      on: {\n        \"controlled.close\": {\n          target: \"closed\"\n        },\n        \"controlled.open\": {\n          target: \"open\"\n        },\n        open: [{\n          guard: \"isOpenControlled\",\n          actions: [\"invokeOnOpen\"]\n        }, {\n          target: \"open\",\n          actions: [\"setInitial\", \"invokeOnOpen\"]\n        }],\n        close: [{\n          guard: \"isOpenControlled\",\n          actions: [\"invokeOnExitComplete\"]\n        }, {\n          target: \"closed\",\n          actions: [\"setInitial\", \"computeSize\", \"invokeOnExitComplete\"]\n        }],\n        \"animation.end\": {\n          target: \"closed\",\n          actions: [\"invokeOnExitComplete\", \"clearInitial\"]\n        }\n      }\n    },\n    open: {\n      effects: [\"trackEnterAnimation\"],\n      on: {\n        \"controlled.close\": {\n          target: \"closing\"\n        },\n        close: [{\n          guard: \"isOpenControlled\",\n          actions: [\"invokeOnClose\"]\n        }, {\n          target: \"closing\",\n          actions: [\"setInitial\", \"computeSize\", \"invokeOnClose\"]\n        }],\n        \"size.measure\": {\n          actions: [\"measureSize\"]\n        },\n        \"animation.end\": {\n          actions: [\"clearInitial\"]\n        }\n      }\n    }\n  },\n  implementations: {\n    guards: {\n      isOpenControlled: ({\n        prop\n      }) => prop(\"open\") != void 0\n    },\n    effects: {\n      trackEnterAnimation: ({\n        send,\n        scope\n      }) => {\n        let cleanup;\n        const rafCleanup = raf(() => {\n          const contentEl = getContentEl(scope);\n          if (!contentEl) return;\n          const animationName = getComputedStyle(contentEl).animationName;\n          const hasNoAnimation = !animationName || animationName === \"none\";\n          if (hasNoAnimation) {\n            send({\n              type: \"animation.end\"\n            });\n            return;\n          }\n          const onEnd = event => {\n            const target = getEventTarget(event);\n            if (target === contentEl) {\n              send({\n                type: \"animation.end\"\n              });\n            }\n          };\n          contentEl.addEventListener(\"animationend\", onEnd);\n          cleanup = () => {\n            contentEl.removeEventListener(\"animationend\", onEnd);\n          };\n        });\n        return () => {\n          rafCleanup();\n          cleanup?.();\n        };\n      },\n      trackExitAnimation: ({\n        send,\n        scope\n      }) => {\n        let cleanup;\n        const rafCleanup = raf(() => {\n          const contentEl = getContentEl(scope);\n          if (!contentEl) return;\n          const animationName = getComputedStyle(contentEl).animationName;\n          const hasNoAnimation = !animationName || animationName === \"none\";\n          if (hasNoAnimation) {\n            send({\n              type: \"animation.end\"\n            });\n            return;\n          }\n          const onEnd = event => {\n            const target = getEventTarget(event);\n            if (target === contentEl) {\n              send({\n                type: \"animation.end\"\n              });\n            }\n          };\n          contentEl.addEventListener(\"animationend\", onEnd);\n          const restoreStyles = setStyle(contentEl, {\n            animationFillMode: \"forwards\"\n          });\n          cleanup = () => {\n            contentEl.removeEventListener(\"animationend\", onEnd);\n            nextTick(() => restoreStyles());\n          };\n        });\n        return () => {\n          rafCleanup();\n          cleanup?.();\n        };\n      }\n    },\n    actions: {\n      setInitial: ({\n        context\n      }) => {\n        context.set(\"initial\", true);\n      },\n      clearInitial: ({\n        context\n      }) => {\n        context.set(\"initial\", false);\n      },\n      cleanupNode: ({\n        refs\n      }) => {\n        refs.set(\"stylesRef\", null);\n      },\n      measureSize: ({\n        context,\n        flush,\n        scope\n      }) => {\n        const contentEl = getContentEl(scope);\n        if (!contentEl) return;\n        const {\n          height,\n          width\n        } = contentEl.getBoundingClientRect();\n        flush(() => {\n          context.set(\"size\", {\n            height,\n            width\n          });\n        });\n      },\n      computeSize: ({\n        refs,\n        scope,\n        flush,\n        context\n      }) => {\n        refs.get(\"cleanup\")?.();\n        const rafCleanup = raf(() => {\n          const contentEl = getContentEl(scope);\n          if (!contentEl) return;\n          const hidden = contentEl.hidden;\n          contentEl.style.animationName = \"none\";\n          contentEl.style.animationDuration = \"0s\";\n          contentEl.hidden = false;\n          const rect = contentEl.getBoundingClientRect();\n          flush(() => {\n            context.set(\"size\", {\n              height: rect.height,\n              width: rect.width\n            });\n          });\n          if (context.get(\"initial\")) {\n            contentEl.style.animationName = \"\";\n            contentEl.style.animationDuration = \"\";\n          }\n          contentEl.hidden = hidden;\n        });\n        refs.set(\"cleanup\", rafCleanup);\n      },\n      invokeOnOpen: ({\n        prop\n      }) => {\n        prop(\"onOpenChange\")?.({\n          open: true\n        });\n      },\n      invokeOnClose: ({\n        prop\n      }) => {\n        prop(\"onOpenChange\")?.({\n          open: false\n        });\n      },\n      invokeOnExitComplete: ({\n        prop\n      }) => {\n        prop(\"onExitComplete\")?.();\n      },\n      toggleVisibility: ({\n        prop,\n        send\n      }) => {\n        send({\n          type: prop(\"open\") ? \"controlled.open\" : \"controlled.close\"\n        });\n      }\n    }\n  }\n});\nvar props = createProps()([\"dir\", \"disabled\", \"getRootNode\", \"id\", \"ids\", \"onExitComplete\", \"onOpenChange\", \"defaultOpen\", \"open\"]);\nvar splitProps = createSplitProps(props);\nexport { anatomy, connect, machine, props, splitProps };","map":null,"metadata":{},"sourceType":"module"}