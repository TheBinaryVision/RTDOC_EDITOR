{"ast":null,"code":"import { createAnatomy } from '@zag-js/anatomy';\nimport { getPlacement, getPlacementStyles } from '@zag-js/popper';\nimport { createGuards, createMachine } from '@zag-js/core';\nimport { trackDismissableElement } from '@zag-js/dismissable';\nimport { createProps } from '@zag-js/types';\nimport { createSplitProps } from '@zag-js/utils';\n\n// src/hover-card.anatomy.ts\nvar anatomy = createAnatomy(\"hoverCard\").parts(\"arrow\", \"arrowTip\", \"trigger\", \"positioner\", \"content\");\nvar parts = anatomy.build();\n\n// src/hover-card.dom.ts\nvar getTriggerId = ctx => ctx.ids?.trigger ?? `hover-card:${ctx.id}:trigger`;\nvar getContentId = ctx => ctx.ids?.content ?? `hover-card:${ctx.id}:content`;\nvar getPositionerId = ctx => ctx.ids?.positioner ?? `hover-card:${ctx.id}:popper`;\nvar getArrowId = ctx => ctx.ids?.arrow ?? `hover-card:${ctx.id}:arrow`;\nvar getTriggerEl = ctx => ctx.getById(getTriggerId(ctx));\nvar getContentEl = ctx => ctx.getById(getContentId(ctx));\nvar getPositionerEl = ctx => ctx.getById(getPositionerId(ctx));\n\n// src/hover-card.connect.ts\nfunction connect(service, normalize) {\n  const {\n    state,\n    send,\n    prop,\n    context,\n    scope\n  } = service;\n  const open = state.hasTag(\"open\");\n  const popperStyles = getPlacementStyles({\n    ...prop(\"positioning\"),\n    placement: context.get(\"currentPlacement\")\n  });\n  return {\n    open,\n    setOpen(nextOpen) {\n      const open2 = state.hasTag(\"open\");\n      if (open2 === nextOpen) return;\n      send({\n        type: nextOpen ? \"OPEN\" : \"CLOSE\"\n      });\n    },\n    reposition(options = {}) {\n      send({\n        type: \"POSITIONING.SET\",\n        options\n      });\n    },\n    getArrowProps() {\n      return normalize.element({\n        id: getArrowId(scope),\n        ...parts.arrow.attrs,\n        dir: prop(\"dir\"),\n        style: popperStyles.arrow\n      });\n    },\n    getArrowTipProps() {\n      return normalize.element({\n        ...parts.arrowTip.attrs,\n        dir: prop(\"dir\"),\n        style: popperStyles.arrowTip\n      });\n    },\n    getTriggerProps() {\n      return normalize.element({\n        ...parts.trigger.attrs,\n        dir: prop(\"dir\"),\n        \"data-placement\": context.get(\"currentPlacement\"),\n        id: getTriggerId(scope),\n        \"data-state\": open ? \"open\" : \"closed\",\n        onPointerEnter(event) {\n          if (event.pointerType === \"touch\") return;\n          send({\n            type: \"POINTER_ENTER\",\n            src: \"trigger\"\n          });\n        },\n        onPointerLeave(event) {\n          if (event.pointerType === \"touch\") return;\n          send({\n            type: \"POINTER_LEAVE\",\n            src: \"trigger\"\n          });\n        },\n        onFocus() {\n          send({\n            type: \"TRIGGER_FOCUS\"\n          });\n        },\n        onBlur() {\n          send({\n            type: \"TRIGGER_BLUR\"\n          });\n        }\n      });\n    },\n    getPositionerProps() {\n      return normalize.element({\n        id: getPositionerId(scope),\n        ...parts.positioner.attrs,\n        dir: prop(\"dir\"),\n        style: popperStyles.floating\n      });\n    },\n    getContentProps() {\n      return normalize.element({\n        ...parts.content.attrs,\n        dir: prop(\"dir\"),\n        id: getContentId(scope),\n        hidden: !open,\n        tabIndex: -1,\n        \"data-state\": open ? \"open\" : \"closed\",\n        \"data-placement\": context.get(\"currentPlacement\"),\n        onPointerEnter(event) {\n          if (event.pointerType === \"touch\") return;\n          send({\n            type: \"POINTER_ENTER\",\n            src: \"content\"\n          });\n        },\n        onPointerLeave(event) {\n          if (event.pointerType === \"touch\") return;\n          send({\n            type: \"POINTER_LEAVE\",\n            src: \"content\"\n          });\n        }\n      });\n    }\n  };\n}\nvar {\n  not,\n  and\n} = createGuards();\nvar machine = createMachine({\n  props({\n    props: props2\n  }) {\n    return {\n      openDelay: 700,\n      closeDelay: 300,\n      ...props2,\n      positioning: {\n        placement: \"bottom\",\n        ...props2.positioning\n      }\n    };\n  },\n  initialState({\n    prop\n  }) {\n    const open = prop(\"open\") || prop(\"defaultOpen\");\n    return open ? \"open\" : \"closed\";\n  },\n  context({\n    prop,\n    bindable\n  }) {\n    return {\n      open: bindable(() => ({\n        defaultValue: prop(\"defaultOpen\"),\n        value: prop(\"open\"),\n        onChange(value) {\n          prop(\"onOpenChange\")?.({\n            open: value\n          });\n        }\n      })),\n      currentPlacement: bindable(() => ({\n        defaultValue: void 0\n      })),\n      isPointer: bindable(() => ({\n        defaultValue: false\n      }))\n    };\n  },\n  watch({\n    track,\n    context,\n    action\n  }) {\n    track([() => context.get(\"open\")], () => {\n      action([\"toggleVisibility\"]);\n    });\n  },\n  states: {\n    closed: {\n      tags: [\"closed\"],\n      entry: [\"clearIsPointer\"],\n      on: {\n        \"CONTROLLED.OPEN\": {\n          target: \"open\"\n        },\n        POINTER_ENTER: {\n          target: \"opening\",\n          actions: [\"setIsPointer\"]\n        },\n        TRIGGER_FOCUS: {\n          target: \"opening\"\n        },\n        OPEN: {\n          target: \"opening\"\n        }\n      }\n    },\n    opening: {\n      tags: [\"closed\"],\n      effects: [\"waitForOpenDelay\"],\n      on: {\n        OPEN_DELAY: [{\n          guard: \"isOpenControlled\",\n          actions: [\"invokeOnOpen\"]\n        }, {\n          target: \"open\",\n          actions: [\"invokeOnOpen\"]\n        }],\n        \"CONTROLLED.OPEN\": {\n          target: \"open\"\n        },\n        \"CONTROLLED.CLOSE\": {\n          target: \"closed\"\n        },\n        POINTER_LEAVE: [{\n          guard: \"isOpenControlled\",\n          // We trigger toggleVisibility manually since the `ctx.open` has not changed yet (at this point)\n          actions: [\"invokeOnClose\", \"toggleVisibility\"]\n        }, {\n          target: \"closed\",\n          actions: [\"invokeOnClose\"]\n        }],\n        TRIGGER_BLUR: [{\n          guard: and(\"isOpenControlled\", not(\"isPointer\")),\n          // We trigger toggleVisibility manually since the `ctx.open` has not changed yet (at this point)\n          actions: [\"invokeOnClose\", \"toggleVisibility\"]\n        }, {\n          guard: not(\"isPointer\"),\n          target: \"closed\",\n          actions: [\"invokeOnClose\"]\n        }],\n        CLOSE: [{\n          guard: \"isOpenControlled\",\n          // We trigger toggleVisibility manually since the `ctx.open` has not changed yet (at this point)\n          actions: [\"invokeOnClose\", \"toggleVisibility\"]\n        }, {\n          target: \"closed\",\n          actions: [\"invokeOnClose\"]\n        }]\n      }\n    },\n    open: {\n      tags: [\"open\"],\n      effects: [\"trackDismissableElement\", \"trackPositioning\"],\n      on: {\n        \"CONTROLLED.CLOSE\": {\n          target: \"closed\"\n        },\n        POINTER_ENTER: {\n          actions: [\"setIsPointer\"]\n        },\n        POINTER_LEAVE: {\n          target: \"closing\"\n        },\n        CLOSE: [{\n          guard: \"isOpenControlled\",\n          actions: [\"invokeOnClose\"]\n        }, {\n          target: \"closed\",\n          actions: [\"invokeOnClose\"]\n        }],\n        TRIGGER_BLUR: [{\n          guard: and(\"isOpenControlled\", not(\"isPointer\")),\n          actions: [\"invokeOnClose\"]\n        }, {\n          guard: not(\"isPointer\"),\n          target: \"closed\",\n          actions: [\"invokeOnClose\"]\n        }],\n        \"POSITIONING.SET\": {\n          actions: [\"reposition\"]\n        }\n      }\n    },\n    closing: {\n      tags: [\"open\"],\n      effects: [\"trackPositioning\", \"waitForCloseDelay\"],\n      on: {\n        CLOSE_DELAY: [{\n          guard: \"isOpenControlled\",\n          actions: [\"invokeOnClose\"]\n        }, {\n          target: \"closed\",\n          actions: [\"invokeOnClose\"]\n        }],\n        \"CONTROLLED.CLOSE\": {\n          target: \"closed\"\n        },\n        \"CONTROLLED.OPEN\": {\n          target: \"open\"\n        },\n        POINTER_ENTER: {\n          target: \"open\",\n          // no need to invokeOnOpen here because it's still open (but about to close)\n          actions: [\"setIsPointer\"]\n        }\n      }\n    }\n  },\n  implementations: {\n    guards: {\n      isPointer: ({\n        context\n      }) => !!context.get(\"isPointer\"),\n      isOpenControlled: ({\n        prop\n      }) => prop(\"open\") != null\n    },\n    effects: {\n      waitForOpenDelay({\n        send,\n        prop\n      }) {\n        const id = setTimeout(() => {\n          send({\n            type: \"OPEN_DELAY\"\n          });\n        }, prop(\"openDelay\"));\n        return () => clearTimeout(id);\n      },\n      waitForCloseDelay({\n        send,\n        prop\n      }) {\n        const id = setTimeout(() => {\n          send({\n            type: \"CLOSE_DELAY\"\n          });\n        }, prop(\"closeDelay\"));\n        return () => clearTimeout(id);\n      },\n      trackPositioning({\n        context,\n        prop,\n        scope\n      }) {\n        if (!context.get(\"currentPlacement\")) {\n          context.set(\"currentPlacement\", prop(\"positioning\").placement);\n        }\n        const getPositionerEl2 = () => getPositionerEl(scope);\n        return getPlacement(getTriggerEl(scope), getPositionerEl2, {\n          ...prop(\"positioning\"),\n          defer: true,\n          onComplete(data) {\n            context.set(\"currentPlacement\", data.placement);\n          }\n        });\n      },\n      trackDismissableElement({\n        send,\n        scope,\n        prop\n      }) {\n        const getContentEl2 = () => getContentEl(scope);\n        return trackDismissableElement(getContentEl2, {\n          defer: true,\n          exclude: [getTriggerEl(scope)],\n          onDismiss() {\n            send({\n              type: \"CLOSE\",\n              src: \"interact-outside\"\n            });\n          },\n          onInteractOutside: prop(\"onInteractOutside\"),\n          onPointerDownOutside: prop(\"onPointerDownOutside\"),\n          onFocusOutside(event) {\n            event.preventDefault();\n            prop(\"onFocusOutside\")?.(event);\n          }\n        });\n      }\n    },\n    actions: {\n      invokeOnClose({\n        prop\n      }) {\n        prop(\"onOpenChange\")?.({\n          open: false\n        });\n      },\n      invokeOnOpen({\n        prop\n      }) {\n        prop(\"onOpenChange\")?.({\n          open: true\n        });\n      },\n      setIsPointer({\n        context\n      }) {\n        context.set(\"isPointer\", true);\n      },\n      clearIsPointer({\n        context\n      }) {\n        context.set(\"isPointer\", false);\n      },\n      reposition({\n        context,\n        prop,\n        scope,\n        event\n      }) {\n        const getPositionerEl2 = () => getPositionerEl(scope);\n        getPlacement(getTriggerEl(scope), getPositionerEl2, {\n          ...prop(\"positioning\"),\n          ...event.options,\n          defer: true,\n          listeners: false,\n          onComplete(data) {\n            context.set(\"currentPlacement\", data.placement);\n          }\n        });\n      },\n      toggleVisibility({\n        prop,\n        event,\n        send\n      }) {\n        queueMicrotask(() => {\n          send({\n            type: prop(\"open\") ? \"CONTROLLED.OPEN\" : \"CONTROLLED.CLOSE\",\n            previousEvent: event\n          });\n        });\n      }\n    }\n  }\n});\nvar props = createProps()([\"closeDelay\", \"dir\", \"getRootNode\", \"id\", \"ids\", \"onOpenChange\", \"defaultOpen\", \"open\", \"openDelay\", \"positioning\", \"onInteractOutside\", \"onPointerDownOutside\", \"onFocusOutside\"]);\nvar splitProps = createSplitProps(props);\nexport { anatomy, connect, machine, props, splitProps };","map":null,"metadata":{},"sourceType":"module"}