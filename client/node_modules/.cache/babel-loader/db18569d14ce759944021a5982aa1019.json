{"ast":null,"code":"import { createAnatomy } from '@zag-js/anatomy';\nimport { createGuards, createMachine, mergeProps } from '@zag-js/core';\nimport { isHTMLElement, contains, raf, getComputedStyle as getComputedStyle$1, getWindow, dataAttr, getDocument } from '@zag-js/dom-query';\nimport { getPlacement, getPlacementStyles } from '@zag-js/popper';\nimport { trackDismissableBranch } from '@zag-js/dismissable';\nimport { trapFocus } from '@zag-js/focus-trap';\nimport { trackInteractOutside } from '@zag-js/interact-outside';\nimport { prevIndex, nextIndex, isString, isEqual, createSplitProps } from '@zag-js/utils';\nimport { createProps } from '@zag-js/types';\n\n// src/tour.anatomy.ts\nvar anatomy = createAnatomy(\"tour\").parts(\"content\", \"actionTrigger\", \"closeTrigger\", \"progressText\", \"title\", \"description\", \"positioner\", \"arrow\", \"arrowTip\", \"backdrop\", \"spotlight\");\nvar parts = anatomy.build();\n\n// src/tour.dom.ts\nvar getPositionerId = ctx => ctx.ids?.positioner ?? `tour-positioner-${ctx.id}`;\nvar getContentId = ctx => ctx.ids?.content ?? `tour-content-${ctx.id}`;\nvar getTitleId = ctx => ctx.ids?.title ?? `tour-title-${ctx.id}`;\nvar getDescriptionId = ctx => ctx.ids?.description ?? `tour-desc-${ctx.id}`;\nvar getArrowId = ctx => ctx.ids?.arrow ?? `tour-arrow-${ctx.id}`;\nvar getBackdropId = ctx => ctx.ids?.backdrop ?? `tour-backdrop-${ctx.id}`;\nvar getContentEl = ctx => ctx.getById(getContentId(ctx));\nvar getPositionerEl = ctx => ctx.getById(getPositionerId(ctx));\nvar getBackdropEl = ctx => ctx.getById(getBackdropId(ctx));\n\n// src/utils/clip-path.ts\nfunction getClipPath(options) {\n  const {\n    radius = 0,\n    rootSize: {\n      width: w,\n      height: h\n    },\n    rect: {\n      width,\n      height,\n      x,\n      y\n    },\n    enabled = true\n  } = options;\n  if (!enabled) return \"\";\n  const {\n    topLeft = 0,\n    topRight = 0,\n    bottomRight = 0,\n    bottomLeft = 0\n  } = typeof radius === \"number\" ? {\n    topLeft: radius,\n    topRight: radius,\n    bottomRight: radius,\n    bottomLeft: radius\n  } : radius;\n  return `M${w},${h}  H0  V0  H${w}  V${h}  Z  M${x + topLeft},${y}  a${topLeft},${topLeft},0,0,0-${topLeft},${topLeft}  V${height + y - bottomLeft}  a${bottomLeft},${bottomLeft},0,0,0,${bottomLeft},${bottomLeft}  H${width + x - bottomRight}  a${bottomRight},${bottomRight},0,0,0,${bottomRight}-${bottomRight}  V${y + topRight}  a${topRight},${topRight},0,0,0-${topRight}-${topRight}  Z`;\n}\n\n// src/utils/step.ts\nvar isTooltipStep = step => {\n  return step?.type === \"tooltip\";\n};\nvar isDialogStep = step => {\n  return step?.type === \"dialog\";\n};\nvar isTooltipPlacement = placement => {\n  return placement != null && placement != \"center\";\n};\nvar normalizeStep = step => {\n  if (step.type === \"floating\") {\n    return {\n      backdrop: false,\n      arrow: false,\n      placement: \"bottom-end\",\n      ...step\n    };\n  }\n  if (step.target == null || step.type === \"dialog\") {\n    return {\n      type: \"dialog\",\n      placement: \"center\",\n      backdrop: true,\n      ...step\n    };\n  }\n  if (!step.type || step.type === \"tooltip\") {\n    return {\n      type: \"tooltip\",\n      arrow: true,\n      backdrop: true,\n      ...step\n    };\n  }\n  return step;\n};\nvar findStep = (steps, id) => {\n  const res = id != null ? steps.find(step => step.id === id) : null;\n  return res ? normalizeStep(res) : null;\n};\nvar findStepIndex = (steps, id) => {\n  return id != null ? steps.findIndex(step => step.id === id) : -1;\n};\n\n// src/tour.connect.ts\nfunction connect(service, normalize) {\n  const {\n    state,\n    context,\n    computed,\n    send,\n    prop,\n    scope\n  } = service;\n  const open = state.hasTag(\"open\");\n  const steps = Array.from(context.get(\"steps\"));\n  const stepIndex = computed(\"stepIndex\");\n  const step = computed(\"step\");\n  const hasTarget = typeof step?.target?.() !== \"undefined\";\n  const hasNextStep = computed(\"hasNextStep\");\n  const hasPrevStep = computed(\"hasPrevStep\");\n  const firstStep = computed(\"isFirstStep\");\n  const lastStep = computed(\"isLastStep\");\n  const placement = context.get(\"currentPlacement\");\n  const targetRect = context.get(\"targetRect\");\n  const popperStyles = getPlacementStyles({\n    strategy: \"absolute\",\n    placement: isTooltipPlacement(placement) ? placement : void 0\n  });\n  const clipPath = getClipPath({\n    enabled: isTooltipStep(step),\n    rect: targetRect,\n    rootSize: context.get(\"boundarySize\"),\n    radius: prop(\"spotlightRadius\")\n  });\n  const actionMap = {\n    next() {\n      send({\n        type: \"STEP.NEXT\",\n        src: \"actionTrigger\"\n      });\n    },\n    prev() {\n      send({\n        type: \"STEP.PREV\",\n        src: \"actionTrigger\"\n      });\n    },\n    dismiss() {\n      send({\n        type: \"DISMISS\",\n        src: \"actionTrigger\"\n      });\n    },\n    goto(id) {\n      send({\n        type: \"STEP.SET\",\n        value: id,\n        src: \"actionTrigger\"\n      });\n    }\n  };\n  return {\n    open,\n    totalSteps: steps.length,\n    stepIndex,\n    step,\n    hasNextStep,\n    hasPrevStep,\n    firstStep,\n    lastStep,\n    addStep(step2) {\n      const next = steps.concat(step2);\n      send({\n        type: \"STEPS.SET\",\n        value: next,\n        src: \"addStep\"\n      });\n    },\n    removeStep(id) {\n      const next = steps.filter(step2 => step2.id !== id);\n      send({\n        type: \"STEPS.SET\",\n        value: next,\n        src: \"removeStep\"\n      });\n    },\n    updateStep(id, stepOverrides) {\n      const next = steps.map(step2 => step2.id === id ? mergeProps(step2, stepOverrides) : step2);\n      send({\n        type: \"STEPS.SET\",\n        value: next,\n        src: \"updateStep\"\n      });\n    },\n    setSteps(steps2) {\n      send({\n        type: \"STEPS.SET\",\n        value: steps2,\n        src: \"setSteps\"\n      });\n    },\n    setStep(id) {\n      send({\n        type: \"STEP.SET\",\n        value: id\n      });\n    },\n    start(id) {\n      send({\n        type: \"START\",\n        id\n      });\n    },\n    isValidStep(id) {\n      return steps.some(step2 => step2.id === id);\n    },\n    isCurrentStep(id) {\n      return Boolean(step?.id === id);\n    },\n    next() {\n      send({\n        type: \"STEP.NEXT\"\n      });\n    },\n    prev() {\n      send({\n        type: \"STEP.PREV\"\n      });\n    },\n    getProgressPercent() {\n      return stepIndex / steps.length * 100;\n    },\n    getProgressText() {\n      const effectiveSteps = steps.filter(step2 => step2.type !== \"wait\");\n      const index = findStepIndex(effectiveSteps, step?.id);\n      const details = {\n        current: index,\n        total: effectiveSteps.length\n      };\n      return prop(\"translations\").progressText?.(details) ?? \"\";\n    },\n    getBackdropProps() {\n      return normalize.element({\n        ...parts.backdrop.attrs,\n        id: getBackdropId(scope),\n        dir: prop(\"dir\"),\n        hidden: !open,\n        \"data-state\": open ? \"open\" : \"closed\",\n        \"data-type\": step?.type,\n        style: {\n          \"--tour-layer\": 0,\n          clipPath: isTooltipStep(step) ? `path(\"${clipPath}\")` : void 0,\n          position: \"absolute\",\n          inset: \"0\",\n          willChange: \"clip-path\"\n        }\n      });\n    },\n    getSpotlightProps() {\n      return normalize.element({\n        ...parts.spotlight.attrs,\n        hidden: !open || !step?.target?.(),\n        style: {\n          \"--tour-layer\": 1,\n          position: \"absolute\",\n          width: `${targetRect.width}px`,\n          height: `${targetRect.height}px`,\n          left: `${targetRect.x}px`,\n          top: `${targetRect.y}px`,\n          borderRadius: `${prop(\"spotlightRadius\")}px`,\n          pointerEvents: \"none\"\n        }\n      });\n    },\n    getProgressTextProps() {\n      return normalize.element({\n        ...parts.progressText.attrs\n      });\n    },\n    getPositionerProps() {\n      return normalize.element({\n        ...parts.positioner.attrs,\n        dir: prop(\"dir\"),\n        id: getPositionerId(scope),\n        \"data-type\": step?.type,\n        \"data-placement\": placement,\n        style: {\n          \"--tour-layer\": 2,\n          ...(step?.type === \"tooltip\" && popperStyles.floating)\n        }\n      });\n    },\n    getArrowProps() {\n      return normalize.element({\n        id: getArrowId(scope),\n        ...parts.arrow.attrs,\n        dir: prop(\"dir\"),\n        hidden: step?.type !== \"tooltip\",\n        style: step?.type === \"tooltip\" ? popperStyles.arrow : void 0,\n        opacity: hasTarget ? void 0 : 0\n      });\n    },\n    getArrowTipProps() {\n      return normalize.element({\n        ...parts.arrowTip.attrs,\n        dir: prop(\"dir\"),\n        style: popperStyles.arrowTip\n      });\n    },\n    getContentProps() {\n      return normalize.element({\n        ...parts.content.attrs,\n        id: getContentId(scope),\n        dir: prop(\"dir\"),\n        role: \"alertdialog\",\n        \"aria-modal\": \"true\",\n        \"aria-live\": \"polite\",\n        \"aria-atomic\": \"true\",\n        hidden: !open,\n        \"data-state\": open ? \"open\" : \"closed\",\n        \"data-type\": step?.type,\n        \"data-placement\": placement,\n        \"data-step\": step?.id,\n        \"aria-labelledby\": getTitleId(scope),\n        \"aria-describedby\": getDescriptionId(scope),\n        tabIndex: -1,\n        onKeyDown(event) {\n          if (event.defaultPrevented) return;\n          if (!prop(\"keyboardNavigation\")) return;\n          const isRtl = prop(\"dir\") === \"rtl\";\n          switch (event.key) {\n            case \"ArrowRight\":\n              if (!hasNextStep) return;\n              send({\n                type: isRtl ? \"STEP.PREV\" : \"STEP.NEXT\",\n                src: \"keydown\"\n              });\n              break;\n            case \"ArrowLeft\":\n              if (!hasPrevStep) return;\n              send({\n                type: isRtl ? \"STEP.NEXT\" : \"STEP.PREV\",\n                src: \"keydown\"\n              });\n              break;\n          }\n        }\n      });\n    },\n    getTitleProps() {\n      return normalize.element({\n        ...parts.title.attrs,\n        id: getTitleId(scope),\n        \"data-placement\": hasTarget ? placement : \"center\"\n      });\n    },\n    getDescriptionProps() {\n      return normalize.element({\n        ...parts.description.attrs,\n        id: getDescriptionId(scope),\n        \"data-placement\": hasTarget ? placement : \"center\"\n      });\n    },\n    getCloseTriggerProps() {\n      return normalize.element({\n        ...parts.closeTrigger.attrs,\n        \"data-type\": step?.type,\n        \"aria-label\": prop(\"translations\").close,\n        onClick: actionMap.dismiss\n      });\n    },\n    getActionTriggerProps(props2) {\n      const {\n        action,\n        attrs\n      } = props2.action;\n      let actionProps = {};\n      switch (action) {\n        case \"next\":\n          actionProps = {\n            \"data-type\": \"next\",\n            disabled: !hasNextStep,\n            \"data-disabled\": dataAttr(!hasNextStep),\n            \"aria-label\": prop(\"translations\").nextStep,\n            onClick: actionMap.next\n          };\n          break;\n        case \"prev\":\n          actionProps = {\n            \"data-type\": \"prev\",\n            disabled: !hasPrevStep,\n            \"data-disabled\": dataAttr(!hasPrevStep),\n            \"aria-label\": prop(\"translations\").prevStep,\n            onClick: actionMap.prev\n          };\n          break;\n        case \"dismiss\":\n          actionProps = {\n            \"data-type\": \"close\",\n            \"aria-label\": prop(\"translations\").close,\n            onClick: actionMap.dismiss\n          };\n          break;\n        default:\n          actionProps = {\n            \"data-type\": \"custom\",\n            onClick() {\n              if (typeof action === \"function\") {\n                action(actionMap);\n              }\n            }\n          };\n          break;\n      }\n      return normalize.button({\n        ...parts.actionTrigger.attrs,\n        type: \"button\",\n        ...attrs,\n        ...actionProps\n      });\n    }\n  };\n}\nfunction getFrameElement(win) {\n  return win.parent && Object.getPrototypeOf(win.parent) ? win.frameElement : null;\n}\nvar normalizeEventPoint = event => {\n  let clientX = event.clientX;\n  let clientY = event.clientY;\n  let win = event.view || window;\n  let frame = getFrameElement(win);\n  while (frame) {\n    const iframeRect = frame.getBoundingClientRect();\n    const css = getComputedStyle(frame);\n    const left = iframeRect.left + (frame.clientLeft + parseFloat(css.paddingLeft));\n    const top = iframeRect.top + (frame.clientTop + parseFloat(css.paddingTop));\n    clientX += left;\n    clientY += top;\n    win = getWindow(frame);\n    frame = getFrameElement(win);\n  }\n  return {\n    clientX,\n    clientY\n  };\n};\nfunction isEventInRect(rect, event) {\n  const {\n    clientX,\n    clientY\n  } = normalizeEventPoint(event);\n  return rect.y <= clientY && clientY <= rect.y + rect.height && rect.x <= clientX && clientX <= rect.x + rect.width;\n}\nfunction offset(r, i) {\n  const dx = i.x || 0;\n  const dy = i.y || 0;\n  return {\n    x: r.x - dx,\n    y: r.y - dy,\n    width: r.width + dx + dx,\n    height: r.height + dy + dy\n  };\n}\n\n// src/tour.machine.ts\nvar {\n  and\n} = createGuards();\nvar getEffectiveSteps = steps => steps.filter(step => step.type !== \"wait\");\nvar getProgress = (steps, stepIndex) => {\n  const effectiveLength = getEffectiveSteps(steps).length;\n  return (stepIndex + 1) / effectiveLength;\n};\nvar machine = createMachine({\n  props({\n    props: props2\n  }) {\n    return {\n      preventInteraction: false,\n      closeOnInteractOutside: true,\n      closeOnEscape: true,\n      keyboardNavigation: true,\n      spotlightOffset: {\n        x: 10,\n        y: 10\n      },\n      spotlightRadius: 4,\n      ...props2,\n      translations: {\n        nextStep: \"next step\",\n        prevStep: \"previous step\",\n        close: \"close tour\",\n        progressText: ({\n          current,\n          total\n        }) => `${current + 1} of ${total}`,\n        skip: \"skip tour\",\n        ...props2.translations\n      }\n    };\n  },\n  initialState() {\n    return \"tour.inactive\";\n  },\n  context({\n    prop,\n    bindable,\n    getContext\n  }) {\n    return {\n      steps: bindable(() => ({\n        defaultValue: prop(\"steps\") ?? [],\n        onChange(value) {\n          prop(\"onStepsChange\")?.({\n            steps: value\n          });\n        }\n      })),\n      stepId: bindable(() => ({\n        defaultValue: prop(\"stepId\"),\n        sync: true,\n        onChange(value) {\n          const context = getContext();\n          const steps = context.get(\"steps\");\n          const stepIndex = findStepIndex(steps, value);\n          const progress = getProgress(steps, stepIndex);\n          const complete = stepIndex == steps.length - 1;\n          prop(\"onStepChange\")?.({\n            stepId: value,\n            stepIndex,\n            totalSteps: steps.length,\n            complete,\n            progress\n          });\n        }\n      })),\n      resolvedTarget: bindable(() => ({\n        sync: true,\n        defaultValue: null\n      })),\n      targetRect: bindable(() => ({\n        defaultValue: {\n          width: 0,\n          height: 0,\n          x: 0,\n          y: 0\n        }\n      })),\n      boundarySize: bindable(() => ({\n        defaultValue: {\n          width: 0,\n          height: 0\n        }\n      })),\n      currentPlacement: bindable(() => ({\n        defaultValue: void 0\n      }))\n    };\n  },\n  computed: {\n    stepIndex: ({\n      context\n    }) => findStepIndex(context.get(\"steps\"), context.get(\"stepId\")),\n    step: ({\n      context\n    }) => findStep(context.get(\"steps\"), context.get(\"stepId\")),\n    hasNextStep: ({\n      context,\n      computed\n    }) => computed(\"stepIndex\") < context.get(\"steps\").length - 1,\n    hasPrevStep: ({\n      computed\n    }) => computed(\"stepIndex\") > 0,\n    isFirstStep: ({\n      computed\n    }) => computed(\"stepIndex\") === 0,\n    isLastStep: ({\n      context,\n      computed\n    }) => computed(\"stepIndex\") === context.get(\"steps\").length - 1,\n    progress: ({\n      context,\n      computed\n    }) => {\n      const effectiveLength = getEffectiveSteps(context.get(\"steps\")).length;\n      return (computed(\"stepIndex\") + 1) / effectiveLength;\n    }\n  },\n  watch({\n    track,\n    context,\n    action\n  }) {\n    track([() => context.get(\"stepId\")], () => {\n      queueMicrotask(() => {\n        action([\"setResolvedTarget\", \"raiseStepChange\", \"syncTargetAttrs\"]);\n      });\n    });\n  },\n  effects: [\"trackBoundarySize\"],\n  exit: [\"cleanupRefs\"],\n  on: {\n    \"STEPS.SET\": {\n      actions: [\"setSteps\"]\n    },\n    \"STEP.SET\": {\n      actions: [\"setStep\"]\n    },\n    \"STEP.NEXT\": {\n      actions: [\"setNextStep\"]\n    },\n    \"STEP.PREV\": {\n      actions: [\"setPrevStep\"]\n    },\n    \"STEP.CHANGED\": [{\n      guard: and(\"isValidStep\", \"hasResolvedTarget\"),\n      target: \"target.scrolling\",\n      actions: [\"cleanupRefs\"]\n    }, {\n      guard: and(\"isValidStep\", \"hasTarget\"),\n      target: \"target.resolving\",\n      actions: [\"cleanupRefs\"]\n    }, {\n      guard: and(\"isValidStep\", \"isWaitingStep\"),\n      target: \"step.waiting\",\n      actions: [\"cleanupRefs\"]\n    }, {\n      guard: \"isValidStep\",\n      target: \"tour.active\",\n      actions: [\"cleanupRefs\"]\n    }],\n    DISMISS: [{\n      guard: \"isLastStep\",\n      target: \"tour.inactive\",\n      actions: [\"invokeOnDismiss\", \"invokeOnComplete\", \"clearStep\"]\n    }, {\n      target: \"tour.inactive\",\n      actions: [\"invokeOnDismiss\", \"clearStep\"]\n    }]\n  },\n  states: {\n    \"tour.inactive\": {\n      tags: [\"closed\"],\n      on: {\n        START: {\n          actions: [\"setInitialStep\", \"invokeOnStart\"]\n        }\n      }\n    },\n    \"target.resolving\": {\n      tags: [\"closed\"],\n      effects: [\"waitForTarget\", \"waitForTargetTimeout\"],\n      on: {\n        \"TARGET.NOT_FOUND\": {\n          target: \"tour.inactive\",\n          actions: [\"invokeOnNotFound\", \"clearStep\"]\n        },\n        \"TARGET.RESOLVED\": {\n          target: \"target.scrolling\",\n          actions: [\"setResolvedTarget\"]\n        }\n      }\n    },\n    \"target.scrolling\": {\n      tags: [\"open\"],\n      entry: [\"scrollToTarget\"],\n      effects: [\"waitForScrollEnd\", \"trapFocus\", \"trackPlacement\", \"trackDismissableBranch\", \"trackInteractOutside\", \"trackEscapeKeydown\"],\n      on: {\n        \"SCROLL.END\": {\n          target: \"tour.active\"\n        }\n      }\n    },\n    \"step.waiting\": {\n      tags: [\"closed\"]\n    },\n    \"tour.active\": {\n      tags: [\"open\"],\n      effects: [\"trapFocus\", \"trackPlacement\", \"trackDismissableBranch\", \"trackInteractOutside\", \"trackEscapeKeydown\"]\n    }\n  },\n  implementations: {\n    guards: {\n      isLastStep: ({\n        computed,\n        context\n      }) => computed(\"stepIndex\") === context.get(\"steps\").length - 1,\n      isValidStep: ({\n        context\n      }) => context.get(\"stepId\") != null,\n      hasTarget: ({\n        computed\n      }) => computed(\"step\")?.target != null,\n      hasResolvedTarget: ({\n        context\n      }) => context.get(\"resolvedTarget\") != null,\n      isWaitingStep: ({\n        computed\n      }) => computed(\"step\")?.type === \"wait\"\n    },\n    actions: {\n      scrollToTarget({\n        context\n      }) {\n        const node = context.get(\"resolvedTarget\");\n        node?.scrollIntoView({\n          behavior: \"instant\",\n          block: \"center\",\n          inline: \"center\"\n        });\n      },\n      setStep(params) {\n        const {\n          event\n        } = params;\n        setStep(params, event.value);\n      },\n      clearStep(params) {\n        const {\n          context\n        } = params;\n        context.set(\"targetRect\", {\n          width: 0,\n          height: 0,\n          x: 0,\n          y: 0\n        });\n        setStep(params, -1);\n      },\n      setInitialStep(params) {\n        const {\n          context,\n          event\n        } = params;\n        const steps = context.get(\"steps\");\n        if (steps.length === 0) return;\n        if (isString(event.value)) {\n          const idx = findStepIndex(steps, event.value);\n          setStep(params, idx);\n          return;\n        }\n        setStep(params, 0);\n      },\n      setNextStep(params) {\n        const {\n          context,\n          computed\n        } = params;\n        const steps = context.get(\"steps\");\n        const idx = nextIndex(steps, computed(\"stepIndex\"));\n        setStep(params, idx);\n      },\n      setPrevStep(params) {\n        const {\n          context,\n          computed\n        } = params;\n        const steps = context.get(\"steps\");\n        const idx = prevIndex(steps, computed(\"stepIndex\"));\n        setStep(params, idx);\n      },\n      invokeOnStart({\n        prop,\n        context,\n        computed\n      }) {\n        prop(\"onStatusChange\")?.({\n          status: \"started\",\n          stepId: context.get(\"stepId\"),\n          stepIndex: computed(\"stepIndex\")\n        });\n      },\n      invokeOnDismiss({\n        prop,\n        context,\n        computed\n      }) {\n        prop(\"onStatusChange\")?.({\n          status: \"dismissed\",\n          stepId: context.get(\"stepId\"),\n          stepIndex: computed(\"stepIndex\")\n        });\n      },\n      invokeOnComplete({\n        prop,\n        context,\n        computed\n      }) {\n        prop(\"onStatusChange\")?.({\n          status: \"completed\",\n          stepId: context.get(\"stepId\"),\n          stepIndex: computed(\"stepIndex\")\n        });\n      },\n      invokeOnSkip({\n        prop,\n        context,\n        computed\n      }) {\n        prop(\"onStatusChange\")?.({\n          status: \"skipped\",\n          stepId: context.get(\"stepId\"),\n          stepIndex: computed(\"stepIndex\")\n        });\n      },\n      invokeOnNotFound({\n        prop,\n        context,\n        computed\n      }) {\n        prop(\"onStatusChange\")?.({\n          status: \"not-found\",\n          stepId: context.get(\"stepId\"),\n          stepIndex: computed(\"stepIndex\")\n        });\n      },\n      raiseStepChange({\n        send\n      }) {\n        send({\n          type: \"STEP.CHANGED\"\n        });\n      },\n      setResolvedTarget({\n        context,\n        event,\n        computed\n      }) {\n        const node = event.node ?? computed(\"step\")?.target?.();\n        context.set(\"resolvedTarget\", node ?? null);\n      },\n      syncTargetAttrs({\n        context,\n        refs,\n        prop\n      }) {\n        refs.get(\"_targetCleanup\")?.();\n        refs.set(\"_targetCleanup\", void 0);\n        const targetEl = context.get(\"resolvedTarget\");\n        if (!targetEl) return;\n        if (prop(\"preventInteraction\")) targetEl.inert = true;\n        targetEl.setAttribute(\"data-tour-highlighted\", \"\");\n        refs.set(\"_targetCleanup\", () => {\n          if (prop(\"preventInteraction\")) targetEl.inert = false;\n          targetEl.removeAttribute(\"data-tour-highlighted\");\n        });\n      },\n      cleanupRefs({\n        refs\n      }) {\n        refs.get(\"_targetCleanup\")?.();\n        refs.set(\"_targetCleanup\", void 0);\n        refs.get(\"_effectCleanup\")?.();\n        refs.set(\"_effectCleanup\", void 0);\n      },\n      validateSteps({\n        context\n      }) {\n        const ids = /* @__PURE__ */new Set();\n        context.get(\"steps\").forEach(step => {\n          if (ids.has(step.id)) {\n            throw new Error(`[zag-js/tour] Duplicate step id: ${step.id}`);\n          }\n          if (step.target == null && step.type == null) {\n            throw new Error(`[zag-js/tour] Step ${step.id} has no target or type. At least one of those is required.`);\n          }\n          ids.add(step.id);\n        });\n      }\n    },\n    effects: {\n      waitForScrollEnd({\n        send\n      }) {\n        const id = setTimeout(() => {\n          send({\n            type: \"SCROLL.END\"\n          });\n        }, 100);\n        return () => clearTimeout(id);\n      },\n      waitForTargetTimeout({\n        send\n      }) {\n        const id = setTimeout(() => {\n          send({\n            type: \"TARGET.NOT_FOUND\"\n          });\n        }, 3e3);\n        return () => clearTimeout(id);\n      },\n      waitForTarget({\n        scope,\n        computed,\n        send\n      }) {\n        const step = computed(\"step\");\n        if (!step) return;\n        const targetEl = step.target;\n        const win = scope.getWin();\n        const rootNode = scope.getRootNode();\n        const observer = new win.MutationObserver(() => {\n          const node = targetEl?.();\n          if (node) {\n            send({\n              type: \"TARGET.RESOLVED\",\n              node\n            });\n            observer.disconnect();\n          }\n        });\n        observer.observe(rootNode, {\n          childList: true,\n          subtree: true,\n          characterData: true\n        });\n        return () => {\n          observer.disconnect();\n        };\n      },\n      trackBoundarySize({\n        context,\n        scope\n      }) {\n        const win = scope.getWin();\n        const doc = scope.getDoc();\n        const onResize = () => {\n          const width = visualViewport?.width ?? win.innerWidth;\n          const height = doc.documentElement.scrollHeight;\n          context.set(\"boundarySize\", {\n            width,\n            height\n          });\n        };\n        onResize();\n        const viewport = win.visualViewport ?? win;\n        viewport.addEventListener(\"resize\", onResize);\n        return () => viewport.removeEventListener(\"resize\", onResize);\n      },\n      trackEscapeKeydown({\n        scope,\n        send,\n        prop\n      }) {\n        if (!prop(\"closeOnEscape\")) return;\n        const doc = scope.getDoc();\n        const onKeyDown = event => {\n          if (event.key === \"Escape\") {\n            event.preventDefault();\n            event.stopPropagation();\n            send({\n              type: \"DISMISS\",\n              src: \"esc\"\n            });\n          }\n        };\n        doc.addEventListener(\"keydown\", onKeyDown, true);\n        return () => {\n          doc.removeEventListener(\"keydown\", onKeyDown, true);\n        };\n      },\n      trackInteractOutside({\n        context,\n        computed,\n        scope,\n        send,\n        prop\n      }) {\n        const step = computed(\"step\");\n        if (step == null) return;\n        const contentEl = () => getContentEl(scope);\n        return trackInteractOutside(contentEl, {\n          defer: true,\n          exclude(target) {\n            return contains(step.target?.(), target);\n          },\n          onFocusOutside(event) {\n            prop(\"onFocusOutside\")?.(event);\n            if (!prop(\"closeOnInteractOutside\")) {\n              event.preventDefault();\n            }\n          },\n          onPointerDownOutside(event) {\n            prop(\"onPointerDownOutside\")?.(event);\n            const isWithin = isEventInRect(context.get(\"targetRect\"), event.detail.originalEvent);\n            if (isWithin) {\n              event.preventDefault();\n              return;\n            }\n            if (!prop(\"closeOnInteractOutside\")) {\n              event.preventDefault();\n            }\n          },\n          onInteractOutside(event) {\n            prop(\"onInteractOutside\")?.(event);\n            if (event.defaultPrevented) return;\n            send({\n              type: \"DISMISS\",\n              src: \"interact-outside\"\n            });\n          }\n        });\n      },\n      trackDismissableBranch({\n        computed,\n        scope\n      }) {\n        const step = computed(\"step\");\n        if (step == null) return;\n        const contentEl = () => getContentEl(scope);\n        return trackDismissableBranch(contentEl, {\n          defer: !contentEl()\n        });\n      },\n      trapFocus({\n        computed,\n        scope\n      }) {\n        const step = computed(\"step\");\n        if (step == null) return;\n        const contentEl = () => getContentEl(scope);\n        return trapFocus(contentEl, {\n          escapeDeactivates: false,\n          allowOutsideClick: true,\n          preventScroll: true,\n          returnFocusOnDeactivate: false\n        });\n      },\n      trackPlacement({\n        context,\n        computed,\n        scope,\n        prop\n      }) {\n        const step = computed(\"step\");\n        if (step == null) return;\n        context.set(\"currentPlacement\", step.placement ?? \"bottom\");\n        if (isDialogStep(step)) {\n          return syncZIndex(scope);\n        }\n        if (!isTooltipStep(step)) {\n          return;\n        }\n        const positionerEl = () => getPositionerEl(scope);\n        return getPlacement(context.get(\"resolvedTarget\"), positionerEl, {\n          defer: true,\n          placement: step.placement ?? \"bottom\",\n          strategy: \"absolute\",\n          gutter: 10,\n          offset: step.offset,\n          getAnchorRect(el) {\n            if (!isHTMLElement(el)) return null;\n            const rect = el.getBoundingClientRect();\n            return offset(rect, prop(\"spotlightOffset\"));\n          },\n          onComplete(data) {\n            const {\n              rects\n            } = data.middlewareData;\n            context.set(\"currentPlacement\", data.placement);\n            context.set(\"targetRect\", rects.reference);\n          }\n        });\n      }\n    }\n  }\n});\nfunction syncZIndex(scope) {\n  return raf(() => {\n    const contentEl = getContentEl(scope);\n    if (!contentEl) return;\n    const styles = getComputedStyle$1(contentEl);\n    const positionerEl = getPositionerEl(scope);\n    const backdropEl = getBackdropEl(scope);\n    if (positionerEl) {\n      positionerEl.style.setProperty(\"--z-index\", styles.zIndex);\n      positionerEl.style.setProperty(\"z-index\", \"var(--z-index)\");\n    }\n    if (backdropEl) {\n      backdropEl.style.setProperty(\"--z-index\", styles.zIndex);\n    }\n  });\n}\nfunction setStep(params, idx) {\n  const {\n    context,\n    refs,\n    computed,\n    prop\n  } = params;\n  const steps = context.get(\"steps\");\n  const step = steps[idx];\n  if (!step) {\n    context.set(\"stepId\", null);\n    return;\n  }\n  if (isEqual(context.get(\"stepId\"), step.id)) return;\n  const update = data => {\n    context.set(\"steps\", prev => prev.map((s, i) => i === idx ? {\n      ...s,\n      ...data\n    } : s));\n  };\n  const next = () => {\n    const idx2 = nextIndex(steps, computed(\"stepIndex\"));\n    context.set(\"stepId\", steps[idx2].id);\n  };\n  const goto = id => {\n    const step2 = findStep(steps, id);\n    if (!step2) return;\n    context.set(\"stepId\", step2.id);\n  };\n  const dismiss = () => {\n    context.set(\"stepId\", null);\n    prop(\"onStatusChange\")?.({\n      status: \"dismissed\",\n      stepId: null,\n      stepIndex: -1\n    });\n  };\n  const show = () => {\n    context.set(\"stepId\", step.id);\n  };\n  if (!step.effect) {\n    show();\n    return;\n  }\n  const cleanup = step.effect({\n    show,\n    next,\n    update,\n    target: step.target,\n    dismiss,\n    goto\n  });\n  refs.set(\"_effectCleanup\", cleanup);\n}\nvar props = createProps()([\"closeOnEscape\", \"closeOnInteractOutside\", \"dir\", \"getRootNode\", \"id\", \"ids\", \"keyboardNavigation\", \"onFocusOutside\", \"onInteractOutside\", \"onPointerDownOutside\", \"onStatusChange\", \"onStepChange\", \"onStepsChange\", \"preventInteraction\", \"spotlightOffset\", \"spotlightRadius\", \"stepId\", \"steps\", \"translations\"]);\nvar splitProps = createSplitProps(props);\nfunction waitForPromise(promise, controller, timeout) {\n  const {\n    signal\n  } = controller;\n  const wrappedPromise = new Promise((resolve, reject) => {\n    const timeoutId = setTimeout(() => {\n      reject(new Error(`Timeout of ${timeout}ms exceeded`));\n    }, timeout);\n    signal.addEventListener(\"abort\", () => {\n      clearTimeout(timeoutId);\n      reject(new Error(\"Promise aborted\"));\n    });\n    promise.then(result => {\n      if (!signal.aborted) {\n        clearTimeout(timeoutId);\n        resolve(result);\n      }\n    }).catch(error => {\n      if (!signal.aborted) {\n        clearTimeout(timeoutId);\n        reject(error);\n      }\n    });\n  });\n  const abort = () => controller.abort();\n  return [wrappedPromise, abort];\n}\nfunction waitForElement(target, options) {\n  const {\n    timeout,\n    rootNode\n  } = options;\n  const win = getWindow(rootNode);\n  const doc = getDocument(rootNode);\n  const controller = new win.AbortController();\n  return waitForPromise(new Promise(resolve => {\n    const el = target();\n    if (el) {\n      resolve(el);\n      return;\n    }\n    const observer = new win.MutationObserver(() => {\n      const el2 = target();\n      if (el2) {\n        observer.disconnect();\n        resolve(el2);\n      }\n    });\n    observer.observe(doc.body, {\n      childList: true,\n      subtree: true\n    });\n  }), controller, timeout);\n}\nfunction waitForElementValue(target, value, options) {\n  const {\n    timeout,\n    rootNode\n  } = options;\n  const win = getWindow(rootNode);\n  const controller = new win.AbortController();\n  return waitForPromise(new Promise(resolve => {\n    const el = target();\n    if (!el) return;\n    const checkValue = () => {\n      if (el.value === value) {\n        resolve();\n        el.removeEventListener(\"input\", checkValue);\n      }\n    };\n    checkValue();\n    el.addEventListener(\"input\", checkValue, {\n      signal: controller.signal\n    });\n  }), controller, timeout);\n}\nexport { anatomy, connect, machine, props, splitProps, waitForElement, waitForElementValue };","map":null,"metadata":{},"sourceType":"module"}