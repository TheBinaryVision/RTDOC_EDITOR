{"ast":null,"code":"import { createAnatomy } from '@zag-js/anatomy';\nimport { isCaretAtStart, indexOfId, raf, setElementValue, queryAll, prevById, nextById, trackFormControl, contains, dispatchInputValueEvent, dataAttr, isComposingEvent, ariaAttr, getEventKey, getNativeEvent } from '@zag-js/dom-query';\nimport { autoResizeInput } from '@zag-js/auto-resize';\nimport { createGuards, createMachine } from '@zag-js/core';\nimport { trackInteractOutside } from '@zag-js/interact-outside';\nimport { createLiveRegion } from '@zag-js/live-region';\nimport { uniq, warn, removeAt, isEqual, createSplitProps } from '@zag-js/utils';\nimport { createProps } from '@zag-js/types';\n\n// src/tags-input.anatomy.ts\nvar anatomy = createAnatomy(\"tagsInput\").parts(\"root\", \"label\", \"control\", \"input\", \"clearTrigger\", \"item\", \"itemPreview\", \"itemInput\", \"itemText\", \"itemDeleteTrigger\");\nvar parts = anatomy.build();\nvar getRootId = ctx => ctx.ids?.root ?? `tags-input:${ctx.id}`;\nvar getInputId = ctx => ctx.ids?.input ?? `tags-input:${ctx.id}:input`;\nvar getClearTriggerId = ctx => ctx.ids?.clearBtn ?? `tags-input:${ctx.id}:clear-btn`;\nvar getHiddenInputId = ctx => ctx.ids?.hiddenInput ?? `tags-input:${ctx.id}:hidden-input`;\nvar getLabelId = ctx => ctx.ids?.label ?? `tags-input:${ctx.id}:label`;\nvar getControlId = ctx => ctx.ids?.control ?? `tags-input:${ctx.id}:control`;\nvar getItemId = (ctx, opt) => ctx.ids?.item?.(opt) ?? `tags-input:${ctx.id}:tag:${opt.value}:${opt.index}`;\nvar getItemDeleteTriggerId = (ctx, opt) => ctx.ids?.itemDeleteTrigger?.(opt) ?? `${getItemId(ctx, opt)}:delete-btn`;\nvar getItemInputId = (ctx, opt) => ctx.ids?.itemInput?.(opt) ?? `${getItemId(ctx, opt)}:input`;\nvar getEditInputId = id => `${id}:input`;\nvar getEditInputEl = (ctx, id) => ctx.getById(getEditInputId(id));\nvar getTagInputEl = (ctx, opt) => ctx.getById(getItemInputId(ctx, opt));\nvar getRootEl = ctx => ctx.getById(getRootId(ctx));\nvar getInputEl = ctx => ctx.getById(getInputId(ctx));\nvar getHiddenInputEl = ctx => ctx.getById(getHiddenInputId(ctx));\nvar getTagElements = ctx => queryAll(getRootEl(ctx), `[data-part=item-preview]:not([data-disabled])`);\nvar getFirstEl = ctx => getTagElements(ctx)[0];\nvar getLastEl = ctx => getTagElements(ctx)[getTagElements(ctx).length - 1];\nvar getPrevEl = (ctx, id) => prevById(getTagElements(ctx), id, false);\nvar getNextEl = (ctx, id) => nextById(getTagElements(ctx), id, false);\nvar getTagElAtIndex = (ctx, index) => getTagElements(ctx)[index];\nvar getIndexOfId = (ctx, id) => indexOfId(getTagElements(ctx), id);\nvar setHoverIntent = el => {\n  const tagEl = el.closest(\"[data-part=item-preview]\");\n  if (!tagEl) return;\n  tagEl.dataset.deleteIntent = \"\";\n};\nvar clearHoverIntent = el => {\n  const tagEl = el.closest(\"[data-part=item-preview]\");\n  if (!tagEl) return;\n  delete tagEl.dataset.deleteIntent;\n};\nvar dispatchInputEvent = (ctx, value) => {\n  const inputEl = getHiddenInputEl(ctx);\n  if (!inputEl) return;\n  dispatchInputValueEvent(inputEl, {\n    value\n  });\n};\n\n// src/tags-input.connect.ts\nfunction connect(service, normalize) {\n  const {\n    state,\n    send,\n    computed,\n    prop,\n    scope,\n    context\n  } = service;\n  const interactive = computed(\"isInteractive\");\n  const disabled = prop(\"disabled\");\n  const readOnly = prop(\"readOnly\");\n  const invalid = prop(\"invalid\") || computed(\"isOverflowing\");\n  const translations = prop(\"translations\");\n  const focused = state.hasTag(\"focused\");\n  const editingTag = state.matches(\"editing:tag\");\n  const empty = computed(\"count\") === 0;\n  function getItemState(options) {\n    const id = getItemId(scope, options);\n    const editedTagId = context.get(\"editedTagId\");\n    const highlightedTagId = context.get(\"highlightedTagId\");\n    return {\n      id,\n      editing: editingTag && editedTagId === id,\n      highlighted: id === highlightedTagId,\n      disabled: Boolean(options.disabled || disabled)\n    };\n  }\n  return {\n    empty,\n    inputValue: computed(\"trimmedInputValue\"),\n    value: context.get(\"value\"),\n    valueAsString: computed(\"valueAsString\"),\n    count: computed(\"count\"),\n    atMax: computed(\"isAtMax\"),\n    setValue(value) {\n      send({\n        type: \"SET_VALUE\",\n        value\n      });\n    },\n    clearValue(id) {\n      if (id) {\n        send({\n          type: \"CLEAR_TAG\",\n          id\n        });\n      } else {\n        send({\n          type: \"CLEAR_VALUE\"\n        });\n      }\n    },\n    addValue(value) {\n      send({\n        type: \"ADD_TAG\",\n        value\n      });\n    },\n    setValueAtIndex(index, value) {\n      send({\n        type: \"SET_VALUE_AT_INDEX\",\n        index,\n        value\n      });\n    },\n    setInputValue(value) {\n      send({\n        type: \"SET_INPUT_VALUE\",\n        value\n      });\n    },\n    clearInputValue() {\n      send({\n        type: \"SET_INPUT_VALUE\",\n        value: \"\"\n      });\n    },\n    focus() {\n      getInputEl(scope)?.focus();\n    },\n    getItemState,\n    getRootProps() {\n      return normalize.element({\n        dir: prop(\"dir\"),\n        ...parts.root.attrs,\n        \"data-invalid\": dataAttr(invalid),\n        \"data-readonly\": dataAttr(readOnly),\n        \"data-disabled\": dataAttr(disabled),\n        \"data-focus\": dataAttr(focused),\n        \"data-empty\": dataAttr(empty),\n        id: getRootId(scope),\n        onPointerDown() {\n          if (!interactive) return;\n          send({\n            type: \"POINTER_DOWN\"\n          });\n        }\n      });\n    },\n    getLabelProps() {\n      return normalize.label({\n        ...parts.label.attrs,\n        \"data-disabled\": dataAttr(disabled),\n        \"data-invalid\": dataAttr(invalid),\n        \"data-readonly\": dataAttr(readOnly),\n        id: getLabelId(scope),\n        dir: prop(\"dir\"),\n        htmlFor: getInputId(scope)\n      });\n    },\n    getControlProps() {\n      return normalize.element({\n        id: getControlId(scope),\n        ...parts.control.attrs,\n        dir: prop(\"dir\"),\n        tabIndex: readOnly ? 0 : void 0,\n        \"data-disabled\": dataAttr(disabled),\n        \"data-readonly\": dataAttr(readOnly),\n        \"data-invalid\": dataAttr(invalid),\n        \"data-focus\": dataAttr(focused)\n      });\n    },\n    getInputProps() {\n      return normalize.input({\n        ...parts.input.attrs,\n        dir: prop(\"dir\"),\n        \"data-invalid\": dataAttr(invalid),\n        \"aria-invalid\": ariaAttr(invalid),\n        \"data-readonly\": dataAttr(readOnly),\n        maxLength: prop(\"maxLength\"),\n        id: getInputId(scope),\n        defaultValue: context.get(\"inputValue\"),\n        autoComplete: \"off\",\n        autoCorrect: \"off\",\n        autoCapitalize: \"none\",\n        disabled: disabled || readOnly,\n        onInput(event) {\n          const evt = getNativeEvent(event);\n          const value = event.currentTarget.value;\n          if (evt.inputType === \"insertFromPaste\") {\n            send({\n              type: \"PASTE\",\n              value\n            });\n            return;\n          }\n          if (endsWith(value, prop(\"delimiter\"))) {\n            send({\n              type: \"DELIMITER_KEY\"\n            });\n            return;\n          }\n          send({\n            type: \"TYPE\",\n            value,\n            key: evt.inputType\n          });\n        },\n        onFocus() {\n          queueMicrotask(() => {\n            send({\n              type: \"FOCUS\"\n            });\n          });\n        },\n        onKeyDown(event) {\n          if (event.defaultPrevented) return;\n          if (isComposingEvent(event)) return;\n          const target = event.currentTarget;\n          const isCombobox = target.getAttribute(\"role\") === \"combobox\";\n          const isExpanded = target.ariaExpanded === \"true\";\n          const keyMap = {\n            ArrowDown() {\n              send({\n                type: \"ARROW_DOWN\"\n              });\n            },\n            ArrowLeft() {\n              if (isCombobox && isExpanded) return;\n              send({\n                type: \"ARROW_LEFT\"\n              });\n            },\n            ArrowRight(event2) {\n              if (context.get(\"highlightedTagId\")) {\n                event2.preventDefault();\n              }\n              if (isCombobox && isExpanded) return;\n              send({\n                type: \"ARROW_RIGHT\"\n              });\n            },\n            Escape(event2) {\n              event2.preventDefault();\n              send({\n                type: \"ESCAPE\"\n              });\n            },\n            Backspace() {\n              send({\n                type: \"BACKSPACE\"\n              });\n            },\n            Delete() {\n              send({\n                type: \"DELETE\"\n              });\n            },\n            Enter(event2) {\n              if (isCombobox && isExpanded) return;\n              send({\n                type: \"ENTER\"\n              });\n              event2.preventDefault();\n            }\n          };\n          const key = getEventKey(event, {\n            dir: prop(\"dir\")\n          });\n          const exec = keyMap[key];\n          if (exec) {\n            exec(event);\n            return;\n          }\n        }\n      });\n    },\n    getHiddenInputProps() {\n      return normalize.input({\n        type: \"text\",\n        hidden: true,\n        name: prop(\"name\"),\n        form: prop(\"form\"),\n        disabled,\n        readOnly,\n        required: prop(\"required\"),\n        id: getHiddenInputId(scope),\n        defaultValue: computed(\"valueAsString\")\n      });\n    },\n    getItemProps(props2) {\n      return normalize.element({\n        ...parts.item.attrs,\n        dir: prop(\"dir\"),\n        \"data-value\": props2.value,\n        \"data-disabled\": dataAttr(disabled)\n      });\n    },\n    getItemPreviewProps(props2) {\n      const itemState = getItemState(props2);\n      return normalize.element({\n        ...parts.itemPreview.attrs,\n        id: itemState.id,\n        dir: prop(\"dir\"),\n        hidden: itemState.editing,\n        \"data-value\": props2.value,\n        \"data-disabled\": dataAttr(disabled),\n        \"data-highlighted\": dataAttr(itemState.highlighted),\n        onPointerDown(event) {\n          if (!interactive || itemState.disabled) return;\n          event.preventDefault();\n          send({\n            type: \"POINTER_DOWN_TAG\",\n            id: itemState.id\n          });\n        },\n        onDoubleClick() {\n          if (!interactive || itemState.disabled) return;\n          send({\n            type: \"DOUBLE_CLICK_TAG\",\n            id: itemState.id\n          });\n        }\n      });\n    },\n    getItemTextProps(props2) {\n      const itemState = getItemState(props2);\n      return normalize.element({\n        ...parts.itemText.attrs,\n        dir: prop(\"dir\"),\n        \"data-disabled\": dataAttr(disabled),\n        \"data-highlighted\": dataAttr(itemState.highlighted)\n      });\n    },\n    getItemInputProps(props2) {\n      const itemState = getItemState(props2);\n      return normalize.input({\n        ...parts.itemInput.attrs,\n        dir: prop(\"dir\"),\n        \"aria-label\": translations?.tagEdited?.(props2.value),\n        disabled,\n        id: getItemInputId(scope, props2),\n        tabIndex: -1,\n        hidden: !itemState.editing,\n        defaultValue: itemState.editing ? context.get(\"editedTagValue\") : \"\",\n        onInput(event) {\n          send({\n            type: \"TAG_INPUT_TYPE\",\n            value: event.currentTarget.value\n          });\n        },\n        onBlur(event) {\n          queueMicrotask(() => {\n            send({\n              type: \"TAG_INPUT_BLUR\",\n              target: event.relatedTarget,\n              id: itemState.id\n            });\n          });\n        },\n        onKeyDown(event) {\n          if (event.defaultPrevented) return;\n          if (isComposingEvent(event)) return;\n          const keyMap = {\n            Enter() {\n              send({\n                type: \"TAG_INPUT_ENTER\"\n              });\n            },\n            Escape() {\n              send({\n                type: \"TAG_INPUT_ESCAPE\"\n              });\n            }\n          };\n          const exec = keyMap[event.key];\n          if (exec) {\n            event.preventDefault();\n            exec(event);\n          }\n        }\n      });\n    },\n    getItemDeleteTriggerProps(props2) {\n      const id = getItemId(scope, props2);\n      return normalize.button({\n        ...parts.itemDeleteTrigger.attrs,\n        dir: prop(\"dir\"),\n        id: getItemDeleteTriggerId(scope, props2),\n        type: \"button\",\n        disabled,\n        \"aria-label\": translations?.deleteTagTriggerLabel?.(props2.value),\n        tabIndex: -1,\n        onPointerDown(event) {\n          if (!interactive) {\n            event.preventDefault();\n          }\n        },\n        onPointerMove(event) {\n          if (!interactive) return;\n          setHoverIntent(event.currentTarget);\n        },\n        onPointerLeave(event) {\n          if (!interactive) return;\n          clearHoverIntent(event.currentTarget);\n        },\n        onClick() {\n          if (!interactive) return;\n          send({\n            type: \"CLICK_DELETE_TAG\",\n            id\n          });\n        }\n      });\n    },\n    getClearTriggerProps() {\n      return normalize.button({\n        ...parts.clearTrigger.attrs,\n        dir: prop(\"dir\"),\n        id: getClearTriggerId(scope),\n        type: \"button\",\n        \"data-readonly\": dataAttr(readOnly),\n        disabled,\n        \"aria-label\": translations?.clearTriggerLabel,\n        hidden: empty,\n        onClick() {\n          if (!interactive) return;\n          send({\n            type: \"CLEAR_VALUE\"\n          });\n        }\n      });\n    }\n  };\n}\nfunction endsWith(str, del) {\n  if (!del) return false;\n  if (typeof del === \"string\") return str.endsWith(del);\n  return new RegExp(`${del.source}$`).test(str);\n}\nvar {\n  and,\n  not,\n  or\n} = createGuards();\nvar machine = createMachine({\n  props({\n    props: props2\n  }) {\n    return {\n      dir: \"ltr\",\n      addOnPaste: false,\n      editable: true,\n      validate: () => true,\n      delimiter: \",\",\n      defaultValue: [],\n      defaultInputValue: \"\",\n      max: Infinity,\n      ...props2,\n      translations: {\n        clearTriggerLabel: \"Clear all tags\",\n        deleteTagTriggerLabel: value => `Delete tag ${value}`,\n        tagAdded: value => `Added tag ${value}`,\n        tagsPasted: values => `Pasted ${values.length} tags`,\n        tagEdited: value => `Editing tag ${value}. Press enter to save or escape to cancel.`,\n        tagUpdated: value => `Tag update to ${value}`,\n        tagDeleted: value => `Tag ${value} deleted`,\n        tagSelected: value => `Tag ${value} selected. Press enter to edit, delete or backspace to remove.`,\n        ...props2.translations\n      }\n    };\n  },\n  initialState({\n    prop\n  }) {\n    return prop(\"autoFocus\") ? \"focused:input\" : \"idle\";\n  },\n  refs() {\n    return {\n      liveRegion: null,\n      log: {\n        current: null,\n        prev: null\n      }\n    };\n  },\n  context({\n    bindable,\n    prop\n  }) {\n    return {\n      value: bindable(() => ({\n        defaultValue: prop(\"defaultValue\"),\n        value: prop(\"value\"),\n        isEqual,\n        hash(value) {\n          return value.join(\", \");\n        },\n        onChange(value) {\n          prop(\"onValueChange\")?.({\n            value\n          });\n        }\n      })),\n      inputValue: bindable(() => ({\n        sync: true,\n        defaultValue: prop(\"defaultInputValue\"),\n        value: prop(\"inputValue\"),\n        onChange(value) {\n          prop(\"onInputValueChange\")?.({\n            inputValue: value\n          });\n        }\n      })),\n      fieldsetDisabled: bindable(() => ({\n        defaultValue: false\n      })),\n      editedTagValue: bindable(() => ({\n        defaultValue: \"\"\n      })),\n      editedTagId: bindable(() => ({\n        defaultValue: null\n      })),\n      editedTagIndex: bindable(() => ({\n        defaultValue: null,\n        sync: true\n      })),\n      highlightedTagId: bindable(() => ({\n        defaultValue: null,\n        sync: true,\n        onChange(value) {\n          prop(\"onHighlightChange\")?.({\n            highlightedValue: value\n          });\n        }\n      }))\n    };\n  },\n  computed: {\n    count: ({\n      context\n    }) => context.get(\"value\").length,\n    valueAsString: ({\n      context\n    }) => context.hash(\"value\"),\n    trimmedInputValue: ({\n      context\n    }) => context.get(\"inputValue\").trim(),\n    isDisabled: ({\n      prop\n    }) => !!prop(\"disabled\"),\n    isInteractive: ({\n      prop\n    }) => !(prop(\"readOnly\") || !!prop(\"disabled\")),\n    isAtMax: ({\n      context,\n      prop\n    }) => context.get(\"value\").length === prop(\"max\"),\n    isOverflowing: ({\n      context,\n      prop\n    }) => context.get(\"value\").length > prop(\"max\")\n  },\n  watch({\n    track,\n    context,\n    action,\n    computed,\n    refs\n  }) {\n    track([() => context.get(\"editedTagValue\")], () => {\n      action([\"syncEditedTagInputValue\"]);\n    });\n    track([() => context.get(\"inputValue\")], () => {\n      action([\"syncInputValue\"]);\n    });\n    track([() => context.get(\"highlightedTagId\")], () => {\n      action([\"logHighlightedTag\"]);\n    });\n    track([() => computed(\"isOverflowing\")], () => {\n      action([\"invokeOnInvalid\"]);\n    });\n    track([() => JSON.stringify(refs.get(\"log\"))], () => {\n      action([\"announceLog\"]);\n    });\n  },\n  effects: [\"trackLiveRegion\", \"trackFormControlState\"],\n  exit: [\"clearLog\"],\n  on: {\n    DOUBLE_CLICK_TAG: {\n      // internal: true,\n      guard: \"isTagEditable\",\n      target: \"editing:tag\",\n      actions: [\"setEditedId\"]\n    },\n    POINTER_DOWN_TAG: {\n      // internal: true,\n      target: \"navigating:tag\",\n      actions: [\"highlightTag\", \"focusInput\"]\n    },\n    CLICK_DELETE_TAG: {\n      target: \"focused:input\",\n      actions: [\"deleteTag\"]\n    },\n    SET_INPUT_VALUE: {\n      actions: [\"setInputValue\"]\n    },\n    SET_VALUE: {\n      actions: [\"setValue\"]\n    },\n    CLEAR_TAG: {\n      actions: [\"deleteTag\"]\n    },\n    SET_VALUE_AT_INDEX: {\n      actions: [\"setValueAtIndex\"]\n    },\n    CLEAR_VALUE: {\n      actions: [\"clearTags\", \"clearInputValue\", \"focusInput\"]\n    },\n    ADD_TAG: {\n      actions: [\"addTag\"]\n    },\n    INSERT_TAG: {\n      // (!isAtMax || allowOverflow) && !inputValueIsEmpty\n      guard: and(or(not(\"isAtMax\"), \"allowOverflow\"), not(\"isInputValueEmpty\")),\n      actions: [\"addTag\", \"clearInputValue\"]\n    },\n    EXTERNAL_BLUR: [{\n      guard: \"addOnBlur\",\n      actions: [\"raiseInsertTagEvent\"]\n    }, {\n      guard: \"clearOnBlur\",\n      actions: [\"clearInputValue\"]\n    }]\n  },\n  states: {\n    idle: {\n      on: {\n        FOCUS: {\n          target: \"focused:input\"\n        },\n        POINTER_DOWN: {\n          guard: not(\"hasHighlightedTag\"),\n          target: \"focused:input\"\n        }\n      }\n    },\n    \"focused:input\": {\n      tags: [\"focused\"],\n      entry: [\"focusInput\", \"clearHighlightedId\"],\n      effects: [\"trackInteractOutside\"],\n      on: {\n        TYPE: {\n          actions: [\"setInputValue\"]\n        },\n        BLUR: [{\n          guard: \"addOnBlur\",\n          target: \"idle\",\n          actions: [\"raiseInsertTagEvent\"]\n        }, {\n          guard: \"clearOnBlur\",\n          target: \"idle\",\n          actions: [\"clearInputValue\"]\n        }, {\n          target: \"idle\"\n        }],\n        ENTER: {\n          actions: [\"raiseInsertTagEvent\"]\n        },\n        DELIMITER_KEY: {\n          actions: [\"raiseInsertTagEvent\"]\n        },\n        ARROW_LEFT: {\n          guard: and(\"hasTags\", \"isCaretAtStart\"),\n          target: \"navigating:tag\",\n          actions: [\"highlightLastTag\"]\n        },\n        BACKSPACE: {\n          target: \"navigating:tag\",\n          guard: and(\"hasTags\", \"isCaretAtStart\"),\n          actions: [\"highlightLastTag\"]\n        },\n        DELETE: {\n          guard: \"hasHighlightedTag\",\n          actions: [\"deleteHighlightedTag\", \"highlightTagAtIndex\"]\n        },\n        PASTE: [{\n          guard: \"addOnPaste\",\n          actions: [\"setInputValue\", \"addTagFromPaste\"]\n        }, {\n          actions: [\"setInputValue\"]\n        }]\n      }\n    },\n    \"navigating:tag\": {\n      tags: [\"focused\"],\n      effects: [\"trackInteractOutside\"],\n      on: {\n        ARROW_RIGHT: [{\n          guard: and(\"hasTags\", \"isCaretAtStart\", not(\"isLastTagHighlighted\")),\n          actions: [\"highlightNextTag\"]\n        }, {\n          target: \"focused:input\"\n        }],\n        ARROW_LEFT: [{\n          guard: not(\"isCaretAtStart\"),\n          target: \"focused:input\"\n        }, {\n          actions: [\"highlightPrevTag\"]\n        }],\n        BLUR: {\n          target: \"idle\",\n          actions: [\"clearHighlightedId\"]\n        },\n        ENTER: {\n          guard: and(\"isTagEditable\", \"hasHighlightedTag\"),\n          target: \"editing:tag\",\n          actions: [\"setEditedId\", \"focusEditedTagInput\"]\n        },\n        ARROW_DOWN: {\n          target: \"focused:input\"\n        },\n        ESCAPE: {\n          target: \"focused:input\"\n        },\n        TYPE: {\n          target: \"focused:input\",\n          actions: [\"setInputValue\"]\n        },\n        BACKSPACE: [{\n          guard: not(\"isCaretAtStart\"),\n          target: \"focused:input\"\n        }, {\n          guard: \"isFirstTagHighlighted\",\n          actions: [\"deleteHighlightedTag\", \"highlightFirstTag\"]\n        }, {\n          guard: \"hasHighlightedTag\",\n          actions: [\"deleteHighlightedTag\", \"highlightPrevTag\"]\n        }, {\n          actions: [\"highlightLastTag\"]\n        }],\n        DELETE: [{\n          guard: not(\"isCaretAtStart\"),\n          target: \"focused:input\"\n        }, {\n          target: \"focused:input\",\n          actions: [\"deleteHighlightedTag\", \"highlightTagAtIndex\"]\n        }],\n        PASTE: [{\n          guard: \"addOnPaste\",\n          target: \"focused:input\",\n          actions: [\"setInputValue\", \"addTagFromPaste\"]\n        }, {\n          target: \"focused:input\",\n          actions: [\"setInputValue\"]\n        }]\n      }\n    },\n    \"editing:tag\": {\n      tags: [\"editing\", \"focused\"],\n      entry: [\"focusEditedTagInput\"],\n      effects: [\"autoResize\"],\n      on: {\n        TAG_INPUT_TYPE: {\n          actions: [\"setEditedTagValue\"]\n        },\n        TAG_INPUT_ESCAPE: {\n          target: \"navigating:tag\",\n          actions: [\"clearEditedTagValue\", \"focusInput\", \"clearEditedId\", \"highlightTagAtIndex\"]\n        },\n        TAG_INPUT_BLUR: [{\n          guard: \"isInputRelatedTarget\",\n          target: \"navigating:tag\",\n          actions: [\"clearEditedTagValue\", \"clearHighlightedId\", \"clearEditedId\"]\n        }, {\n          target: \"idle\",\n          actions: [\"clearEditedTagValue\", \"clearHighlightedId\", \"clearEditedId\", \"raiseExternalBlurEvent\"]\n        }],\n        TAG_INPUT_ENTER: [{\n          guard: \"isEditedTagEmpty\",\n          target: \"navigating:tag\",\n          actions: [\"deleteHighlightedTag\", \"focusInput\", \"clearEditedId\", \"highlightTagAtIndex\"]\n        }, {\n          target: \"navigating:tag\",\n          actions: [\"submitEditedTagValue\", \"focusInput\", \"clearEditedId\", \"highlightTagAtIndex\"]\n        }]\n      }\n    }\n  },\n  implementations: {\n    guards: {\n      isInputRelatedTarget: ({\n        scope,\n        event\n      }) => event.relatedTarget === getInputEl(scope),\n      isAtMax: ({\n        computed\n      }) => computed(\"isAtMax\"),\n      hasHighlightedTag: ({\n        context\n      }) => context.get(\"highlightedTagId\") != null,\n      isFirstTagHighlighted: ({\n        context,\n        scope\n      }) => {\n        const value = context.get(\"value\");\n        const firstItemId = getItemId(scope, {\n          value: value[0],\n          index: 0\n        });\n        return firstItemId === context.get(\"highlightedTagId\");\n      },\n      isEditedTagEmpty: ({\n        context\n      }) => context.get(\"editedTagValue\").trim() === \"\",\n      isLastTagHighlighted: ({\n        context,\n        scope\n      }) => {\n        const value = context.get(\"value\");\n        const lastIndex = value.length - 1;\n        const lastItemId = getItemId(scope, {\n          value: value[lastIndex],\n          index: lastIndex\n        });\n        return lastItemId === context.get(\"highlightedTagId\");\n      },\n      isInputValueEmpty: ({\n        context\n      }) => context.get(\"inputValue\").trim().length === 0,\n      hasTags: ({\n        context\n      }) => context.get(\"value\").length > 0,\n      allowOverflow: ({\n        prop\n      }) => !!prop(\"allowOverflow\"),\n      autoFocus: ({\n        prop\n      }) => !!prop(\"autoFocus\"),\n      addOnBlur: ({\n        prop\n      }) => prop(\"blurBehavior\") === \"add\",\n      clearOnBlur: ({\n        prop\n      }) => prop(\"blurBehavior\") === \"clear\",\n      addOnPaste: ({\n        prop\n      }) => !!prop(\"addOnPaste\"),\n      isTagEditable: ({\n        prop\n      }) => !!prop(\"editable\"),\n      isCaretAtStart: ({\n        scope\n      }) => isCaretAtStart(getInputEl(scope))\n    },\n    effects: {\n      trackInteractOutside({\n        scope,\n        prop,\n        send\n      }) {\n        return trackInteractOutside(getInputEl(scope), {\n          exclude(target) {\n            return contains(getRootEl(scope), target);\n          },\n          onFocusOutside: prop(\"onFocusOutside\"),\n          onPointerDownOutside: prop(\"onPointerDownOutside\"),\n          onInteractOutside(event) {\n            prop(\"onInteractOutside\")?.(event);\n            if (event.defaultPrevented) return;\n            send({\n              type: \"BLUR\",\n              src: \"interact-outside\"\n            });\n          }\n        });\n      },\n      trackFormControlState({\n        context,\n        send,\n        scope\n      }) {\n        return trackFormControl(getHiddenInputEl(scope), {\n          onFieldsetDisabledChange(disabled) {\n            context.set(\"fieldsetDisabled\", disabled);\n          },\n          onFormReset() {\n            const value = context.initial(\"value\");\n            send({\n              type: \"SET_VALUE\",\n              value,\n              src: \"form-reset\"\n            });\n          }\n        });\n      },\n      autoResize({\n        context,\n        prop,\n        scope\n      }) {\n        let fn_cleanup;\n        const raf_cleanup = raf(() => {\n          const editedTagValue = context.get(\"editedTagValue\");\n          const editedTagIndex = context.get(\"editedTagIndex\");\n          if (!editedTagValue || editedTagIndex == null || !prop(\"editable\")) return;\n          const inputEl = getTagInputEl(scope, {\n            value: editedTagValue,\n            index: editedTagIndex\n          });\n          fn_cleanup = autoResizeInput(inputEl);\n        });\n        return () => {\n          raf_cleanup();\n          fn_cleanup?.();\n        };\n      },\n      trackLiveRegion({\n        scope,\n        refs\n      }) {\n        const liveRegion = createLiveRegion({\n          level: \"assertive\",\n          document: scope.getDoc()\n        });\n        refs.set(\"liveRegion\", liveRegion);\n        return () => liveRegion.destroy();\n      }\n    },\n    actions: {\n      raiseInsertTagEvent({\n        send\n      }) {\n        send({\n          type: \"INSERT_TAG\"\n        });\n      },\n      raiseExternalBlurEvent({\n        send,\n        event\n      }) {\n        send({\n          type: \"EXTERNAL_BLUR\",\n          id: event.id\n        });\n      },\n      dispatchChangeEvent({\n        scope,\n        computed\n      }) {\n        dispatchInputEvent(scope, computed(\"valueAsString\"));\n      },\n      highlightNextTag({\n        context,\n        scope\n      }) {\n        const highlightedTagId = context.get(\"highlightedTagId\");\n        if (highlightedTagId == null) return;\n        const next = getNextEl(scope, highlightedTagId);\n        context.set(\"highlightedTagId\", next?.id ?? null);\n      },\n      highlightFirstTag({\n        context,\n        scope\n      }) {\n        raf(() => {\n          const first = getFirstEl(scope);\n          context.set(\"highlightedTagId\", first?.id ?? null);\n        });\n      },\n      highlightLastTag({\n        context,\n        scope\n      }) {\n        const last = getLastEl(scope);\n        context.set(\"highlightedTagId\", last?.id ?? null);\n      },\n      highlightPrevTag({\n        context,\n        scope\n      }) {\n        const highlightedTagId = context.get(\"highlightedTagId\");\n        if (highlightedTagId == null) return;\n        const prev = getPrevEl(scope, highlightedTagId);\n        context.set(\"highlightedTagId\", prev?.id ?? null);\n      },\n      highlightTag({\n        context,\n        event\n      }) {\n        context.set(\"highlightedTagId\", event.id);\n      },\n      highlightTagAtIndex({\n        context,\n        scope\n      }) {\n        raf(() => {\n          const idx = context.get(\"editedTagIndex\");\n          if (idx == null) return;\n          const tagEl = getTagElAtIndex(scope, idx);\n          if (tagEl == null) return;\n          context.set(\"highlightedTagId\", tagEl.id);\n          context.set(\"editedTagIndex\", null);\n        });\n      },\n      deleteTag({\n        context,\n        scope,\n        event,\n        refs\n      }) {\n        const index = getIndexOfId(scope, event.id);\n        const value = context.get(\"value\")[index];\n        const prevLog = refs.get(\"log\");\n        refs.set(\"log\", {\n          prev: prevLog.current,\n          current: {\n            type: \"delete\",\n            value\n          }\n        });\n        context.set(\"value\", prev => removeAt(prev, index));\n      },\n      deleteHighlightedTag({\n        context,\n        scope,\n        refs\n      }) {\n        const highlightedTagId = context.get(\"highlightedTagId\");\n        if (highlightedTagId == null) return;\n        const index = getIndexOfId(scope, highlightedTagId);\n        context.set(\"editedTagIndex\", index);\n        const value = context.get(\"value\");\n        const prevLog = refs.get(\"log\");\n        refs.set(\"log\", {\n          prev: prevLog.current,\n          current: {\n            type: \"delete\",\n            value: value[index]\n          }\n        });\n        context.set(\"value\", prev => removeAt(prev, index));\n      },\n      setEditedId({\n        context,\n        event,\n        scope\n      }) {\n        const highlightedTagId = context.get(\"highlightedTagId\");\n        const editedTagId = event.id ?? highlightedTagId;\n        context.set(\"editedTagId\", editedTagId);\n        const index = getIndexOfId(scope, editedTagId);\n        const valueAtIndex = context.get(\"value\")[index];\n        context.set(\"editedTagIndex\", index);\n        context.set(\"editedTagValue\", valueAtIndex);\n      },\n      clearEditedId({\n        context\n      }) {\n        context.set(\"editedTagId\", null);\n      },\n      clearEditedTagValue({\n        context\n      }) {\n        context.set(\"editedTagValue\", \"\");\n      },\n      setEditedTagValue({\n        context,\n        event\n      }) {\n        context.set(\"editedTagValue\", event.value);\n      },\n      submitEditedTagValue({\n        context,\n        scope,\n        refs\n      }) {\n        const editedTagId = context.get(\"editedTagId\");\n        if (!editedTagId) return;\n        const index = getIndexOfId(scope, editedTagId);\n        context.set(\"value\", prev => {\n          const value = prev.slice();\n          value[index] = context.get(\"editedTagValue\");\n          return value;\n        });\n        const prevLog = refs.get(\"log\");\n        refs.set(\"log\", {\n          prev: prevLog.current,\n          current: {\n            type: \"update\",\n            value: context.get(\"editedTagValue\")\n          }\n        });\n      },\n      setValueAtIndex({\n        context,\n        event,\n        refs\n      }) {\n        if (event.value) {\n          context.set(\"value\", prev => {\n            const value = prev.slice();\n            value[event.index] = event.value;\n            return value;\n          });\n          const prevLog = refs.get(\"log\");\n          refs.set(\"log\", {\n            prev: prevLog.current,\n            current: {\n              type: \"update\",\n              value: event.value\n            }\n          });\n        } else {\n          warn(\"You need to provide a value for the tag\");\n        }\n      },\n      focusEditedTagInput({\n        context,\n        scope\n      }) {\n        raf(() => {\n          const editedTagId = context.get(\"editedTagId\");\n          if (!editedTagId) return;\n          const editTagInputEl = getEditInputEl(scope, editedTagId);\n          editTagInputEl?.select();\n        });\n      },\n      setInputValue({\n        context,\n        event\n      }) {\n        context.set(\"inputValue\", event.value);\n      },\n      clearHighlightedId({\n        context\n      }) {\n        context.set(\"highlightedTagId\", null);\n      },\n      focusInput({\n        scope\n      }) {\n        raf(() => {\n          getInputEl(scope)?.focus();\n        });\n      },\n      clearInputValue({\n        context\n      }) {\n        raf(() => {\n          context.set(\"inputValue\", \"\");\n        });\n      },\n      syncInputValue({\n        context,\n        scope\n      }) {\n        const inputEl = getInputEl(scope);\n        if (!inputEl) return;\n        setElementValue(inputEl, context.get(\"inputValue\"));\n      },\n      syncEditedTagInputValue({\n        context,\n        event,\n        scope\n      }) {\n        const id = context.get(\"editedTagId\") || context.get(\"highlightedTagId\") || event.id;\n        if (id == null) return;\n        const editTagInputEl = getEditInputEl(scope, id);\n        if (!editTagInputEl) return;\n        setElementValue(editTagInputEl, context.get(\"editedTagValue\"));\n      },\n      addTag({\n        context,\n        event,\n        computed,\n        prop,\n        refs\n      }) {\n        const inputValue = event.value ?? computed(\"trimmedInputValue\");\n        const value = context.get(\"value\");\n        const guard = prop(\"validate\")?.({\n          inputValue,\n          value: Array.from(value)\n        });\n        if (guard) {\n          const nextValue = uniq(value.concat(inputValue));\n          context.set(\"value\", nextValue);\n          const prevLog = refs.get(\"log\");\n          refs.set(\"log\", {\n            prev: prevLog.current,\n            current: {\n              type: \"add\",\n              value: inputValue\n            }\n          });\n        } else {\n          prop(\"onValueInvalid\")?.({\n            reason: \"invalidTag\"\n          });\n        }\n      },\n      addTagFromPaste({\n        context,\n        computed,\n        prop,\n        refs\n      }) {\n        raf(() => {\n          const inputValue = computed(\"trimmedInputValue\");\n          const value = context.get(\"value\");\n          const guard = prop(\"validate\")?.({\n            inputValue,\n            value: Array.from(value)\n          });\n          if (guard) {\n            const delimiter = prop(\"delimiter\");\n            const trimmedValue = delimiter ? inputValue.split(delimiter).map(v => v.trim()) : [inputValue];\n            const nextValue = uniq(value.concat(...trimmedValue));\n            context.set(\"value\", nextValue);\n            const prevLog = refs.get(\"log\");\n            refs.set(\"log\", {\n              prev: prevLog.current,\n              current: {\n                type: \"paste\",\n                values: trimmedValue\n              }\n            });\n          } else {\n            prop(\"onValueInvalid\")?.({\n              reason: \"invalidTag\"\n            });\n          }\n          context.set(\"inputValue\", \"\");\n        });\n      },\n      clearTags({\n        context,\n        refs\n      }) {\n        context.set(\"value\", []);\n        const prevLog = refs.get(\"log\");\n        refs.set(\"log\", {\n          prev: prevLog.current,\n          current: {\n            type: \"clear\"\n          }\n        });\n      },\n      setValue({\n        context,\n        event\n      }) {\n        context.set(\"value\", event.value);\n      },\n      invokeOnInvalid({\n        prop,\n        computed\n      }) {\n        if (computed(\"isOverflowing\")) {\n          prop(\"onValueInvalid\")?.({\n            reason: \"rangeOverflow\"\n          });\n        }\n      },\n      clearLog({\n        refs\n      }) {\n        const log = refs.get(\"log\");\n        log.prev = log.current = null;\n      },\n      logHighlightedTag({\n        refs,\n        context,\n        scope\n      }) {\n        const highlightedTagId = context.get(\"highlightedTagId\");\n        const log = refs.get(\"log\");\n        if (highlightedTagId == null || !log.current) return;\n        const index = getIndexOfId(scope, highlightedTagId);\n        const value = context.get(\"value\")[index];\n        const prevLog = refs.get(\"log\");\n        refs.set(\"log\", {\n          prev: prevLog.current,\n          current: {\n            type: \"select\",\n            value\n          }\n        });\n      },\n      // queue logs with screen reader and get it announced\n      announceLog({\n        refs,\n        prop\n      }) {\n        const liveRegion = refs.get(\"liveRegion\");\n        const translations = prop(\"translations\");\n        const log = refs.get(\"log\");\n        if (!log.current || liveRegion == null) return;\n        const region = liveRegion;\n        const {\n          current,\n          prev\n        } = log;\n        let msg;\n        switch (current.type) {\n          case \"add\":\n            msg = translations.tagAdded(current.value);\n            break;\n          case \"delete\":\n            msg = translations.tagDeleted(current.value);\n            break;\n          case \"update\":\n            msg = translations.tagUpdated(current.value);\n            break;\n          case \"paste\":\n            msg = translations.tagsPasted(current.values);\n            break;\n          case \"select\":\n            msg = translations.tagSelected(current.value);\n            if (prev?.type === \"delete\") {\n              msg = `${translations.tagDeleted(prev.value)}. ${msg}`;\n            } else if (prev?.type === \"update\") {\n              msg = `${translations.tagUpdated(prev.value)}. ${msg}`;\n            }\n            break;\n        }\n        if (msg) region.announce(msg);\n      }\n    }\n  }\n});\nvar props = createProps()([\"addOnPaste\", \"allowOverflow\", \"autoFocus\", \"blurBehavior\", \"delimiter\", \"dir\", \"disabled\", \"editable\", \"form\", \"getRootNode\", \"id\", \"ids\", \"inputValue\", \"invalid\", \"max\", \"maxLength\", \"name\", \"onFocusOutside\", \"onHighlightChange\", \"onInputValueChange\", \"onInteractOutside\", \"onPointerDownOutside\", \"onValueChange\", \"onValueInvalid\", \"required\", \"readOnly\", \"translations\", \"validate\", \"value\", \"defaultValue\", \"defaultInputValue\"]);\nvar splitProps = createSplitProps(props);\nvar itemProps = createProps()([\"index\", \"disabled\", \"value\"]);\nvar splitItemProps = createSplitProps(itemProps);\nexport { anatomy, connect, itemProps, machine, props, splitItemProps, splitProps };","map":null,"metadata":{},"sourceType":"module"}