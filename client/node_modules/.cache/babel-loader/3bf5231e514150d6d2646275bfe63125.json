{"ast":null,"code":"import { createAnatomy } from '@zag-js/anatomy';\nimport { trackPointerMove, queryAll, dataAttr, getEventKey, getEventPoint } from '@zag-js/dom-query';\nimport { prev, next, ensure, isEqual, setRafTimeout, ensureProps, createSplitProps } from '@zag-js/utils';\nimport { createMachine } from '@zag-js/core';\nimport { createProps } from '@zag-js/types';\n\n// src/splitter.anatomy.ts\nvar anatomy = createAnatomy(\"splitter\").parts(\"root\", \"panel\", \"resizeTrigger\");\nvar parts = anatomy.build();\nvar getRootId = ctx => ctx.ids?.root ?? `splitter:${ctx.id}`;\nvar getResizeTriggerId = (ctx, id) => ctx.ids?.resizeTrigger?.(id) ?? `splitter:${ctx.id}:splitter:${id}`;\nvar getPanelId = (ctx, id) => ctx.ids?.panel?.(id) ?? `splitter:${ctx.id}:panel:${id}`;\nvar getGlobalCursorId = ctx => `splitter:${ctx.id}:global-cursor`;\nvar getRootEl = ctx => ctx.getById(getRootId(ctx));\nvar getResizeTriggerEl = (ctx, id) => ctx.getById(getResizeTriggerId(ctx, id));\nvar getCursor = (state, x) => {\n  let cursor = x ? \"col-resize\" : \"row-resize\";\n  if (state.isAtMin) cursor = x ? \"e-resize\" : \"s-resize\";\n  if (state.isAtMax) cursor = x ? \"w-resize\" : \"n-resize\";\n  return cursor;\n};\nvar getResizeTriggerEls = ctx => {\n  return queryAll(getRootEl(ctx), `[role=separator][data-ownedby='${CSS.escape(getRootId(ctx))}']`);\n};\nvar setupGlobalCursor = (ctx, state, x, nonce) => {\n  const styleEl = ctx.getById(getGlobalCursorId(ctx));\n  const textContent = `* { cursor: ${getCursor(state, x)} !important; }`;\n  if (styleEl) {\n    styleEl.textContent = textContent;\n  } else {\n    const style = ctx.getDoc().createElement(\"style\");\n    if (nonce) style.nonce = nonce;\n    style.id = getGlobalCursorId(ctx);\n    style.textContent = textContent;\n    ctx.getDoc().head.appendChild(style);\n  }\n};\nvar removeGlobalCursor = ctx => {\n  const styleEl = ctx.getById(getGlobalCursorId(ctx));\n  styleEl?.remove();\n};\nfunction calculateAriaValues({\n  size,\n  panels,\n  pivotIndices\n}) {\n  let currentMinSize = 0;\n  let currentMaxSize = 100;\n  let totalMinSize = 0;\n  let totalMaxSize = 0;\n  const firstIndex = pivotIndices[0];\n  ensure(firstIndex, () => \"No pivot index found\");\n  panels.forEach((panel, index) => {\n    const {\n      maxSize = 100,\n      minSize = 0\n    } = panel;\n    if (index === firstIndex) {\n      currentMinSize = minSize;\n      currentMaxSize = maxSize;\n    } else {\n      totalMinSize += minSize;\n      totalMaxSize += maxSize;\n    }\n  });\n  const valueMax = Math.min(currentMaxSize, 100 - totalMinSize);\n  const valueMin = Math.max(currentMinSize, 100 - totalMaxSize);\n  const valueNow = size[firstIndex];\n  return {\n    valueMax,\n    valueMin,\n    valueNow\n  };\n}\nfunction getAriaValue(size, panels, handleId) {\n  const [beforeId, afterId] = handleId.split(\":\");\n  const beforeIndex = panels.findIndex(panel => panel.id === beforeId);\n  const afterIndex = panels.findIndex(panel => panel.id === afterId);\n  const {\n    valueMax,\n    valueMin,\n    valueNow\n  } = calculateAriaValues({\n    size,\n    panels,\n    pivotIndices: [beforeIndex, afterIndex]\n  });\n  return {\n    beforeId,\n    afterId,\n    valueMax: Math.round(valueMax),\n    valueMin: Math.round(valueMin),\n    valueNow: valueNow != null ? Math.round(valueNow) : void 0\n  };\n}\n\n// src/utils/fuzzy.ts\nvar PRECISION = 10;\nfunction fuzzyCompareNumbers(actual, expected, fractionDigits = PRECISION) {\n  if (actual.toFixed(fractionDigits) === expected.toFixed(fractionDigits)) {\n    return 0;\n  } else {\n    return actual > expected ? 1 : -1;\n  }\n}\nfunction fuzzyNumbersEqual(actual, expected, fractionDigits = PRECISION) {\n  if (actual == null || expected == null) return false;\n  return fuzzyCompareNumbers(actual, expected, fractionDigits) === 0;\n}\nfunction fuzzySizeEqual(actual, expected, fractionDigits) {\n  if (actual.length !== expected.length) {\n    return false;\n  }\n  for (let index = 0; index < actual.length; index++) {\n    const actualSize = actual[index];\n    const expectedSize = expected[index];\n    if (!fuzzyNumbersEqual(actualSize, expectedSize, fractionDigits)) {\n      return false;\n    }\n  }\n  return true;\n}\nfunction getPanelById(panels, id) {\n  const panel = panels.find(panel2 => panel2.id === id);\n  ensure(panel, () => `Panel data not found for id \"${id}\"`);\n  return panel;\n}\nfunction findPanelDataIndex(panels, panel) {\n  return panels.findIndex(prevPanel => prevPanel === panel || prevPanel.id === panel.id);\n}\nfunction findPanelIndex(panels, id) {\n  return panels.findIndex(panel => panel.id === id);\n}\nfunction panelDataHelper(panels, panel, sizes) {\n  const index = findPanelIndex(panels, panel.id);\n  const pivotIndices = index === panels.length - 1 ? [index - 1, index] : [index, index + 1];\n  const panelSize = sizes[index];\n  return {\n    ...panel,\n    panelSize,\n    pivotIndices\n  };\n}\nfunction sortPanels(panels) {\n  return panels.sort((panelA, panelB) => {\n    const orderA = panelA.order;\n    const orderB = panelB.order;\n    if (orderA == null && orderB == null) {\n      return 0;\n    } else if (orderA == null) {\n      return -1;\n    } else if (orderB == null) {\n      return 1;\n    } else {\n      return orderA - orderB;\n    }\n  });\n}\nfunction getPanelLayout(panels) {\n  return panels.map(panel => panel.id).sort().join(\":\");\n}\nfunction serializePanels(panels) {\n  const keys = panels.map(panel => panel.id);\n  const sortedKeys = keys.sort();\n  const serialized = sortedKeys.map(key => {\n    const panel = panels.find(panel2 => panel2.id === key);\n    return JSON.stringify(panel);\n  });\n  return serialized.join(\",\");\n}\nfunction getPanelFlexBoxStyle({\n  defaultSize,\n  dragState,\n  sizes,\n  panels,\n  panelIndex,\n  precision = 3\n}) {\n  const size = sizes[panelIndex];\n  let flexGrow;\n  if (size == null) {\n    flexGrow = defaultSize != void 0 ? defaultSize.toPrecision(precision) : \"1\";\n  } else if (panels.length === 1) {\n    flexGrow = \"1\";\n  } else {\n    flexGrow = size.toPrecision(precision);\n  }\n  return {\n    flexBasis: 0,\n    flexGrow,\n    flexShrink: 1,\n    // Without this, Panel sizes may be unintentionally overridden by their content\n    overflow: \"hidden\",\n    // Disable pointer events inside of a panel during resize\n    // This avoid edge cases like nested iframes\n    pointerEvents: dragState !== null ? \"none\" : void 0\n  };\n}\nfunction getUnsafeDefaultSize({\n  panels,\n  size: sizes\n}) {\n  const finalSizes = Array(panels.length);\n  let numPanelsWithSizes = 0;\n  let remainingSize = 100;\n  for (let index = 0; index < panels.length; index++) {\n    const panel = panels[index];\n    ensure(panel, () => `Panel data not found for index ${index}`);\n    const defaultSize = sizes[index];\n    if (defaultSize != null) {\n      numPanelsWithSizes++;\n      finalSizes[index] = defaultSize;\n      remainingSize -= defaultSize;\n    }\n  }\n  for (let index = 0; index < panels.length; index++) {\n    const panel = panels[index];\n    ensure(panel, () => `Panel data not found for index ${index}`);\n    const defaultSize = sizes[index];\n    if (defaultSize != null) {\n      continue;\n    }\n    const numRemainingPanels = panels.length - numPanelsWithSizes;\n    const size = remainingSize / numRemainingPanels;\n    numPanelsWithSizes++;\n    finalSizes[index] = size;\n    remainingSize -= size;\n  }\n  return finalSizes;\n}\n\n// src/splitter.connect.ts\nfunction connect(service, normalize) {\n  const {\n    state,\n    send,\n    prop,\n    computed,\n    context,\n    scope\n  } = service;\n  const horizontal = computed(\"horizontal\");\n  const dragging = state.matches(\"dragging\");\n  const getPanelStyle = id => {\n    const panels = prop(\"panels\");\n    const panelIndex = panels.findIndex(panel => panel.id === id);\n    const defaultSize = context.initial(\"size\")[panelIndex];\n    const dragState = context.get(\"dragState\");\n    return getPanelFlexBoxStyle({\n      defaultSize,\n      dragState,\n      sizes: context.get(\"size\"),\n      panels,\n      panelIndex\n    });\n  };\n  return {\n    dragging,\n    getItems() {\n      return prop(\"panels\").flatMap((panel, index, arr) => {\n        const nextPanel = arr[index + 1];\n        if (panel && nextPanel) {\n          return [{\n            type: \"panel\",\n            id: panel.id\n          }, {\n            type: \"handle\",\n            id: `${panel.id}:${nextPanel.id}`\n          }];\n        }\n        return [{\n          type: \"panel\",\n          id: panel.id\n        }];\n      });\n    },\n    getSizes() {\n      return context.get(\"size\");\n    },\n    setSizes(size) {\n      send({\n        type: \"SIZE.SET\",\n        size\n      });\n    },\n    collapsePanel(id) {\n      send({\n        type: \"PANEL.COLLAPSE\",\n        id\n      });\n    },\n    expandPanel(id, minSize) {\n      send({\n        type: \"PANEL.EXPAND\",\n        id,\n        minSize\n      });\n    },\n    resizePanel(id, unsafePanelSize) {\n      send({\n        type: \"PANEL.RESIZE\",\n        id,\n        size: unsafePanelSize\n      });\n    },\n    getPanelSize(id) {\n      const panels = prop(\"panels\");\n      const size = context.get(\"size\");\n      const panelData = getPanelById(panels, id);\n      const {\n        panelSize\n      } = panelDataHelper(panels, panelData, size);\n      ensure(panelSize, () => `Panel size not found for panel \"${panelData.id}\"`);\n      return panelSize;\n    },\n    isPanelCollapsed(id) {\n      const panels = prop(\"panels\");\n      const size = context.get(\"size\");\n      const panelData = getPanelById(panels, id);\n      const {\n        collapsedSize = 0,\n        collapsible,\n        panelSize\n      } = panelDataHelper(panels, panelData, size);\n      ensure(panelSize, () => `Panel size not found for panel \"${panelData.id}\"`);\n      return collapsible === true && fuzzyNumbersEqual(panelSize, collapsedSize);\n    },\n    isPanelExpanded(id) {\n      const panels = prop(\"panels\");\n      const size = context.get(\"size\");\n      const panelData = getPanelById(panels, id);\n      const {\n        collapsedSize = 0,\n        collapsible,\n        panelSize\n      } = panelDataHelper(panels, panelData, size);\n      ensure(panelSize, () => `Panel size not found for panel \"${panelData.id}\"`);\n      return !collapsible || fuzzyCompareNumbers(panelSize, collapsedSize) > 0;\n    },\n    getLayout() {\n      return getPanelLayout(prop(\"panels\"));\n    },\n    getRootProps() {\n      return normalize.element({\n        ...parts.root.attrs,\n        \"data-orientation\": prop(\"orientation\"),\n        id: getRootId(scope),\n        dir: prop(\"dir\"),\n        style: {\n          display: \"flex\",\n          flexDirection: horizontal ? \"row\" : \"column\",\n          height: \"100%\",\n          width: \"100%\",\n          overflow: \"hidden\"\n        }\n      });\n    },\n    getPanelProps(props2) {\n      const {\n        id\n      } = props2;\n      return normalize.element({\n        ...parts.panel.attrs,\n        \"data-orientation\": prop(\"orientation\"),\n        dir: prop(\"dir\"),\n        \"data-id\": id,\n        \"data-index\": findPanelIndex(prop(\"panels\"), id),\n        id: getPanelId(scope, id),\n        \"data-ownedby\": getRootId(scope),\n        style: getPanelStyle(id)\n      });\n    },\n    getResizeTriggerProps(props2) {\n      const {\n        id,\n        disabled\n      } = props2;\n      const aria = getAriaValue(context.get(\"size\"), prop(\"panels\"), id);\n      const dragging2 = context.get(\"dragState\")?.resizeTriggerId === id;\n      const focused = dragging2 || context.get(\"keyboardState\")?.resizeTriggerId === id;\n      return normalize.element({\n        ...parts.resizeTrigger.attrs,\n        dir: prop(\"dir\"),\n        id: getResizeTriggerId(scope, id),\n        role: \"separator\",\n        \"data-id\": id,\n        \"data-ownedby\": getRootId(scope),\n        tabIndex: disabled ? void 0 : 0,\n        \"aria-valuenow\": aria.valueNow,\n        \"aria-valuemin\": aria.valueMin,\n        \"aria-valuemax\": aria.valueMax,\n        \"data-orientation\": prop(\"orientation\"),\n        \"aria-orientation\": prop(\"orientation\"),\n        \"aria-controls\": `${getPanelId(scope, aria.beforeId)} ${getPanelId(scope, aria.afterId)}`,\n        \"data-focus\": dataAttr(focused),\n        \"data-disabled\": dataAttr(disabled),\n        style: {\n          touchAction: \"none\",\n          userSelect: \"none\",\n          WebkitUserSelect: \"none\",\n          flex: \"0 0 auto\",\n          pointerEvents: dragging2 && !focused ? \"none\" : void 0,\n          cursor: horizontal ? \"col-resize\" : \"row-resize\",\n          [horizontal ? \"minHeight\" : \"minWidth\"]: \"0\"\n        },\n        onPointerDown(event) {\n          if (event.button !== 0) return;\n          if (disabled) {\n            event.preventDefault();\n            return;\n          }\n          const point = getEventPoint(event);\n          send({\n            type: \"POINTER_DOWN\",\n            id,\n            point\n          });\n          event.currentTarget.setPointerCapture(event.pointerId);\n          event.preventDefault();\n          event.stopPropagation();\n        },\n        onPointerUp(event) {\n          if (disabled) return;\n          if (event.currentTarget.hasPointerCapture(event.pointerId)) {\n            event.currentTarget.releasePointerCapture(event.pointerId);\n          }\n        },\n        onPointerOver() {\n          if (disabled) return;\n          send({\n            type: \"POINTER_OVER\",\n            id\n          });\n        },\n        onPointerLeave() {\n          if (disabled) return;\n          send({\n            type: \"POINTER_LEAVE\",\n            id\n          });\n        },\n        onBlur() {\n          if (disabled) return;\n          send({\n            type: \"BLUR\"\n          });\n        },\n        onFocus() {\n          if (disabled) return;\n          send({\n            type: \"FOCUS\",\n            id\n          });\n        },\n        onKeyDown(event) {\n          if (event.defaultPrevented) return;\n          if (disabled) return;\n          const keyboardResizeBy = prop(\"keyboardResizeBy\");\n          let delta = 0;\n          if (event.shiftKey) {\n            delta = 10;\n          } else if (keyboardResizeBy != null) {\n            delta = keyboardResizeBy;\n          } else {\n            delta = 1;\n          }\n          const keyMap = {\n            Enter() {\n              send({\n                type: \"ENTER\",\n                id\n              });\n            },\n            ArrowUp() {\n              send({\n                type: \"KEYBOARD_MOVE\",\n                id,\n                delta: horizontal ? 0 : delta\n              });\n            },\n            ArrowDown() {\n              send({\n                type: \"KEYBOARD_MOVE\",\n                id,\n                delta: horizontal ? 0 : delta\n              });\n            },\n            ArrowLeft() {\n              send({\n                type: \"KEYBOARD_MOVE\",\n                id,\n                delta: horizontal ? -delta : 0\n              });\n            },\n            ArrowRight() {\n              send({\n                type: \"KEYBOARD_MOVE\",\n                id,\n                delta: horizontal ? delta : 0\n              });\n            },\n            Home() {\n              send({\n                type: \"KEYBOARD_MOVE\",\n                id,\n                delta: -100\n              });\n            },\n            End() {\n              send({\n                type: \"KEYBOARD_MOVE\",\n                id,\n                delta: 100\n              });\n            },\n            F6() {\n              send({\n                type: \"FOCUS.CYCLE\",\n                id,\n                shiftKey: event.shiftKey\n              });\n            }\n          };\n          const key = getEventKey(event, {\n            dir: prop(\"dir\"),\n            orientation: prop(\"orientation\")\n          });\n          const exec = keyMap[key];\n          if (exec) {\n            exec(event);\n            event.preventDefault();\n          }\n        }\n      });\n    }\n  };\n}\nfunction resizePanel({\n  panels,\n  index,\n  size\n}) {\n  const panel = panels[index];\n  ensure(panel, () => `Panel data not found for index ${index}`);\n  let {\n    collapsedSize = 0,\n    collapsible,\n    maxSize = 100,\n    minSize = 0\n  } = panel;\n  if (fuzzyCompareNumbers(size, minSize) < 0) {\n    if (collapsible) {\n      const halfwayPoint = (collapsedSize + minSize) / 2;\n      if (fuzzyCompareNumbers(size, halfwayPoint) < 0) {\n        size = collapsedSize;\n      } else {\n        size = minSize;\n      }\n    } else {\n      size = minSize;\n    }\n  }\n  size = Math.min(maxSize, size);\n  size = parseFloat(size.toFixed(PRECISION));\n  return size;\n}\n\n// src/utils/resize-by-delta.ts\nfunction resizeByDelta(props2) {\n  let {\n    delta,\n    initialSize,\n    panels,\n    pivotIndices,\n    prevSize,\n    trigger\n  } = props2;\n  if (fuzzyNumbersEqual(delta, 0)) {\n    return initialSize;\n  }\n  const nextSize = [...initialSize];\n  const [firstPivotIndex, secondPivotIndex] = pivotIndices;\n  ensure(firstPivotIndex, () => \"Invalid first pivot index\");\n  ensure(secondPivotIndex, () => \"Invalid second pivot index\");\n  let deltaApplied = 0;\n  {\n    if (trigger === \"keyboard\") {\n      {\n        const index = delta < 0 ? secondPivotIndex : firstPivotIndex;\n        const panel = panels[index];\n        ensure(panel, () => `Panel data not found for index ${index}`);\n        const {\n          collapsedSize = 0,\n          collapsible,\n          minSize = 0\n        } = panel;\n        if (collapsible) {\n          const prevSize2 = initialSize[index];\n          ensure(prevSize2, () => `Previous size not found for panel index ${index}`);\n          if (fuzzyNumbersEqual(prevSize2, collapsedSize)) {\n            const localDelta = minSize - prevSize2;\n            if (fuzzyCompareNumbers(localDelta, Math.abs(delta)) > 0) {\n              delta = delta < 0 ? 0 - localDelta : localDelta;\n            }\n          }\n        }\n      }\n      {\n        const index = delta < 0 ? firstPivotIndex : secondPivotIndex;\n        const panel = panels[index];\n        ensure(panel, () => `No panel data found for index ${index}`);\n        const {\n          collapsedSize = 0,\n          collapsible,\n          minSize = 0\n        } = panel;\n        if (collapsible) {\n          const prevSize2 = initialSize[index];\n          ensure(prevSize2, () => `Previous size not found for panel index ${index}`);\n          if (fuzzyNumbersEqual(prevSize2, minSize)) {\n            const localDelta = prevSize2 - collapsedSize;\n            if (fuzzyCompareNumbers(localDelta, Math.abs(delta)) > 0) {\n              delta = delta < 0 ? 0 - localDelta : localDelta;\n            }\n          }\n        }\n      }\n    }\n  }\n  {\n    const increment = delta < 0 ? 1 : -1;\n    let index = delta < 0 ? secondPivotIndex : firstPivotIndex;\n    let maxAvailableDelta = 0;\n    while (true) {\n      const prevSize2 = initialSize[index];\n      ensure(prevSize2, () => `Previous size not found for panel index ${index}`);\n      const maxSafeSize = resizePanel({\n        panels,\n        index,\n        size: 100\n      });\n      const delta2 = maxSafeSize - prevSize2;\n      maxAvailableDelta += delta2;\n      index += increment;\n      if (index < 0 || index >= panels.length) {\n        break;\n      }\n    }\n    const minAbsDelta = Math.min(Math.abs(delta), Math.abs(maxAvailableDelta));\n    delta = delta < 0 ? 0 - minAbsDelta : minAbsDelta;\n  }\n  {\n    const pivotIndex = delta < 0 ? firstPivotIndex : secondPivotIndex;\n    let index = pivotIndex;\n    while (index >= 0 && index < panels.length) {\n      const deltaRemaining = Math.abs(delta) - Math.abs(deltaApplied);\n      const prevSize2 = initialSize[index];\n      ensure(prevSize2, () => `Previous size not found for panel index ${index}`);\n      const unsafeSize = prevSize2 - deltaRemaining;\n      const safeSize = resizePanel({\n        panels,\n        index,\n        size: unsafeSize\n      });\n      if (!fuzzyNumbersEqual(prevSize2, safeSize)) {\n        deltaApplied += prevSize2 - safeSize;\n        nextSize[index] = safeSize;\n        if (deltaApplied.toPrecision(3).localeCompare(Math.abs(delta).toPrecision(3), void 0, {\n          numeric: true\n        }) >= 0) {\n          break;\n        }\n      }\n      if (delta < 0) {\n        index--;\n      } else {\n        index++;\n      }\n    }\n  }\n  if (fuzzySizeEqual(prevSize, nextSize)) {\n    return prevSize;\n  }\n  {\n    const pivotIndex = delta < 0 ? secondPivotIndex : firstPivotIndex;\n    const prevSize2 = initialSize[pivotIndex];\n    ensure(prevSize2, () => `Previous size not found for panel index ${pivotIndex}`);\n    const unsafeSize = prevSize2 + deltaApplied;\n    const safeSize = resizePanel({\n      panels,\n      index: pivotIndex,\n      size: unsafeSize\n    });\n    nextSize[pivotIndex] = safeSize;\n    if (!fuzzyNumbersEqual(safeSize, unsafeSize)) {\n      let deltaRemaining = unsafeSize - safeSize;\n      const pivotIndex2 = delta < 0 ? secondPivotIndex : firstPivotIndex;\n      let index = pivotIndex2;\n      while (index >= 0 && index < panels.length) {\n        const prevSize3 = nextSize[index];\n        ensure(prevSize3, () => `Previous size not found for panel index ${index}`);\n        const unsafeSize2 = prevSize3 + deltaRemaining;\n        const safeSize2 = resizePanel({\n          panels,\n          index,\n          size: unsafeSize2\n        });\n        if (!fuzzyNumbersEqual(prevSize3, safeSize2)) {\n          deltaRemaining -= safeSize2 - prevSize3;\n          nextSize[index] = safeSize2;\n        }\n        if (fuzzyNumbersEqual(deltaRemaining, 0)) {\n          break;\n        }\n        if (delta > 0) {\n          index--;\n        } else {\n          index++;\n        }\n      }\n    }\n  }\n  const totalSize = nextSize.reduce((total, size) => size + total, 0);\n  if (!fuzzyNumbersEqual(totalSize, 100)) {\n    return prevSize;\n  }\n  return nextSize;\n}\nfunction validateSizes({\n  size: prevSize,\n  panels\n}) {\n  const nextSize = [...prevSize];\n  const nextSizeTotalSize = nextSize.reduce((accumulated, current) => accumulated + current, 0);\n  if (nextSize.length !== panels.length) {\n    throw Error(`Invalid ${panels.length} panel size: ${nextSize.map(size => `${size}%`).join(\", \")}`);\n  } else if (!fuzzyNumbersEqual(nextSizeTotalSize, 100) && nextSize.length > 0) {\n    for (let index = 0; index < panels.length; index++) {\n      const unsafeSize = nextSize[index];\n      ensure(unsafeSize, () => `No size data found for index ${index}`);\n      const safeSize = 100 / nextSizeTotalSize * unsafeSize;\n      nextSize[index] = safeSize;\n    }\n  }\n  let remainingSize = 0;\n  for (let index = 0; index < panels.length; index++) {\n    const unsafeSize = nextSize[index];\n    ensure(unsafeSize, () => `No size data found for index ${index}`);\n    const safeSize = resizePanel({\n      panels,\n      index,\n      size: unsafeSize\n    });\n    if (unsafeSize != safeSize) {\n      remainingSize += unsafeSize - safeSize;\n      nextSize[index] = safeSize;\n    }\n  }\n  if (!fuzzyNumbersEqual(remainingSize, 0)) {\n    for (let index = 0; index < panels.length; index++) {\n      const prevSize2 = nextSize[index];\n      ensure(prevSize2, () => `No size data found for index ${index}`);\n      const unsafeSize = prevSize2 + remainingSize;\n      const safeSize = resizePanel({\n        panels,\n        index,\n        size: unsafeSize\n      });\n      if (prevSize2 !== safeSize) {\n        remainingSize -= safeSize - prevSize2;\n        nextSize[index] = safeSize;\n        if (fuzzyNumbersEqual(remainingSize, 0)) {\n          break;\n        }\n      }\n    }\n  }\n  return nextSize;\n}\n\n// src/splitter.machine.ts\nvar machine = createMachine({\n  props({\n    props: props2\n  }) {\n    ensureProps(props2, [\"panels\"]);\n    return {\n      orientation: \"horizontal\",\n      defaultSize: [],\n      dir: \"ltr\",\n      ...props2,\n      panels: sortPanels(props2.panels)\n    };\n  },\n  initialState() {\n    return \"idle\";\n  },\n  context({\n    prop,\n    bindable,\n    getContext,\n    getRefs\n  }) {\n    return {\n      size: bindable(() => ({\n        value: prop(\"size\"),\n        defaultValue: prop(\"defaultSize\"),\n        isEqual(a, b) {\n          return b != null && fuzzySizeEqual(a, b);\n        },\n        onChange(value) {\n          const ctx = getContext();\n          const refs = getRefs();\n          const sizesBeforeCollapse = refs.get(\"panelSizeBeforeCollapse\");\n          const expandToSizes = Object.fromEntries(sizesBeforeCollapse.entries());\n          const resizeTriggerId = ctx.get(\"dragState\")?.resizeTriggerId ?? null;\n          const layout = getPanelLayout(prop(\"panels\"));\n          prop(\"onResize\")?.({\n            size: value,\n            layout,\n            resizeTriggerId,\n            expandToSizes\n          });\n        }\n      })),\n      dragState: bindable(() => ({\n        defaultValue: null\n      })),\n      keyboardState: bindable(() => ({\n        defaultValue: null\n      }))\n    };\n  },\n  watch({\n    track,\n    action,\n    prop\n  }) {\n    track([() => serializePanels(prop(\"panels\"))], () => {\n      action([\"syncSize\"]);\n    });\n  },\n  refs() {\n    return {\n      panelSizeBeforeCollapse: /* @__PURE__ */new Map(),\n      prevDelta: 0,\n      panelIdToLastNotifiedSizeMap: /* @__PURE__ */new Map()\n    };\n  },\n  computed: {\n    horizontal({\n      prop\n    }) {\n      return prop(\"orientation\") === \"horizontal\";\n    }\n  },\n  on: {\n    \"SIZE.SET\": {\n      actions: [\"setSize\"]\n    },\n    \"PANEL.COLLAPSE\": {\n      actions: [\"collapsePanel\"]\n    },\n    \"PANEL.EXPAND\": {\n      actions: [\"expandPanel\"]\n    },\n    \"PANEL.RESIZE\": {\n      actions: [\"resizePanel\"]\n    }\n  },\n  entry: [\"syncSize\"],\n  states: {\n    idle: {\n      entry: [\"clearDraggingState\", \"clearKeyboardState\"],\n      on: {\n        POINTER_OVER: {\n          target: \"hover:temp\",\n          actions: [\"setKeyboardState\"]\n        },\n        FOCUS: {\n          target: \"focused\",\n          actions: [\"setKeyboardState\"]\n        },\n        POINTER_DOWN: {\n          target: \"dragging\",\n          actions: [\"setDraggingState\"]\n        }\n      }\n    },\n    \"hover:temp\": {\n      effects: [\"waitForHoverDelay\"],\n      on: {\n        HOVER_DELAY: {\n          target: \"hover\"\n        },\n        POINTER_DOWN: {\n          target: \"dragging\",\n          actions: [\"setDraggingState\"]\n        },\n        POINTER_LEAVE: {\n          target: \"idle\"\n        }\n      }\n    },\n    hover: {\n      tags: [\"focus\"],\n      on: {\n        POINTER_DOWN: {\n          target: \"dragging\",\n          actions: [\"setDraggingState\"]\n        },\n        POINTER_LEAVE: {\n          target: \"idle\"\n        }\n      }\n    },\n    focused: {\n      tags: [\"focus\"],\n      on: {\n        BLUR: {\n          target: \"idle\"\n        },\n        ENTER: {\n          actions: [\"collapseOrExpandPanel\"]\n        },\n        POINTER_DOWN: {\n          target: \"dragging\",\n          actions: [\"setDraggingState\"]\n        },\n        KEYBOARD_MOVE: {\n          actions: [\"invokeOnResizeStart\", \"setKeyboardValue\", \"invokeOnResizeEnd\"]\n        },\n        \"FOCUS.CYCLE\": {\n          actions: [\"focusNextResizeTrigger\"]\n        }\n      }\n    },\n    dragging: {\n      tags: [\"focus\"],\n      effects: [\"trackPointerMove\"],\n      entry: [\"invokeOnResizeStart\"],\n      on: {\n        POINTER_MOVE: {\n          actions: [\"setPointerValue\", \"setGlobalCursor\"]\n        },\n        POINTER_UP: {\n          target: \"idle\",\n          actions: [\"invokeOnResizeEnd\", \"clearGlobalCursor\"]\n        }\n      }\n    }\n  },\n  implementations: {\n    effects: {\n      waitForHoverDelay: ({\n        send\n      }) => {\n        return setRafTimeout(() => {\n          send({\n            type: \"HOVER_DELAY\"\n          });\n        }, 250);\n      },\n      trackPointerMove: ({\n        scope,\n        send\n      }) => {\n        const doc = scope.getDoc();\n        return trackPointerMove(doc, {\n          onPointerMove(info) {\n            send({\n              type: \"POINTER_MOVE\",\n              point: info.point\n            });\n          },\n          onPointerUp() {\n            send({\n              type: \"POINTER_UP\"\n            });\n          }\n        });\n      }\n    },\n    actions: {\n      setSize(params) {\n        const {\n          context,\n          event,\n          prop\n        } = params;\n        const unsafeSize = event.size;\n        const prevSize = context.get(\"size\");\n        const panels = prop(\"panels\");\n        const safeSize = validateSizes({\n          size: unsafeSize,\n          panels\n        });\n        if (!isEqual(prevSize, safeSize)) {\n          setSize(params, safeSize);\n        }\n      },\n      syncSize({\n        context,\n        prop\n      }) {\n        const panels = prop(\"panels\");\n        let prevSize = context.get(\"size\");\n        let unsafeSize = null;\n        if (prevSize.length === 0) {\n          unsafeSize = getUnsafeDefaultSize({\n            panels,\n            size: context.initial(\"size\")\n          });\n        }\n        const nextSize = validateSizes({\n          size: unsafeSize ?? prevSize,\n          panels\n        });\n        if (!isEqual(prevSize, nextSize)) {\n          context.set(\"size\", nextSize);\n        }\n      },\n      setDraggingState({\n        context,\n        event,\n        prop,\n        scope\n      }) {\n        const orientation = prop(\"orientation\");\n        const size = context.get(\"size\");\n        const resizeTriggerId = event.id;\n        const panelGroupEl = getRootEl(scope);\n        if (!panelGroupEl) return;\n        const handleElement = getResizeTriggerEl(scope, resizeTriggerId);\n        ensure(handleElement, () => `Drag handle element not found for id \"${resizeTriggerId}\"`);\n        const initialCursorPosition = orientation === \"horizontal\" ? event.point.x : event.point.y;\n        context.set(\"dragState\", {\n          resizeTriggerId: event.id,\n          resizeTriggerRect: handleElement.getBoundingClientRect(),\n          initialCursorPosition,\n          initialSize: size\n        });\n      },\n      clearDraggingState({\n        context\n      }) {\n        context.set(\"dragState\", null);\n      },\n      setKeyboardState({\n        context,\n        event\n      }) {\n        context.set(\"keyboardState\", {\n          resizeTriggerId: event.id\n        });\n      },\n      clearKeyboardState({\n        context\n      }) {\n        context.set(\"keyboardState\", null);\n      },\n      collapsePanel(params) {\n        const {\n          context,\n          prop,\n          event,\n          refs\n        } = params;\n        const prevSize = context.get(\"size\");\n        const panels = prop(\"panels\");\n        const panel = panels.find(panel2 => panel2.id === event.id);\n        ensure(panel, () => `Panel data not found for id \"${event.id}\"`);\n        if (panel.collapsible) {\n          const {\n            collapsedSize = 0,\n            panelSize,\n            pivotIndices\n          } = panelDataHelper(panels, panel, prevSize);\n          ensure(panelSize, () => `Panel size not found for panel \"${panel.id}\"`);\n          if (!fuzzyNumbersEqual(panelSize, collapsedSize)) {\n            refs.get(\"panelSizeBeforeCollapse\").set(panel.id, panelSize);\n            const isLastPanel = findPanelDataIndex(panels, panel) === panels.length - 1;\n            const delta = isLastPanel ? panelSize - collapsedSize : collapsedSize - panelSize;\n            const nextSize = resizeByDelta({\n              delta,\n              initialSize: prevSize,\n              panels,\n              pivotIndices,\n              prevSize,\n              trigger: \"imperative-api\"\n            });\n            if (!isEqual(prevSize, nextSize)) {\n              setSize(params, nextSize);\n            }\n          }\n        }\n      },\n      expandPanel(params) {\n        const {\n          context,\n          prop,\n          event,\n          refs\n        } = params;\n        const panels = prop(\"panels\");\n        const prevSize = context.get(\"size\");\n        const panel = panels.find(panel2 => panel2.id === event.id);\n        ensure(panel, () => `Panel data not found for id \"${event.id}\"`);\n        if (panel.collapsible) {\n          const {\n            collapsedSize = 0,\n            panelSize = 0,\n            minSize: minSizeFromProps = 0,\n            pivotIndices\n          } = panelDataHelper(panels, panel, prevSize);\n          const minSize = event.minSize ?? minSizeFromProps;\n          if (fuzzyNumbersEqual(panelSize, collapsedSize)) {\n            const prevPanelSize = refs.get(\"panelSizeBeforeCollapse\").get(panel.id);\n            const baseSize = prevPanelSize != null && prevPanelSize >= minSize ? prevPanelSize : minSize;\n            const isLastPanel = findPanelDataIndex(panels, panel) === panels.length - 1;\n            const delta = isLastPanel ? panelSize - baseSize : baseSize - panelSize;\n            const nextSize = resizeByDelta({\n              delta,\n              initialSize: prevSize,\n              panels,\n              pivotIndices,\n              prevSize,\n              trigger: \"imperative-api\"\n            });\n            if (!isEqual(prevSize, nextSize)) {\n              setSize(params, nextSize);\n            }\n          }\n        }\n      },\n      resizePanel(params) {\n        const {\n          context,\n          prop,\n          event\n        } = params;\n        const prevSize = context.get(\"size\");\n        const panels = prop(\"panels\");\n        const panel = getPanelById(panels, event.id);\n        const unsafePanelSize = event.size;\n        const {\n          panelSize,\n          pivotIndices\n        } = panelDataHelper(panels, panel, prevSize);\n        ensure(panelSize, () => `Panel size not found for panel \"${panel.id}\"`);\n        const isLastPanel = findPanelDataIndex(panels, panel) === panels.length - 1;\n        const delta = isLastPanel ? panelSize - unsafePanelSize : unsafePanelSize - panelSize;\n        const nextSize = resizeByDelta({\n          delta,\n          initialSize: prevSize,\n          panels,\n          pivotIndices,\n          prevSize,\n          trigger: \"imperative-api\"\n        });\n        if (!isEqual(prevSize, nextSize)) {\n          setSize(params, nextSize);\n        }\n      },\n      setPointerValue(params) {\n        const {\n          context,\n          event,\n          prop,\n          scope\n        } = params;\n        const dragState = context.get(\"dragState\");\n        if (!dragState) return;\n        const {\n          resizeTriggerId,\n          initialSize,\n          initialCursorPosition\n        } = dragState;\n        const panels = prop(\"panels\");\n        const panelGroupElement = getRootEl(scope);\n        ensure(panelGroupElement, () => `Panel group element not found`);\n        const pivotIndices = resizeTriggerId.split(\":\").map(id => panels.findIndex(panel => panel.id === id));\n        const horizontal = prop(\"orientation\") === \"horizontal\";\n        const cursorPosition = horizontal ? event.point.x : event.point.y;\n        const groupRect = panelGroupElement.getBoundingClientRect();\n        const groupSizeInPixels = horizontal ? groupRect.width : groupRect.height;\n        const offsetPixels = cursorPosition - initialCursorPosition;\n        const offsetPercentage = offsetPixels / groupSizeInPixels * 100;\n        const prevSize = context.get(\"size\");\n        const nextSize = resizeByDelta({\n          delta: offsetPercentage,\n          initialSize: initialSize ?? prevSize,\n          panels,\n          pivotIndices,\n          prevSize,\n          trigger: \"mouse-or-touch\"\n        });\n        if (!isEqual(prevSize, nextSize)) {\n          setSize(params, nextSize);\n        }\n      },\n      setKeyboardValue(params) {\n        const {\n          context,\n          event,\n          prop\n        } = params;\n        const panelDataArray = prop(\"panels\");\n        const resizeTriggerId = event.id;\n        const delta = event.delta;\n        const pivotIndices = resizeTriggerId.split(\":\").map(id => panelDataArray.findIndex(panelData => panelData.id === id));\n        const prevSize = context.get(\"size\");\n        const nextSize = resizeByDelta({\n          delta,\n          initialSize: prevSize,\n          panels: panelDataArray,\n          pivotIndices,\n          prevSize,\n          trigger: \"keyboard\"\n        });\n        if (!isEqual(prevSize, nextSize)) {\n          setSize(params, nextSize);\n        }\n      },\n      invokeOnResizeEnd({\n        context,\n        prop\n      }) {\n        queueMicrotask(() => {\n          const dragState = context.get(\"dragState\");\n          prop(\"onResizeEnd\")?.({\n            size: context.get(\"size\"),\n            resizeTriggerId: dragState?.resizeTriggerId ?? null\n          });\n        });\n      },\n      invokeOnResizeStart({\n        prop\n      }) {\n        queueMicrotask(() => {\n          prop(\"onResizeStart\")?.();\n        });\n      },\n      collapseOrExpandPanel(params) {\n        const {\n          context,\n          prop\n        } = params;\n        const panelDataArray = prop(\"panels\");\n        const sizes = context.get(\"size\");\n        const resizeTriggerId = context.get(\"keyboardState\")?.resizeTriggerId;\n        const [idBefore, idAfter] = resizeTriggerId?.split(\":\") ?? [];\n        const index = panelDataArray.findIndex(panelData2 => panelData2.id === idBefore);\n        if (index === -1) return;\n        const panelData = panelDataArray[index];\n        ensure(panelData, () => `No panel data found for index ${index}`);\n        const size = sizes[index];\n        const {\n          collapsedSize = 0,\n          collapsible,\n          minSize = 0\n        } = panelData;\n        if (size != null && collapsible) {\n          const pivotIndices = [idBefore, idAfter].map(id => panelDataArray.findIndex(panelData2 => panelData2.id === id));\n          const nextSize = resizeByDelta({\n            delta: fuzzyNumbersEqual(size, collapsedSize) ? minSize - collapsedSize : collapsedSize - size,\n            initialSize: context.initial(\"size\"),\n            panels: panelDataArray,\n            pivotIndices,\n            prevSize: sizes,\n            trigger: \"keyboard\"\n          });\n          if (!isEqual(sizes, nextSize)) {\n            setSize(params, nextSize);\n          }\n        }\n      },\n      setGlobalCursor({\n        context,\n        scope,\n        prop\n      }) {\n        const dragState = context.get(\"dragState\");\n        if (!dragState) return;\n        const panels = prop(\"panels\");\n        const horizontal = prop(\"orientation\") === \"horizontal\";\n        const [idBefore] = dragState.resizeTriggerId.split(\":\");\n        const indexBefore = panels.findIndex(panel2 => panel2.id === idBefore);\n        const panel = panels[indexBefore];\n        const size = context.get(\"size\");\n        const aria = getAriaValue(size, panels, dragState.resizeTriggerId);\n        const isAtMin = fuzzyNumbersEqual(aria.valueNow, aria.valueMin) || fuzzyNumbersEqual(aria.valueNow, panel.collapsedSize);\n        const isAtMax = fuzzyNumbersEqual(aria.valueNow, aria.valueMax);\n        const cursorState = {\n          isAtMin,\n          isAtMax\n        };\n        setupGlobalCursor(scope, cursorState, horizontal, prop(\"nonce\"));\n      },\n      clearGlobalCursor({\n        scope\n      }) {\n        removeGlobalCursor(scope);\n      },\n      focusNextResizeTrigger({\n        event,\n        scope\n      }) {\n        const resizeTriggers = getResizeTriggerEls(scope);\n        const index = resizeTriggers.findIndex(el => el.dataset.id === event.id);\n        const handleEl = event.shiftKey ? prev(resizeTriggers, index) : next(resizeTriggers, index);\n        handleEl?.focus();\n      }\n    }\n  }\n});\nfunction setSize(params, sizes) {\n  const {\n    refs,\n    prop,\n    context\n  } = params;\n  const panelsArray = prop(\"panels\");\n  const onCollapse = prop(\"onCollapse\");\n  const onExpand = prop(\"onExpand\");\n  const panelIdToLastNotifiedSizeMap = refs.get(\"panelIdToLastNotifiedSizeMap\");\n  context.set(\"size\", sizes);\n  sizes.forEach((size, index) => {\n    const panelData = panelsArray[index];\n    ensure(panelData, () => `Panel data not found for index ${index}`);\n    const {\n      collapsedSize = 0,\n      collapsible,\n      id: panelId\n    } = panelData;\n    const lastNotifiedSize = panelIdToLastNotifiedSizeMap.get(panelId);\n    if (lastNotifiedSize == null || size !== lastNotifiedSize) {\n      panelIdToLastNotifiedSizeMap.set(panelId, size);\n      if (collapsible && (onCollapse || onExpand)) {\n        if ((lastNotifiedSize == null || fuzzyNumbersEqual(lastNotifiedSize, collapsedSize)) && !fuzzyNumbersEqual(size, collapsedSize)) {\n          onExpand?.({\n            panelId,\n            size\n          });\n        }\n        if (onCollapse && (lastNotifiedSize == null || !fuzzyNumbersEqual(lastNotifiedSize, collapsedSize)) && fuzzyNumbersEqual(size, collapsedSize)) {\n          onCollapse?.({\n            panelId,\n            size\n          });\n        }\n      }\n    }\n  });\n}\nvar props = createProps()([\"dir\", \"getRootNode\", \"id\", \"ids\", \"onResize\", \"onResizeStart\", \"onResizeEnd\", \"onCollapse\", \"onExpand\", \"orientation\", \"size\", \"defaultSize\", \"panels\", \"keyboardResizeBy\", \"nonce\"]);\nvar splitProps = createSplitProps(props);\nvar panelProps = createProps()([\"id\"]);\nvar splitPanelProps = createSplitProps(panelProps);\nvar resizeTriggerProps = createProps()([\"disabled\", \"id\"]);\nvar splitResizeTriggerProps = createSplitProps(resizeTriggerProps);\nexport { anatomy, connect, getPanelLayout as layout, machine, panelProps, props, resizeTriggerProps, splitPanelProps, splitProps, splitResizeTriggerProps };","map":null,"metadata":{},"sourceType":"module"}