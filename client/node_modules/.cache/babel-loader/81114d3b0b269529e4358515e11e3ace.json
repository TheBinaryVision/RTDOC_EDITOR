{"ast":null,"code":"import { createAnatomy } from '@zag-js/anatomy';\nimport { query, raf, queryAll, dataAttr, ariaAttr, isComposingEvent, getEventKey } from '@zag-js/dom-query';\nimport { getPlacement, getPlacementStyles } from '@zag-js/popper';\nimport { Time } from '@internationalized/date';\nimport { createGuards, createMachine } from '@zag-js/core';\nimport { trackDismissableElement } from '@zag-js/dismissable';\nimport { next, prev, match, createSplitProps } from '@zag-js/utils';\nimport { createProps } from '@zag-js/types';\n\n// src/time-picker.anatomy.ts\nvar anatomy = createAnatomy(\"time-picker\").parts(\"cell\", \"clearTrigger\", \"column\", \"content\", \"control\", \"input\", \"label\", \"positioner\", \"root\", \"spacer\", \"trigger\");\nvar parts = anatomy.build();\nvar getContentId = ctx => ctx.ids?.content ?? `time-picker:${ctx.id}:content`;\nvar getColumnId = (ctx, unit) => ctx.ids?.column?.(unit) ?? `time-picker:${ctx.id}:column:${unit}`;\nvar getControlId = ctx => ctx.ids?.control ?? `time-picker:${ctx.id}:control`;\nvar getClearTriggerId = ctx => ctx.ids?.clearTrigger ?? `time-picker:${ctx.id}:clear-trigger`;\nvar getPositionerId = ctx => ctx.ids?.positioner ?? `time-picker:${ctx.id}:positioner`;\nvar getInputId = ctx => ctx.ids?.input ?? `time-picker:${ctx.id}:input`;\nvar getTriggerId = ctx => ctx.ids?.trigger ?? `time-picker:${ctx.id}:trigger`;\nvar getContentEl = ctx => ctx.getById(getContentId(ctx));\nvar getColumnEl = (ctx, unit) => query(getContentEl(ctx), `[data-part=column][data-unit=${unit}]`);\nvar getColumnEls = ctx => queryAll(getContentEl(ctx), `[data-part=column]:not([hidden])`);\nvar getColumnCellEls = (ctx, unit) => queryAll(getColumnEl(ctx, unit), `[data-part=cell]`);\nvar getControlEl = ctx => ctx.getById(getControlId(ctx));\nvar getClearTriggerEl = ctx => ctx.getById(getClearTriggerId(ctx));\nvar getPositionerEl = ctx => ctx.getById(getPositionerId(ctx));\nvar getInputEl = ctx => ctx.getById(getInputId(ctx));\nvar getTriggerEl = ctx => ctx.getById(getTriggerId(ctx));\nvar getFocusedCell = ctx => query(getContentEl(ctx), `[data-part=cell][data-focus]`);\nvar getInitialFocusCell = (ctx, unit) => {\n  const contentEl = getContentEl(ctx);\n  let cellEl = query(contentEl, `[data-part=cell][data-unit=${unit}][aria-current]`);\n  cellEl || (cellEl = query(contentEl, `[data-part=cell][data-unit=${unit}][data-now]`));\n  cellEl || (cellEl = query(contentEl, `[data-part=cell][data-unit=${unit}]`));\n  return cellEl;\n};\nvar getColumnUnit = el => el.dataset.unit;\nvar getCellValue = el => {\n  const value = el?.dataset.value;\n  return el?.dataset.unit === \"period\" ? value : Number(value ?? \"0\");\n};\nfunction getCurrentTime() {\n  const now = /* @__PURE__ */new Date();\n  return new Time(now.getHours(), now.getMinutes(), now.getSeconds());\n}\nvar padStart = value => value.toString().padStart(2, \"0\");\nfunction getValueString(value, hour12, period, allowSeconds) {\n  if (!value) return \"\";\n  let hourValue = value.hour;\n  if (hour12 && hourValue === 0) {\n    hourValue = 12;\n  } else if (hour12 && hourValue > 12) {\n    hourValue -= 12;\n  }\n  let result = `${padStart(hourValue)}:${padStart(value.minute)}`;\n  if (allowSeconds) {\n    const second = padStart(value.second);\n    result += `:${second}`;\n  }\n  if (hour12 && period) {\n    result += ` ${period.toUpperCase()}`;\n  }\n  return result;\n}\nvar TIME_REX = /(\\d{1,2}):(\\d{1,2})(?::(\\d{1,2}))?\\s?(AM|PM|am|pm)?/;\nfunction getTimeValue(locale, periodProp, value) {\n  const match2 = value.match(TIME_REX);\n  if (!match2) return;\n  let [, hourString, minuteString, secondString, periodString] = match2;\n  let hour = parseInt(hourString);\n  const minute = parseInt(minuteString);\n  const second = secondString ? parseInt(secondString) : void 0;\n  if (!is12HourFormat(locale) && periodProp) {\n    return {\n      time: new Time(hour, minute, second),\n      period: periodProp\n    };\n  }\n  let period = periodString ? periodString.toLowerCase() : \"am\";\n  if (hour > 11) {\n    period = \"pm\";\n  } else if (period === \"pm\") {\n    hour += 12;\n  }\n  return {\n    time: new Time(hour, minute, second),\n    period\n  };\n}\nfunction get12HourFormatPeriodHour(hour, period) {\n  if (!period) return hour;\n  return period === \"pm\" ? hour + 12 : hour;\n}\nfunction getHourPeriod(hour, locale) {\n  if (hour === void 0 || !is12HourFormat(locale)) return null;\n  return hour > 11 ? \"pm\" : \"am\";\n}\nfunction is12HourFormat(locale) {\n  return new Intl.DateTimeFormat(locale, {\n    hour: \"numeric\"\n  }).formatToParts(/* @__PURE__ */new Date()).some(part => part.type === \"dayPeriod\");\n}\nfunction getInputPlaceholder(placeholder, allowSeconds, locale) {\n  if (placeholder) return placeholder;\n  const secondsPart = allowSeconds ? \":ss\" : \"\";\n  const periodPart = is12HourFormat(locale) ? \" aa\" : \"\";\n  return `hh:mm${secondsPart}${periodPart}`;\n}\nfunction clampTime(value, min, max) {\n  let time = value;\n  if (min && min.compare(value) > 0) {\n    time = min.copy();\n  } else if (max && max.compare(value) < 0) {\n    time = max.copy();\n  }\n  return time;\n}\nfunction isTimeEqual(a, b) {\n  if (!a || !b) return false;\n  return a.hour === b.hour && a.minute === b.minute && a.second === b.second;\n}\n\n// src/time-picker.connect.ts\nfunction connect(service, normalize) {\n  const {\n    state,\n    send,\n    prop,\n    computed,\n    scope,\n    context\n  } = service;\n  const disabled = prop(\"disabled\");\n  const readOnly = prop(\"readOnly\");\n  const locale = prop(\"locale\");\n  const hour12 = is12HourFormat(locale);\n  const min = prop(\"min\");\n  const max = prop(\"max\");\n  const steps = prop(\"steps\");\n  const focused = state.matches(\"focused\");\n  const open = state.hasTag(\"open\");\n  const value = context.get(\"value\");\n  const valueAsString = computed(\"valueAsString\");\n  const currentTime = context.get(\"currentTime\");\n  const focusedColumn = context.get(\"focusedColumn\");\n  const currentPlacement = context.get(\"currentPlacement\");\n  const popperStyles = getPlacementStyles({\n    ...prop(\"positioning\"),\n    placement: currentPlacement\n  });\n  return {\n    focused,\n    open,\n    value,\n    valueAsString,\n    hour12,\n    reposition(options = {}) {\n      send({\n        type: \"POSITIONING.SET\",\n        options\n      });\n    },\n    setOpen(nextOpen) {\n      const open2 = state.hasTag(\"open\");\n      if (open2 === nextOpen) return;\n      send({\n        type: nextOpen ? \"OPEN\" : \"CLOSE\"\n      });\n    },\n    setUnitValue(unit, value2) {\n      send({\n        type: \"UNIT.SET\",\n        unit,\n        value: value2\n      });\n    },\n    setValue(value2) {\n      send({\n        type: \"VALUE.SET\",\n        value: value2\n      });\n    },\n    clearValue() {\n      send({\n        type: \"VALUE.CLEAR\"\n      });\n    },\n    getHours() {\n      const length = hour12 ? 12 : 24;\n      const arr = Array.from({\n        length\n      }, (_, i) => i);\n      const step = steps?.hour;\n      const hours = step != null ? arr.filter(hour => hour % step === 0) : arr;\n      return hours.map(value2 => ({\n        label: hour12 && value2 === 0 ? \"12\" : padStart(value2),\n        value: value2\n      }));\n    },\n    getMinutes() {\n      const arr = Array.from({\n        length: 60\n      }, (_, i) => i);\n      const step = steps?.minute;\n      const minutes = step != null ? arr.filter(minute => minute % step === 0) : arr;\n      return minutes.map(value2 => ({\n        label: padStart(value2),\n        value: value2\n      }));\n    },\n    getSeconds() {\n      const arr = Array.from({\n        length: 60\n      }, (_, i) => i);\n      const step = steps?.second;\n      const seconds = step != null ? arr.filter(second => second % step === 0) : arr;\n      return seconds.map(value2 => ({\n        label: padStart(value2),\n        value: value2\n      }));\n    },\n    getRootProps() {\n      return normalize.element({\n        ...parts.root.attrs,\n        \"data-state\": open ? \"open\" : \"closed\",\n        \"data-disabled\": dataAttr(disabled),\n        \"data-readonly\": dataAttr(readOnly)\n      });\n    },\n    getLabelProps() {\n      return normalize.label({\n        ...parts.label.attrs,\n        dir: prop(\"dir\"),\n        htmlFor: getInputId(scope),\n        \"data-state\": open ? \"open\" : \"closed\",\n        \"data-disabled\": dataAttr(disabled),\n        \"data-readonly\": dataAttr(readOnly)\n      });\n    },\n    getControlProps() {\n      return normalize.element({\n        ...parts.control.attrs,\n        dir: prop(\"dir\"),\n        id: getControlId(scope),\n        \"data-disabled\": dataAttr(disabled)\n      });\n    },\n    getInputProps() {\n      return normalize.input({\n        ...parts.input.attrs,\n        dir: prop(\"dir\"),\n        autoComplete: \"off\",\n        autoCorrect: \"off\",\n        spellCheck: \"false\",\n        id: getInputId(scope),\n        name: prop(\"name\"),\n        defaultValue: valueAsString,\n        placeholder: getInputPlaceholder(prop(\"placeholder\"), prop(\"allowSeconds\"), locale),\n        disabled,\n        readOnly,\n        onFocus() {\n          send({\n            type: \"INPUT.FOCUS\"\n          });\n        },\n        onBlur(event) {\n          send({\n            type: \"INPUT.BLUR\",\n            value: event.currentTarget.value\n          });\n        },\n        onKeyDown(event) {\n          if (isComposingEvent(event)) return;\n          if (event.key !== \"Enter\") return;\n          send({\n            type: \"INPUT.ENTER\",\n            value: event.currentTarget.value\n          });\n          event.preventDefault();\n        }\n      });\n    },\n    getTriggerProps() {\n      return normalize.button({\n        ...parts.trigger.attrs,\n        id: getTriggerId(scope),\n        type: \"button\",\n        \"data-placement\": currentPlacement,\n        disabled,\n        \"data-readonly\": dataAttr(readOnly),\n        \"aria-label\": open ? \"Close calendar\" : \"Open calendar\",\n        \"aria-controls\": getContentId(scope),\n        \"data-state\": open ? \"open\" : \"closed\",\n        onClick(event) {\n          if (event.defaultPrevented) return;\n          send({\n            type: \"TRIGGER.CLICK\"\n          });\n        }\n      });\n    },\n    getClearTriggerProps() {\n      return normalize.button({\n        ...parts.clearTrigger.attrs,\n        id: getClearTriggerId(scope),\n        type: \"button\",\n        hidden: !value,\n        disabled,\n        \"data-readonly\": dataAttr(readOnly),\n        \"aria-label\": \"Clear time\",\n        onClick(event) {\n          if (event.defaultPrevented) return;\n          send({\n            type: \"VALUE.CLEAR\"\n          });\n        }\n      });\n    },\n    getPositionerProps() {\n      return normalize.element({\n        ...parts.positioner.attrs,\n        dir: prop(\"dir\"),\n        id: getPositionerId(scope),\n        style: popperStyles.floating\n      });\n    },\n    getSpacerProps() {\n      return normalize.element({\n        ...parts.spacer.attrs\n      });\n    },\n    getContentProps() {\n      return normalize.element({\n        ...parts.content.attrs,\n        dir: prop(\"dir\"),\n        id: getContentId(scope),\n        hidden: !open,\n        tabIndex: 0,\n        role: \"application\",\n        \"data-state\": open ? \"open\" : \"closed\",\n        \"data-placement\": currentPlacement,\n        \"aria-roledescription\": \"timepicker\",\n        \"aria-label\": \"timepicker\",\n        onKeyDown(event) {\n          if (event.defaultPrevented) return;\n          if (isComposingEvent(event)) return;\n          const keyMap = {\n            ArrowUp() {\n              send({\n                type: \"CONTENT.ARROW_UP\"\n              });\n            },\n            ArrowDown() {\n              send({\n                type: \"CONTENT.ARROW_DOWN\"\n              });\n            },\n            ArrowLeft() {\n              send({\n                type: \"CONTENT.ARROW_LEFT\"\n              });\n            },\n            ArrowRight() {\n              send({\n                type: \"CONTENT.ARROW_RIGHT\"\n              });\n            },\n            Enter() {\n              send({\n                type: \"CONTENT.ENTER\"\n              });\n            },\n            // prevent tabbing out of the time picker\n            Tab() {},\n            Escape() {\n              if (!prop(\"disableLayer\")) return;\n              send({\n                type: \"CONTENT.ESCAPE\"\n              });\n            }\n          };\n          const exec = keyMap[getEventKey(event, {\n            dir: prop(\"dir\")\n          })];\n          if (exec) {\n            exec(event);\n            event.preventDefault();\n          }\n        }\n      });\n    },\n    getColumnProps(props2) {\n      const hidden = props2.unit === \"second\" && !prop(\"allowSeconds\") || props2.unit === \"period\" && !hour12;\n      return normalize.element({\n        ...parts.column.attrs,\n        id: getColumnId(scope, props2.unit),\n        \"data-unit\": props2.unit,\n        \"data-focus\": dataAttr(focusedColumn === props2.unit),\n        hidden\n      });\n    },\n    getHourCellProps(props2) {\n      const hour = props2.value;\n      const isSelectable = !(min && get12HourFormatPeriodHour(hour, computed(\"period\")) < min.hour || max && get12HourFormatPeriodHour(hour, computed(\"period\")) > max.hour);\n      const isSelected = value?.hour === get12HourFormatPeriodHour(hour, computed(\"period\"));\n      const isFocused = focusedColumn === \"hour\" && context.get(\"focusedValue\") === hour;\n      const currentHour = hour12 && currentTime ? currentTime?.hour % 12 : currentTime?.hour;\n      const isCurrent = currentHour === hour || hour === 12 && currentHour === 0;\n      return normalize.button({\n        ...parts.cell.attrs,\n        type: \"button\",\n        \"aria-disabled\": ariaAttr(!isSelectable),\n        \"data-disabled\": dataAttr(!isSelectable),\n        \"aria-current\": ariaAttr(isSelected),\n        \"data-selected\": dataAttr(isSelected),\n        \"data-now\": dataAttr(isCurrent),\n        \"data-focus\": dataAttr(isFocused),\n        \"aria-label\": `${hour} hours`,\n        \"data-value\": hour,\n        \"data-unit\": \"hour\",\n        onClick(event) {\n          if (event.defaultPrevented) return;\n          if (!isSelectable) return;\n          send({\n            type: \"UNIT.CLICK\",\n            unit: \"hour\",\n            value: hour\n          });\n        }\n      });\n    },\n    getMinuteCellProps(props2) {\n      const minute = props2.value;\n      const value2 = context.get(\"value\");\n      const minMinute = min?.set({\n        second: 0\n      });\n      const maxMinute = max?.set({\n        second: 0\n      });\n      const isSelectable = !(minMinute && value2 && minMinute.compare(value2.set({\n        minute\n      })) > 0 || maxMinute && value2 && maxMinute.compare(value2.set({\n        minute\n      })) < 0);\n      const isSelected = value2?.minute === minute;\n      const isCurrent = currentTime?.minute === minute;\n      const isFocused = focusedColumn === \"minute\" && context.get(\"focusedValue\") === minute;\n      return normalize.button({\n        ...parts.cell.attrs,\n        type: \"button\",\n        \"aria-disabled\": ariaAttr(!isSelectable),\n        \"data-disabled\": dataAttr(!isSelectable),\n        \"aria-current\": ariaAttr(isSelected),\n        \"data-selected\": dataAttr(isSelected),\n        \"aria-label\": `${minute} minutes`,\n        \"data-value\": minute,\n        \"data-now\": dataAttr(isCurrent),\n        \"data-focus\": dataAttr(isFocused),\n        \"data-unit\": \"minute\",\n        onClick(event) {\n          if (event.defaultPrevented) return;\n          if (!isSelectable) return;\n          send({\n            type: \"UNIT.CLICK\",\n            unit: \"minute\",\n            value: minute\n          });\n        }\n      });\n    },\n    getSecondCellProps(props2) {\n      const second = props2.value;\n      const isSelectable = !(min && value?.minute && min.compare(value.set({\n        second\n      })) > 0 || max && value?.minute && max.compare(value.set({\n        second\n      })) < 0);\n      const isSelected = value?.second === second;\n      const isCurrent = currentTime?.second === second;\n      const isFocused = focusedColumn === \"second\" && context.get(\"focusedValue\") === second;\n      return normalize.button({\n        ...parts.cell.attrs,\n        type: \"button\",\n        \"aria-disabled\": ariaAttr(!isSelectable),\n        \"data-disabled\": dataAttr(!isSelectable),\n        \"aria-current\": ariaAttr(isSelected),\n        \"data-selected\": dataAttr(isSelected),\n        \"aria-label\": `${second} seconds`,\n        \"data-value\": second,\n        \"data-unit\": \"second\",\n        \"data-focus\": dataAttr(isFocused),\n        \"data-now\": dataAttr(isCurrent),\n        onClick(event) {\n          if (event.defaultPrevented) return;\n          if (!isSelectable) return;\n          send({\n            type: \"UNIT.CLICK\",\n            unit: \"second\",\n            value: second\n          });\n        }\n      });\n    },\n    getPeriodCellProps(props2) {\n      const isSelected = computed(\"period\") === props2.value;\n      const currentPeriod = getHourPeriod(currentTime?.hour, locale);\n      const isCurrent = currentPeriod === props2.value;\n      const isFocused = focusedColumn === \"period\" && context.get(\"focusedValue\") === props2.value;\n      return normalize.button({\n        ...parts.cell.attrs,\n        type: \"button\",\n        \"aria-current\": ariaAttr(isSelected),\n        \"data-selected\": dataAttr(isSelected),\n        \"data-focus\": dataAttr(isFocused),\n        \"data-now\": dataAttr(isCurrent),\n        \"aria-label\": props2.value,\n        \"data-value\": props2.value,\n        \"data-unit\": \"period\",\n        onClick(event) {\n          if (event.defaultPrevented) return;\n          send({\n            type: \"UNIT.CLICK\",\n            unit: \"period\",\n            value: props2.value\n          });\n        }\n      });\n    }\n  };\n}\nvar {\n  and\n} = createGuards();\nvar machine = createMachine({\n  props({\n    props: props2\n  }) {\n    return {\n      locale: \"en-US\",\n      ...props2,\n      positioning: {\n        placement: \"bottom-start\",\n        gutter: 8,\n        ...props2.positioning\n      }\n    };\n  },\n  initialState({\n    prop\n  }) {\n    const open = prop(\"open\") || prop(\"defaultOpen\");\n    return open ? \"open\" : \"idle\";\n  },\n  context({\n    prop,\n    bindable,\n    getComputed\n  }) {\n    return {\n      value: bindable(() => ({\n        value: prop(\"value\"),\n        defaultValue: prop(\"defaultValue\"),\n        hash(a) {\n          return a?.toString() ?? \"\";\n        },\n        isEqual: isTimeEqual,\n        onChange(value) {\n          const computed = getComputed();\n          const valueAsString = getValueString(value, computed(\"hour12\"), computed(\"period\"), prop(\"allowSeconds\"));\n          prop(\"onValueChange\")?.({\n            value,\n            valueAsString\n          });\n        }\n      })),\n      focusedColumn: bindable(() => ({\n        defaultValue: \"hour\"\n      })),\n      focusedValue: bindable(() => ({\n        defaultValue: null\n      })),\n      currentTime: bindable(() => ({\n        defaultValue: null\n      })),\n      currentPlacement: bindable(() => ({\n        defaultValue: void 0\n      })),\n      restoreFocus: bindable(() => ({\n        defaultValue: void 0\n      }))\n    };\n  },\n  computed: {\n    valueAsString: ({\n      context,\n      prop,\n      computed\n    }) => getValueString(context.get(\"value\"), computed(\"hour12\"), computed(\"period\"), prop(\"allowSeconds\")),\n    hour12: ({\n      prop\n    }) => is12HourFormat(prop(\"locale\")),\n    period: ({\n      context,\n      prop\n    }) => getHourPeriod(context.get(\"value\")?.hour, prop(\"locale\"))\n  },\n  watch({\n    track,\n    action,\n    prop,\n    context,\n    computed\n  }) {\n    track([() => prop(\"open\")], () => {\n      action([\"toggleVisibility\"]);\n    });\n    track([() => context.hash(\"value\"), () => computed(\"period\")], () => {\n      action([\"syncInputElement\"]);\n    });\n    track([() => context.get(\"focusedColumn\")], () => {\n      action([\"syncFocusedValue\"]);\n    });\n    track([() => context.get(\"focusedValue\")], () => {\n      action([\"focusCell\"]);\n    });\n  },\n  on: {\n    \"VALUE.CLEAR\": {\n      actions: [\"clearValue\"]\n    },\n    \"VALUE.SET\": {\n      actions: [\"setValue\"]\n    },\n    \"UNIT.SET\": {\n      actions: [\"setUnitValue\"]\n    }\n  },\n  states: {\n    idle: {\n      tags: [\"closed\"],\n      on: {\n        \"INPUT.FOCUS\": {\n          target: \"focused\"\n        },\n        \"TRIGGER.CLICK\": [{\n          guard: \"isOpenControlled\",\n          actions: [\"invokeOnOpen\"]\n        }, {\n          target: \"open\",\n          actions: [\"invokeOnOpen\"]\n        }],\n        OPEN: [{\n          guard: \"isOpenControlled\",\n          actions: [\"invokeOnOpen\"]\n        }, {\n          target: \"open\",\n          actions: [\"invokeOnOpen\"]\n        }],\n        \"CONTROLLED.OPEN\": {\n          target: \"open\",\n          actions: [\"invokeOnOpen\"]\n        }\n      }\n    },\n    focused: {\n      tags: [\"closed\"],\n      on: {\n        \"TRIGGER.CLICK\": [{\n          guard: \"isOpenControlled\",\n          actions: [\"invokeOnOpen\"]\n        }, {\n          target: \"open\",\n          actions: [\"invokeOnOpen\"]\n        }],\n        OPEN: [{\n          guard: \"isOpenControlled\",\n          actions: [\"invokeOnOpen\"]\n        }, {\n          target: \"open\",\n          actions: [\"invokeOnOpen\"]\n        }],\n        \"INPUT.ENTER\": {\n          actions: [\"setInputValue\", \"clampTimeValue\"]\n        },\n        \"INPUT.BLUR\": {\n          target: \"idle\",\n          actions: [\"setInputValue\", \"clampTimeValue\"]\n        },\n        \"CONTROLLED.OPEN\": {\n          target: \"open\",\n          actions: [\"invokeOnOpen\"]\n        }\n      }\n    },\n    open: {\n      tags: [\"open\"],\n      entry: [\"setCurrentTime\", \"scrollColumnsToTop\", \"focusHourColumn\"],\n      exit: [\"resetFocusedCell\"],\n      effects: [\"computePlacement\", \"trackDismissableElement\"],\n      on: {\n        \"TRIGGER.CLICK\": [{\n          guard: \"isOpenControlled\",\n          actions: [\"invokeOnClose\"]\n        }, {\n          target: \"focused\",\n          actions: [\"invokeOnClose\"]\n        }],\n        \"INPUT.ENTER\": {\n          actions: [\"setInputValue\", \"clampTimeValue\"]\n        },\n        CLOSE: [{\n          guard: \"isOpenControlled\",\n          actions: [\"invokeOnClose\"]\n        }, {\n          target: \"idle\",\n          actions: [\"invokeOnClose\"]\n        }],\n        \"CONTROLLED.CLOSE\": [{\n          guard: and(\"shouldRestoreFocus\", \"isInteractOutsideEvent\"),\n          target: \"focused\",\n          actions: [\"focusTriggerElement\"]\n        }, {\n          guard: \"shouldRestoreFocus\",\n          target: \"focused\",\n          actions: [\"focusInputElement\"]\n        }, {\n          target: \"idle\"\n        }],\n        \"CONTENT.ESCAPE\": [{\n          guard: \"isOpenControlled\",\n          actions: [\"invokeOnClose\"]\n        }, {\n          target: \"focused\",\n          actions: [\"invokeOnClose\", \"focusInputElement\"]\n        }],\n        INTERACT_OUTSIDE: [{\n          guard: \"isOpenControlled\",\n          actions: [\"invokeOnClose\"]\n        }, {\n          guard: \"shouldRestoreFocus\",\n          target: \"focused\",\n          actions: [\"invokeOnClose\", \"focusTriggerElement\"]\n        }, {\n          target: \"idle\",\n          actions: [\"invokeOnClose\"]\n        }],\n        \"POSITIONING.SET\": {\n          actions: [\"reposition\"]\n        },\n        \"UNIT.CLICK\": {\n          actions: [\"setFocusedValue\", \"setFocusedColumn\", \"setUnitValue\"]\n        },\n        \"CONTENT.ARROW_UP\": {\n          actions: [\"focusPreviousCell\"]\n        },\n        \"CONTENT.ARROW_DOWN\": {\n          actions: [\"focusNextCell\"]\n        },\n        \"CONTENT.ARROW_LEFT\": {\n          actions: [\"focusPreviousColumnCell\"]\n        },\n        \"CONTENT.ARROW_RIGHT\": {\n          actions: [\"focusNextColumnCell\"]\n        },\n        \"CONTENT.ENTER\": {\n          actions: [\"selectFocusedCell\", \"focusNextColumnCell\"]\n        }\n      }\n    }\n  },\n  implementations: {\n    guards: {\n      shouldRestoreFocus: ({\n        context\n      }) => !!context.get(\"restoreFocus\"),\n      isOpenControlled: ({\n        prop\n      }) => prop(\"open\") != null,\n      isInteractOutsideEvent: ({\n        event\n      }) => event.previousEvent?.type === \"INTERACT_OUTSIDE\"\n    },\n    effects: {\n      computePlacement({\n        context,\n        prop,\n        scope\n      }) {\n        context.set(\"currentPlacement\", prop(\"positioning\").placement);\n        const anchorEl = () => getControlEl(scope);\n        const positionerEl = () => getPositionerEl(scope);\n        return getPlacement(anchorEl, positionerEl, {\n          defer: true,\n          ...prop(\"positioning\"),\n          onComplete(data) {\n            context.set(\"currentPlacement\", data.placement);\n          }\n        });\n      },\n      trackDismissableElement({\n        context,\n        prop,\n        scope,\n        send\n      }) {\n        if (prop(\"disableLayer\")) return;\n        const contentEl = () => getContentEl(scope);\n        return trackDismissableElement(contentEl, {\n          defer: true,\n          exclude: [getTriggerEl(scope), getClearTriggerEl(scope)],\n          onEscapeKeyDown(event) {\n            event.preventDefault();\n            context.set(\"restoreFocus\", true);\n            send({\n              type: \"CONTENT.ESCAPE\"\n            });\n          },\n          onInteractOutside(event) {\n            context.set(\"restoreFocus\", !event.detail.focusable);\n          },\n          onDismiss() {\n            send({\n              type: \"INTERACT_OUTSIDE\"\n            });\n          }\n        });\n      }\n    },\n    actions: {\n      reposition({\n        context,\n        prop,\n        scope,\n        event\n      }) {\n        const positionerEl = () => getPositionerEl(scope);\n        getPlacement(getTriggerEl(scope), positionerEl, {\n          ...prop(\"positioning\"),\n          ...event.options,\n          defer: true,\n          listeners: false,\n          onComplete(data) {\n            context.set(\"currentPlacement\", data.placement);\n          }\n        });\n      },\n      toggleVisibility({\n        prop,\n        send,\n        event\n      }) {\n        send({\n          type: prop(\"open\") ? \"CONTROLLED.OPEN\" : \"CONTROLLED.CLOSE\",\n          previousEvent: event\n        });\n      },\n      invokeOnOpen({\n        prop\n      }) {\n        prop(\"onOpenChange\")?.({\n          open: true\n        });\n      },\n      invokeOnClose({\n        prop\n      }) {\n        prop(\"onOpenChange\")?.({\n          open: false\n        });\n      },\n      setInputValue({\n        context,\n        event,\n        prop,\n        computed\n      }) {\n        const timeValue = getTimeValue(prop(\"locale\"), computed(\"period\"), event.value);\n        if (!timeValue) return;\n        context.set(\"value\", timeValue.time);\n      },\n      syncInputElement({\n        scope,\n        computed\n      }) {\n        const inputEl = getInputEl(scope);\n        if (!inputEl) return;\n        inputEl.value = computed(\"valueAsString\");\n      },\n      setUnitValue({\n        context,\n        event,\n        computed\n      }) {\n        const {\n          unit,\n          value\n        } = event;\n        const _value = context.get(\"value\");\n        const current = _value ?? context.get(\"currentTime\") ?? new Time(0);\n        const nextTime = match(unit, {\n          hour: () => current.set({\n            hour: computed(\"hour12\") ? value + 12 : value\n          }),\n          minute: () => current.set({\n            minute: value\n          }),\n          second: () => current.set({\n            second: value\n          }),\n          period: () => {\n            if (!_value) return;\n            const diff = value === \"pm\" ? 12 : 0;\n            return _value.set({\n              hour: _value.hour % 12 + diff\n            });\n          }\n        });\n        if (!nextTime) return;\n        context.set(\"value\", nextTime);\n      },\n      setValue({\n        context,\n        event\n      }) {\n        if (!(event.value instanceof Time)) return;\n        context.set(\"value\", event.value);\n      },\n      clearValue({\n        context\n      }) {\n        context.set(\"value\", null);\n      },\n      setFocusedValue({\n        context,\n        event\n      }) {\n        context.set(\"focusedValue\", event.value);\n      },\n      setFocusedColumn({\n        context,\n        event\n      }) {\n        context.set(\"focusedColumn\", event.unit);\n      },\n      resetFocusedCell({\n        context\n      }) {\n        context.set(\"focusedColumn\", \"hour\");\n        context.set(\"focusedValue\", null);\n      },\n      clampTimeValue({\n        context,\n        prop\n      }) {\n        const value = context.get(\"value\");\n        if (!value) return;\n        const nextTime = clampTime(value, prop(\"min\"), prop(\"max\"));\n        context.set(\"value\", nextTime);\n      },\n      setCurrentTime({\n        context\n      }) {\n        context.set(\"currentTime\", getCurrentTime());\n      },\n      scrollColumnsToTop({\n        scope\n      }) {\n        raf(() => {\n          const columnEls = getColumnEls(scope);\n          for (const columnEl of columnEls) {\n            const cellEl = getInitialFocusCell(scope, columnEl.dataset.unit);\n            if (!cellEl) continue;\n            columnEl.scrollTop = cellEl.offsetTop - 4;\n          }\n        });\n      },\n      focusTriggerElement({\n        scope\n      }) {\n        getTriggerEl(scope)?.focus({\n          preventScroll: true\n        });\n      },\n      focusInputElement({\n        scope\n      }) {\n        getInputEl(scope)?.focus({\n          preventScroll: true\n        });\n      },\n      focusHourColumn({\n        context,\n        scope\n      }) {\n        raf(() => {\n          const hourEl = getInitialFocusCell(scope, \"hour\");\n          if (!hourEl) return;\n          context.set(\"focusedValue\", getCellValue(hourEl));\n        });\n      },\n      focusPreviousCell({\n        context,\n        scope\n      }) {\n        raf(() => {\n          const cells = getColumnCellEls(scope, context.get(\"focusedColumn\"));\n          const focusedEl = getFocusedCell(scope);\n          const focusedIndex = focusedEl ? cells.indexOf(focusedEl) : -1;\n          const prevCell = prev(cells, focusedIndex, {\n            loop: false\n          });\n          if (!prevCell) return;\n          context.set(\"focusedValue\", getCellValue(prevCell));\n        });\n      },\n      focusNextCell({\n        context,\n        scope\n      }) {\n        raf(() => {\n          const cells = getColumnCellEls(scope, context.get(\"focusedColumn\"));\n          const focusedEl = getFocusedCell(scope);\n          const focusedIndex = focusedEl ? cells.indexOf(focusedEl) : -1;\n          const nextCell = next(cells, focusedIndex, {\n            loop: false\n          });\n          if (!nextCell) return;\n          context.set(\"focusedValue\", getCellValue(nextCell));\n        });\n      },\n      selectFocusedCell({\n        context,\n        computed\n      }) {\n        const current = context.get(\"value\") ?? context.get(\"currentTime\") ?? new Time(0);\n        let value = context.get(\"focusedValue\");\n        let column = context.get(\"focusedColumn\");\n        if (column === \"hour\" && computed(\"hour12\")) {\n          value = computed(\"hour12\") ? value + 12 : value;\n        } else if (context.get(\"focusedColumn\") === \"period\") {\n          column = \"hour\";\n          const diff = value === \"pm\" ? 12 : 0;\n          value = current.hour % 12 + diff;\n        }\n        const nextTime = current.set({\n          [column]: value\n        });\n        context.set(\"value\", nextTime);\n      },\n      focusPreviousColumnCell({\n        context,\n        scope\n      }) {\n        raf(() => {\n          const columns = getColumnEls(scope);\n          const currentColumnEl = getColumnEl(scope, context.get(\"focusedColumn\"));\n          const focusedIndex = columns.indexOf(currentColumnEl);\n          const prevColumnEl = prev(columns, focusedIndex, {\n            loop: false\n          });\n          if (!prevColumnEl) return;\n          context.set(\"focusedColumn\", getColumnUnit(prevColumnEl));\n        });\n      },\n      focusNextColumnCell({\n        context,\n        scope\n      }) {\n        raf(() => {\n          const columns = getColumnEls(scope);\n          const currentColumnEl = getColumnEl(scope, context.get(\"focusedColumn\"));\n          const focusedIndex = columns.indexOf(currentColumnEl);\n          const nextColumnEl = next(columns, focusedIndex, {\n            loop: false\n          });\n          if (!nextColumnEl) return;\n          context.set(\"focusedColumn\", getColumnUnit(nextColumnEl));\n        });\n      },\n      focusCell({\n        scope\n      }) {\n        queueMicrotask(() => {\n          const cellEl = getFocusedCell(scope);\n          cellEl?.focus();\n        });\n      },\n      syncFocusedValue({\n        context,\n        scope\n      }) {\n        if (context.get(\"focusedValue\") === null) return;\n        queueMicrotask(() => {\n          const cellEl = getInitialFocusCell(scope, context.get(\"focusedColumn\"));\n          context.set(\"focusedValue\", getCellValue(cellEl));\n        });\n      }\n    }\n  }\n});\nfunction parse(value) {\n  return new Time(value.hour, value.minute, value.second, value.millisecond);\n}\nvar props = createProps()([\"dir\", \"disabled\", \"disableLayer\", \"getRootNode\", \"id\", \"ids\", \"locale\", \"max\", \"min\", \"name\", \"onFocusChange\", \"onOpenChange\", \"onValueChange\", \"open\", \"placeholder\", \"positioning\", \"readOnly\", \"steps\", \"value\", \"allowSeconds\", \"defaultValue\", \"defaultOpen\"]);\nvar splitProps = createSplitProps(props);\nexport { anatomy, connect, machine, parse, props, splitProps };","map":null,"metadata":{},"sourceType":"module"}