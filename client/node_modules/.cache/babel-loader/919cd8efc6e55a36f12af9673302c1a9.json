{"ast":null,"code":"import { createAnatomy } from '@zag-js/anatomy';\nimport { trackPointerMove, getRelativePoint, getDataUrl as getDataUrl$1, query, dataAttr, isLeftClick, isModifierKey, getEventTarget } from '@zag-js/dom-query';\nimport { createMachine } from '@zag-js/core';\nimport getStroke from 'perfect-freehand';\nimport { createProps } from '@zag-js/types';\nimport { createSplitProps } from '@zag-js/utils';\n\n// src/signature-pad.anatomy.ts\nvar anatomy = createAnatomy(\"signature-pad\").parts(\"root\", \"control\", \"segment\", \"segmentPath\", \"guide\", \"clearTrigger\", \"label\");\nvar parts = anatomy.build();\nvar getRootId = ctx => ctx.ids?.root ?? `signature-${ctx.id}`;\nvar getControlId = ctx => ctx.ids?.control ?? `signature-control-${ctx.id}`;\nvar getLabelId = ctx => ctx.ids?.label ?? `signature-label-${ctx.id}`;\nvar getHiddenInputId = ctx => ctx.ids?.hiddenInput ?? `signature-input-${ctx.id}`;\nvar getControlEl = ctx => ctx.getById(getControlId(ctx));\nvar getSegmentEl = ctx => query(getControlEl(ctx), \"[data-part=segment]\");\nvar getDataUrl = (ctx, options) => {\n  return getDataUrl$1(getSegmentEl(ctx), options);\n};\n\n// src/signature-pad.connect.ts\nfunction connect(service, normalize) {\n  const {\n    state,\n    send,\n    prop,\n    computed,\n    context,\n    scope\n  } = service;\n  const drawing = state.matches(\"drawing\");\n  const empty = computed(\"isEmpty\");\n  const interactive = computed(\"isInteractive\");\n  const disabled = prop(\"disabled\");\n  const translations = prop(\"translations\");\n  return {\n    empty,\n    drawing,\n    currentPath: context.get(\"currentPath\"),\n    paths: context.get(\"paths\"),\n    clear() {\n      send({\n        type: \"CLEAR\"\n      });\n    },\n    getDataUrl(type, quality) {\n      if (computed(\"isEmpty\")) return Promise.resolve(\"\");\n      return getDataUrl(scope, {\n        type,\n        quality\n      });\n    },\n    getLabelProps() {\n      return normalize.label({\n        ...parts.label.attrs,\n        id: getLabelId(scope),\n        \"data-disabled\": dataAttr(disabled),\n        htmlFor: getHiddenInputId(scope),\n        onClick(event) {\n          if (!interactive) return;\n          if (event.defaultPrevented) return;\n          const controlEl = getControlEl(scope);\n          controlEl?.focus({\n            preventScroll: true\n          });\n        }\n      });\n    },\n    getRootProps() {\n      return normalize.element({\n        ...parts.root.attrs,\n        \"data-disabled\": dataAttr(disabled),\n        id: getRootId(scope)\n      });\n    },\n    getControlProps() {\n      return normalize.element({\n        ...parts.control.attrs,\n        tabIndex: disabled ? void 0 : 0,\n        id: getControlId(scope),\n        role: \"application\",\n        \"aria-roledescription\": \"signature pad\",\n        \"aria-label\": translations.control,\n        \"aria-disabled\": disabled,\n        \"data-disabled\": dataAttr(disabled),\n        onPointerDown(event) {\n          if (!isLeftClick(event)) return;\n          if (isModifierKey(event)) return;\n          if (!interactive) return;\n          const target = getEventTarget(event);\n          if (target?.closest(\"[data-part=clear-trigger]\")) return;\n          event.currentTarget.setPointerCapture(event.pointerId);\n          const point = {\n            x: event.clientX,\n            y: event.clientY\n          };\n          const controlEl = getControlEl(scope);\n          if (!controlEl) return;\n          const {\n            offset\n          } = getRelativePoint(point, controlEl);\n          send({\n            type: \"POINTER_DOWN\",\n            point: offset,\n            pressure: event.pressure\n          });\n        },\n        onPointerUp(event) {\n          if (!interactive) return;\n          if (event.currentTarget.hasPointerCapture(event.pointerId)) {\n            event.currentTarget.releasePointerCapture(event.pointerId);\n          }\n        },\n        style: {\n          position: \"relative\",\n          touchAction: \"none\",\n          userSelect: \"none\",\n          WebkitUserSelect: \"none\"\n        }\n      });\n    },\n    getSegmentProps() {\n      return normalize.svg({\n        ...parts.segment.attrs,\n        style: {\n          position: \"absolute\",\n          top: 0,\n          left: 0,\n          width: \"100%\",\n          height: \"100%\",\n          pointerEvents: \"none\",\n          fill: prop(\"drawing\").fill\n        }\n      });\n    },\n    getSegmentPathProps(props2) {\n      return normalize.path({\n        ...parts.segmentPath.attrs,\n        d: props2.path\n      });\n    },\n    getGuideProps() {\n      return normalize.element({\n        ...parts.guide.attrs,\n        \"data-disabled\": dataAttr(disabled)\n      });\n    },\n    getClearTriggerProps() {\n      return normalize.button({\n        ...parts.clearTrigger.attrs,\n        type: \"button\",\n        \"aria-label\": translations.clearTrigger,\n        hidden: !context.get(\"paths\").length || drawing,\n        disabled,\n        onClick() {\n          send({\n            type: \"CLEAR\"\n          });\n        }\n      });\n    },\n    getHiddenInputProps(props2) {\n      return normalize.input({\n        id: getHiddenInputId(scope),\n        type: \"text\",\n        hidden: true,\n        disabled,\n        required: prop(\"required\"),\n        readOnly: true,\n        name: prop(\"name\"),\n        value: props2.value\n      });\n    }\n  };\n}\n\n// src/get-svg-path.ts\nvar average = (a, b) => (a + b) / 2;\nfunction getSvgPathFromStroke(points, closed = true) {\n  const len = points.length;\n  if (len < 4) {\n    return \"\";\n  }\n  let a = points[0];\n  let b = points[1];\n  const c = points[2];\n  let result = `M${a[0].toFixed(2)},${a[1].toFixed(2)} Q${b[0].toFixed(2)},${b[1].toFixed(2)} ${average(b[0], c[0]).toFixed(2)},${average(b[1], c[1]).toFixed(2)} T`;\n  for (let i = 2, max = len - 1; i < max; i++) {\n    a = points[i];\n    b = points[i + 1];\n    result += `${average(a[0], b[0]).toFixed(2)},${average(a[1], b[1]).toFixed(2)} `;\n  }\n  if (closed) {\n    result += \"Z\";\n  }\n  return result;\n}\n\n// src/signature-pad.machine.ts\nvar machine = createMachine({\n  props({\n    props: props2\n  }) {\n    return {\n      ...props2,\n      drawing: {\n        size: 2,\n        simulatePressure: false,\n        thinning: 0.7,\n        smoothing: 0.4,\n        streamline: 0.6,\n        ...props2.drawing\n      },\n      translations: {\n        control: \"signature pad\",\n        clearTrigger: \"clear signature\",\n        ...props2.translations\n      }\n    };\n  },\n  initialState() {\n    return \"idle\";\n  },\n  context({\n    prop,\n    bindable\n  }) {\n    return {\n      paths: bindable(() => ({\n        defaultValue: [],\n        sync: true,\n        onChange(value) {\n          prop(\"onDraw\")?.({\n            paths: value\n          });\n        }\n      })),\n      currentPoints: bindable(() => ({\n        defaultValue: []\n      })),\n      currentPath: bindable(() => ({\n        defaultValue: null\n      }))\n    };\n  },\n  computed: {\n    isInteractive: ({\n      prop\n    }) => !(prop(\"disabled\") || prop(\"readOnly\")),\n    isEmpty: ({\n      context\n    }) => context.get(\"paths\").length === 0\n  },\n  on: {\n    CLEAR: {\n      actions: [\"clearPoints\", \"invokeOnDrawEnd\", \"focusCanvasEl\"]\n    }\n  },\n  states: {\n    idle: {\n      on: {\n        POINTER_DOWN: {\n          target: \"drawing\",\n          actions: [\"addPoint\"]\n        }\n      }\n    },\n    drawing: {\n      effects: [\"trackPointerMove\"],\n      on: {\n        POINTER_MOVE: {\n          actions: [\"addPoint\", \"invokeOnDraw\"]\n        },\n        POINTER_UP: {\n          target: \"idle\",\n          actions: [\"endStroke\", \"invokeOnDrawEnd\"]\n        }\n      }\n    }\n  },\n  implementations: {\n    effects: {\n      trackPointerMove({\n        scope,\n        send\n      }) {\n        const doc = scope.getDoc();\n        return trackPointerMove(doc, {\n          onPointerMove({\n            event,\n            point\n          }) {\n            const controlEl = getControlEl(scope);\n            if (!controlEl) return;\n            const {\n              offset\n            } = getRelativePoint(point, controlEl);\n            send({\n              type: \"POINTER_MOVE\",\n              point: offset,\n              pressure: event.pressure\n            });\n          },\n          onPointerUp() {\n            send({\n              type: \"POINTER_UP\"\n            });\n          }\n        });\n      }\n    },\n    actions: {\n      addPoint({\n        context,\n        event,\n        prop\n      }) {\n        const nextPoints = [...context.get(\"currentPoints\"), event.point];\n        context.set(\"currentPoints\", nextPoints);\n        const stroke = getStroke(nextPoints, prop(\"drawing\"));\n        context.set(\"currentPath\", getSvgPathFromStroke(stroke));\n      },\n      endStroke({\n        context\n      }) {\n        context.set(\"paths\", [...context.get(\"paths\"), context.get(\"currentPath\")]);\n        context.set(\"currentPoints\", []);\n        context.set(\"currentPath\", null);\n      },\n      clearPoints({\n        context\n      }) {\n        context.set(\"currentPoints\", []);\n        context.set(\"paths\", []);\n      },\n      focusCanvasEl({\n        scope\n      }) {\n        queueMicrotask(() => {\n          scope.getActiveElement()?.focus({\n            preventScroll: true\n          });\n        });\n      },\n      invokeOnDraw({\n        context,\n        prop\n      }) {\n        prop(\"onDraw\")?.({\n          paths: [...context.get(\"paths\"), context.get(\"currentPath\")]\n        });\n      },\n      invokeOnDrawEnd({\n        context,\n        prop,\n        scope,\n        computed\n      }) {\n        prop(\"onDrawEnd\")?.({\n          paths: [...context.get(\"paths\")],\n          getDataUrl(type, quality = 0.92) {\n            if (computed(\"isEmpty\")) return Promise.resolve(\"\");\n            return getDataUrl(scope, {\n              type,\n              quality\n            });\n          }\n        });\n      }\n    }\n  }\n});\nvar props = createProps()([\"dir\", \"disabled\", \"drawing\", \"getRootNode\", \"id\", \"ids\", \"name\", \"onDraw\", \"onDrawEnd\", \"readOnly\", \"required\", \"translations\"]);\nvar splitProps = createSplitProps(props);\nexport { anatomy, connect, machine, props, splitProps };","map":null,"metadata":{},"sourceType":"module"}